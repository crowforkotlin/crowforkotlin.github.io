<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android 2025 热修复、动态化方案研究报告</title>
      <link href="/2025/10/28/Android/Android%E7%83%AD%E4%BF%AE%E5%92%8C%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88/"/>
      <url>/2025/10/28/Android/Android%E7%83%AD%E4%BF%AE%E5%92%8C%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-2025-热修复与动态化方案研究报告"><a href="#Android-2025-热修复与动态化方案研究报告" class="headerlink" title="Android 2025 热修复与动态化方案研究报告"></a>Android 2025 热修复与动态化方案研究报告</h1><h2 id="一、热修复方案对比"><a href="#一、热修复方案对比" class="headerlink" title="一、热修复方案对比"></a>一、热修复方案对比</h2><p>热修复方案的核心在于对已发布应用的代码进行即时修复，无需重新发布版本。以下是几种主流方案的特性对比：</p><table><thead><tr><th align="left">特性</th><th align="left">Tinker (腾讯)</th><th align="left">QZone (腾讯)</th><th align="left">AndFix (阿里)</th><th align="left">Robust (美团)</th></tr></thead><tbody><tr><td align="left"><strong>类替换</strong></td><td align="left">✅ 支持</td><td align="left">✅ 支持</td><td align="left">❌ 不支持</td><td align="left">❌ 不支持</td></tr><tr><td align="left"><strong>So 替换</strong></td><td align="left">✅ 支持</td><td align="left">❌ 不支持</td><td align="left">❌ 不支持</td><td align="left">❌ 不支持</td></tr><tr><td align="left"><strong>资源替换</strong></td><td align="left">✅ 支持</td><td align="left">✅ 支持</td><td align="left">❌ 不支持</td><td align="left">❌ 不支持</td></tr><tr><td align="left"><strong>全平台支持</strong></td><td align="left">✅ 支持</td><td align="left">✅ 支持</td><td align="left">✅ 支持</td><td align="left">✅ 支持</td></tr><tr><td align="left"><strong>即时生效</strong></td><td align="left">❌ 需重启</td><td align="left">❌ 需重启</td><td align="left">✅ 支持</td><td align="left">✅ 支持</td></tr><tr><td align="left"><strong>性能损耗</strong></td><td align="left">较小</td><td align="left">较大</td><td align="left">较小</td><td align="left">较小</td></tr><tr><td align="left"><strong>补丁包大小</strong></td><td align="left">较小</td><td align="left">较大</td><td align="left">一般</td><td align="left">一般</td></tr><tr><td align="left"><strong>开发透明</strong></td><td align="left">✅ 是</td><td align="left">✅ 是</td><td align="left">❌ 否</td><td align="left">❌ 否</td></tr><tr><td align="left"><strong>复杂度</strong></td><td align="left">较低</td><td align="left">较低</td><td align="left">复杂</td><td align="left">复杂</td></tr><tr><td align="left"><strong>Gradle 支持</strong></td><td align="left">✅ 支持</td><td align="left">❌ 不支持</td><td align="left">❌ 不支持</td><td align="left">❌ 不支持</td></tr><tr><td align="left"><strong>Rom 体积</strong></td><td align="left">较大</td><td align="left">较小</td><td align="left">较小</td><td align="left">较小</td></tr><tr><td align="left"><strong>成功率</strong></td><td align="left">较高</td><td align="left">较高</td><td align="left">一般</td><td align="left"><strong>最高</strong></td></tr></tbody></table><p><strong>核心结论：</strong><br>目前，多数主流开源热修复框架（如 AndFix, Robust）已长期未维护。<strong>Tinker</strong> 是当前社区内依然活跃并推荐使用的方案。</p><h3 id="1-Tinker-方案的潜在问题-v1-9-15-2"><a href="#1-Tinker-方案的潜在问题-v1-9-15-2" class="headerlink" title="1. Tinker 方案的潜在问题 (v1.9.15.2)"></a>1. Tinker 方案的潜在问题 (v1.9.15.2)</h3><p>尽管 Tinker 是首选，但在集成到大型项目中时，仍需注意以下挑战：</p><ol><li><strong>Gradle 兼容性问题：</strong> 官方版本对 Gradle 7+ 的支持不佳，直接升级可能会引发编译异常。</li><li><strong>编译打包冲突：</strong><ul><li>当项目依赖了较高版本的 Material 组件 (如 v1.13.0+) 或其他复杂库时，R8 混淆过程极易出现 <code>XXX which is not in loader class</code> 的类丢失错误。</li><li>官方建议通过配置白名单解决，但实际操作中可能依然无法彻底解决问题，有时不得不降级依赖版本。</li></ul></li><li><strong>Application 改造：</strong><ul><li>官方要求 <code>Application</code> 类中不能包含业务逻辑，以避免补丁构建失败。</li><li>对于已有项目，这意味着需要进行大量重构，将相关逻辑封装并通过反射调用，适配成本较高。</li></ul></li></ol><h3 id="2-Shiply-基于-Tinker-的商业化方案"><a href="#2-Shiply-基于-Tinker-的商业化方案" class="headerlink" title="2. Shiply (基于 Tinker 的商业化方案)"></a>2. Shiply (基于 Tinker 的商业化方案)</h3><ul><li><strong>优点：</strong> 基于 Tinker 扩展，原生支持 Gradle 8+，并提供了 Web 控制台用于补丁管理，方案更加成熟。</li><li><strong>缺点：</strong> 依然继承了 Tinker 底层的核心问题，如编译冲突和 Application 改造的复杂性。</li></ul><blockquote><p><strong>参考资料:</strong> <a href="https://shiply.tds.qq.com/document/hotfix/faq/">Tinker&#x2F;Shiply 常见问题</a></p></blockquote><h3 id="3-热修复方案总结"><a href="#3-热修复方案总结" class="headerlink" title="3. 热修复方案总结"></a>3. 热修复方案总结</h3><ul><li><strong>优点：</strong><ul><li>能够动态修复线上代码，灵活性高。</li><li>补丁产物较小，对性能影响可控。</li></ul></li><li><strong>缺点：</strong><ul><li><strong>集成成本高：</strong> 引入现有大型项目时，解决编译打包问题、重构 Application 类等工作耗时耗力。</li><li><strong>兼容性风险：</strong> 容易与项目中的第三方依赖产生冲突，稳定性需要充分测试。</li></ul></li></ul><hr><h2 id="二、动态化方案"><a href="#二、动态化方案" class="headerlink" title="二、动态化方案"></a>二、动态化方案</h2><p>动态化与热修复不同，它更侧重于功能模块的动态下发和执行，而非仅仅是代码“打补丁”。</p><ul><li><strong>实现方式 1 (语言解释器)：</strong> 通过内置的语言解释器（如 JavaScript 引擎）执行插件代码，并桥接到原生平台 API。</li><li><strong>实现方式 2 (插件化框架)：</strong> 通过 Hook 原生实现，动态加载插件文件（如 APK）来执行逻辑，对宿主代码的修改能力有限。</li></ul><h3 id="1-Shadow-腾讯插件化方案"><a href="#1-Shadow-腾讯插件化方案" class="headerlink" title="1. Shadow (腾讯插件化方案)"></a>1. Shadow (腾讯插件化方案)</h3><ul><li><strong>核心特性：</strong> 零反射、全动态的 Android 插件框架，插件产物为 APK 压缩后的 ZIP 文件。</li><li><strong>优点：</strong> 性能接近原生，产物小，已支持原生四大组件等能力。</li><li><strong>商业版：</strong> <a href="https://shiply.tds.qq.com/document/android-plugin/overview/">Shiply 动态化</a> 基于 Shadow 实现，提供 Web 控制台管理，但部分高级能力需申请开放。</li></ul><h3 id="2-Zipline-Kotlin-Multiplatform-方案"><a href="#2-Zipline-Kotlin-Multiplatform-方案" class="headerlink" title="2. Zipline (Kotlin Multiplatform 方案)"></a>2. Zipline (Kotlin Multiplatform 方案)</h3><ul><li><strong>核心特性：</strong> 通过内置的 QuickJS 引擎解释并执行 JS 代码，桥接到原生平台（Android, iOS, Desktop）。插件文件是 JS 编译后的二进制 <code>.zipline</code> 文件。</li><li><strong>优点：</strong> 跨平台，项目结构清晰。</li><li><strong>缺点：</strong> 不直接支持原生能力，需要自行扩展桥接实现；产物较大，性能相比原生有一定损耗。</li></ul><h3 id="3-动态化方案总结"><a href="#3-动态化方案总结" class="headerlink" title="3. 动态化方案总结"></a>3. 动态化方案总结</h3><ul><li><strong>优点：</strong><ul><li>适配和兼容过程通常比热修复简单。</li><li>插件化使得模块分离，项目结构更清晰。</li></ul></li><li><strong>缺点：</strong><ul><li>部分框架的插件产物较大。</li><li>依赖解释器的方案性能略低于原生。</li><li>通常无法修复未预先扩展的宿主代码。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 热修复 </tag>
            
            <tag> 热加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin Compiler (1) FIR &amp; IR测试</title>
      <link href="/2025/10/22/Kotlin/Kotlin%20Compiler%20(1)%20FIR%20IR%E6%B5%8B%E8%AF%95/"/>
      <url>/2025/10/22/Kotlin/Kotlin%20Compiler%20(1)%20FIR%20IR%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="深入探索-Kotlin-编译器：FIR-与-IR-插件测试"><a href="#深入探索-Kotlin-编译器：FIR-与-IR-插件测试" class="headerlink" title="深入探索 Kotlin 编译器：FIR 与 IR 插件测试"></a>深入探索 Kotlin 编译器：FIR 与 IR 插件测试</h1><blockquote><p>本文深入探讨 Kotlin 编译器插件的测试机制，核心围绕两种测试类型：用于验证编译时错误的 “诊断测试 (Diagnostic Test)”，和用于验证运行时行为的 “黑盒代码生成测试 (Box Test)”。我们将以官方的 <a href="https://github.com/Kotlin/compiler-plugin-template">Kotlin&#x2F;compiler-plugin-template</a> 项目为例，揭示测试指令（Test Directives）如何驱动复杂的测试流程，并阐明测试类的继承关系如何决定测试的行为与验证逻辑。</p></blockquote><h2 id="核心测试类型"><a href="#核心测试类型" class="headerlink" title="核心测试类型"></a>核心测试类型</h2><p>在 Kotlin 编译器插件模板项目中，主要通过以下两种测试类型来确保插件的正确性：</p><ol><li><p><strong>诊断测试 (Diagnostic Test)</strong><br>此测试的核心目标是验证编译器在特定阶段能否正确报告预期的编译错误或警告。它通过分析源码，在编译流程的某个指定阶段（如 <code>FRONTEND</code>）停下来，检查编译器输出的诊断信息是否与预期完全一致。这种测试不关心代码能否最终运行，只关心编译过程的正确性。</p></li><li><p><strong>黑盒代码生成测试 (Box Test)</strong><br>黑盒测试关注的是“输入”与“最终输出”的对应关系，而不关心编译器的内部实现细节。测试流程会将一段合法的 Kotlin 源码作为输入，完整地执行编译、代码生成和运行，最后验证程序的运行时输出是否符合预期。这种测试用于确保编译器插件在修改代码后，其运行时行为仍然正确。</p></li></ol><h2 id="项目结构解析"><a href="#项目结构解析" class="headerlink" title="项目结构解析"></a>项目结构解析</h2><p>分析的源码基于官方的 <a href="https://github.com/Kotlin/compiler-plugin-template">Kotlin&#x2F;compiler-plugin-template</a>。该模板项目为开发编译器插件提供了标准的结构和测试框架。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">├───.github</span><br><span class="line">├───.gradle</span><br><span class="line">├───.idea</span><br><span class="line">├───.kotlin</span><br><span class="line">├───build</span><br><span class="line">├───compiler-plugin</span><br><span class="line">│   ├───src</span><br><span class="line">│   │   └───org/jetbrains/kotlin/compiler/plugin/template</span><br><span class="line">│   │       ├───fir</span><br><span class="line">│   │       └───ir</span><br><span class="line">│   ├───test-fixtures</span><br><span class="line">│   │   └───org/jetbrains/kotlin/compiler/plugin/template</span><br><span class="line">│   │       ├───runners</span><br><span class="line">│   │       └───services</span><br><span class="line">│   ├───test-gen</span><br><span class="line">│   │   └───org/jetbrains/kotlin/compiler/plugin/template</span><br><span class="line">│   │       └───runners</span><br><span class="line">│   └───testData</span><br><span class="line">│       ├───box</span><br><span class="line">│       └───diagnostics</span><br><span class="line">├───gradle</span><br><span class="line">├───gradle-plugin</span><br><span class="line">├───kotlin-js-store</span><br><span class="line">└───plugin-annotations</span><br><span class="line">    └───src</span><br></pre></td></tr></table></figure><p>其中与测试直接相关的关键目录如下：</p><ul><li><code>compiler-plugin/testData</code>: 存放测试用例源文件（<code>.kt</code>），按测试类型分为 <code>box</code> 和 <code>diagnostics</code>。</li><li><code>compiler-plugin/test-fixtures</code>: 包含测试辅助工具类，例如自定义的测试运行器基类和配置器。</li><li><code>compiler-plugin/test-gen</code>: 存放由测试框架根据 <code>testData</code> 自动生成的测试类代码。</li></ul><h2 id="黑盒代码生成测试-Box-Test-实现"><a href="#黑盒代码生成测试-Box-Test-实现" class="headerlink" title="黑盒代码生成测试 (Box Test) 实现"></a>黑盒代码生成测试 (Box Test) 实现</h2><p>黑盒测试验证从 FIR 到 IR 再到最终代码生成的完整流程。</p><h3 id="测试基类-AbstractJvmBoxTest"><a href="#测试基类-AbstractJvmBoxTest" class="headerlink" title="测试基类 AbstractJvmBoxTest"></a>测试基类 <code>AbstractJvmBoxTest</code></h3><p>所有 JVM 平台的黑盒测试都继承自 <code>AbstractJvmBoxTest</code>。此类负责配置测试环境、编译器指令和插件。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetbrains.kotlin.compiler.plugin.template.runners</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.compiler.plugin.template.services.ExtensionRegistrarConfigurator</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.compiler.plugin.template.services.PluginAnnotationsProvider</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.FirParser</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.builders.TestConfigurationBuilder</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.directives.CodegenTestDirectives</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.directives.FirDiagnosticsDirectives</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.directives.JvmEnvironmentConfigurationDirectives</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.runners.codegen.AbstractFirBlackBoxCodegenTestBase</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.services.EnvironmentBasedStandardLibrariesPathProvider</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.services.KotlinStandardLibrariesPathProvider</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">AbstractJvmBoxTest</span> : <span class="type">AbstractFirBlackBoxCodegenTestBase</span>(FirParser.LightTree) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createKotlinStandardLibrariesPathProvider</span><span class="params">()</span></span>: KotlinStandardLibrariesPathProvider &#123;</span><br><span class="line">        <span class="keyword">return</span> EnvironmentBasedStandardLibrariesPathProvider</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">configure</span><span class="params">(builder: <span class="type">TestConfigurationBuilder</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.configure(builder)</span><br><span class="line"></span><br><span class="line">        with(builder) &#123;</span><br><span class="line">            <span class="comment">// 设置所有测试默认开启的编译器指令</span></span><br><span class="line">            defaultDirectives &#123;</span><br><span class="line">                +CodegenTestDirectives.DUMP_IR       <span class="comment">// 输出生成的 IR</span></span><br><span class="line">                +FirDiagnosticsDirectives.FIR_DUMP   <span class="comment">// 输出 FIR 树</span></span><br><span class="line">                +JvmEnvironmentConfigurationDirectives.FULL_JDK</span><br><span class="line">                +CodegenTestDirectives.IGNORE_DEXING</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册插件服务</span></span><br><span class="line">            useConfigurators(</span><br><span class="line">                ::PluginAnnotationsProvider,</span><br><span class="line">                ::ExtensionRegistrarConfigurator</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动生成的测试类"><a href="#自动生成的测试类" class="headerlink" title="自动生成的测试类"></a>自动生成的测试类</h3><p><code>JvmBoxTestGenerated</code> 是一个由测试框架自动生成的类，它会扫描 <code>compiler-plugin/testData/box</code> 目录下的所有 <code>.kt</code> 文件，并为每个文件生成一个对应的 <code>@Test</code> 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetbrains.kotlin.compiler.plugin.template.runners;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intellij.testFramework.TestDataPath;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.util.KtTestUtil;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.TargetBackend;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.TestMetadata;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** This class is generated by &#123;<span class="doctag">@link</span> org.jetbrains.kotlin.compiler.plugin.template.GenerateTestsKt&#125;. DO NOT MODIFY MANUALLY */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(<span class="string">&quot;all&quot;</span>)</span></span><br><span class="line"><span class="meta">@TestMetadata(<span class="string">&quot;compiler-plugin/testData/box&quot;</span>)</span></span><br><span class="line"><span class="meta">@TestDataPath(<span class="string">&quot;<span class="variable">$PROJECT_ROOT</span>&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JvmBoxTestGenerated</span> <span class="title">extends</span> <span class="title">AbstractJvmBoxTest</span> &#123;</span><br><span class="line">  <span class="comment">// ... (方法为每个 testData/box 下的 .kt 文件自动生成)</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@TestMetadata(<span class="string">&quot;simple.kt&quot;</span>)</span></span><br><span class="line">  <span class="keyword">public</span> void testSimple() &#123;</span><br><span class="line">    runTest(<span class="string">&quot;compiler-plugin/testData/box/simple.kt&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="诊断测试-Diagnostic-Test-实现"><a href="#诊断测试-Diagnostic-Test-实现" class="headerlink" title="诊断测试 (Diagnostic Test) 实现"></a>诊断测试 (Diagnostic Test) 实现</h2><p>诊断测试仅关心编译器的某个特定阶段是否按预期工作，通过 <code>RUN_PIPELINE_TILL</code> 指令来控制编译流程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RUN_PIPELINE_TILL: FRONTEND</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该指令告诉测试框架，编译流程在 FRONTEND 阶段结束后就应停止并进行验证。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果测试用例中的代码在 FRONTEND 阶段之后才能发现问题（或没有问题），</span></span><br><span class="line"><span class="comment"> * 例如，移除下面的错误行 s.&lt;!UNRESOLVED_REFERENCE!&gt;inc&lt;!&gt;()，代码本身是合法的。</span></span><br><span class="line"><span class="comment"> * 此时测试框架会因编译成功通过了 FRONTEND 阶段而抛出异常：</span></span><br><span class="line"><span class="comment"> * &quot;Phase FRONTEND could be promoted to BACKEND&quot;，</span></span><br><span class="line"><span class="comment"> * 建议将指令调整到更靠后的阶段，如 FIR2IR 或 BACKEND。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> foo.bar</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.compiler.plugin.template.SomeAnnotation</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> s = MyClass().foo()</span><br><span class="line">    s.&lt;!UNRESOLVED_REFERENCE!&gt;inc&lt;!&gt;() <span class="comment">// 预期此处产生一个 &quot;UNRESOLVED_REFERENCE&quot; 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器各阶段的顺序定义在 <code>org.jetbrains.kotlin.test.services.TestPhase</code> 中：</p><ol><li><code>FRONTEND</code></li><li><code>FIR2IR</code></li><li><code>KLIB</code></li><li><code>BACKEND</code></li></ol><h2 id="FIR-与-IR-在插件开发中的应用"><a href="#FIR-与-IR-在插件开发中的应用" class="headerlink" title="FIR 与 IR 在插件开发中的应用"></a>FIR 与 IR 在插件开发中的应用</h2><p>对编译器插件开发者而言，理解 FIR 和 IR 的角色至关重要。</p><ul><li><strong>FIR (Frontend Intermediate Representation)</strong>: 是一个更接近 Kotlin 源码的中间表示。主要用于语法分析、语义分析和诊断。详细信息请参考 <a href="https://github.com/JetBrains/kotlin/blob/master/docs/fir/fir-basics.md">FIR 官方文档</a>。</li><li><strong>IR (Intermediate Representation)</strong>: 是一个更底层的、与具体平台无关的中间表示。它是连接前端和后端的桥梁，大多数代码生成和转换插件（如添加&#x2F;修改函数、类）都在 IR 阶段进行。详细信息请参考 <a href="https://github.com/JetBrains/kotlin/blob/master/docs/compiler-plugins/basics.md">Compiler Plugins 官方文档</a>。</li></ul><h3 id="实际案例：Zipline-IR-插件"><a href="#实际案例：Zipline-IR-插件" class="headerlink" title="实际案例：Zipline IR 插件"></a>实际案例：Zipline IR 插件</h3><p><a href="https://github.com/cashapp/zipline">Zipline</a> 项目通过 IR 插件实现了跨平台（Kotlin&#x2F;JS, Kotlin&#x2F;JVM）的 RPC 调用。其核心原理是在编译期动态修改实现了 <code>ZiplineService</code> 接口的代码。</p><p><strong>第一步：开发者编写的代码</strong><br>开发者仅需定义一个简单的服务接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EchoService.kt</span></span><br><span class="line"><span class="keyword">package</span> com.example</span><br><span class="line"><span class="keyword">import</span> app.cash.zipline.ZiplineService</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">EchoService</span> : <span class="type">ZiplineService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">echo</span><span class="params">(request: <span class="type">String</span>)</span></span>: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步：Zipline IR 插件在编译时的工作</strong><br>在编译器的 IR 阶段，<code>ZiplineIrGenerationExtension</code> 插件被激活。它扫描所有实现了 <code>ZiplineService</code> 的接口，并执行以下内存中的 IR 变换：</p><ol><li><strong>创建伴生对象</strong>：如果接口没有 <code>companion object</code>，则为其创建一个。</li><li><strong>生成 Adapter 类</strong>：在伴生对象内部，生成一个名为 <code>Adapter</code> 的嵌套类，该类实现了 <code>ZiplineServiceAdapter</code>，用于桥接 Zipline 的底层通信。</li><li><strong>生成代理类</strong>：在 <code>Adapter</code> 内部，再生成一个私有的代理类（如 <code>GeneratedOutboundService</code>），该类实现了原始的 <code>EchoService</code> 接口，并将所有方法调用转发给 Zipline 的 RPC <code>callHandler</code>。</li></ol><p><strong>第三步：编译器后端看到的最终 IR 结构</strong><br>插件处理完成后，编译器后端看到的 <code>EchoService</code> 的 IR 结构在逻辑上等同于以下代码。这份代码并未出现在源文件中，而是由插件在内存中动态构建，并直接用于生成最终的目标平台代码（如 JVM 字节码）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> app.cash.zipline.ZiplineService</span><br><span class="line"><span class="keyword">import</span> app.cash.zipline.<span class="keyword">internal</span>.bridge.ZiplineServiceAdapter</span><br><span class="line"><span class="keyword">import</span> kotlinx.serialization.KSerializer</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">EchoService</span> : <span class="type">ZiplineService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">echo</span><span class="params">(request: <span class="type">String</span>)</span></span>: String</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- START: CODE GENERATED BY ZIPLINE IR PLUGIN ---</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">Adapter</span>(...) : ZiplineServiceAdapter&lt;EchoService&gt;, KSerializer&lt;EchoService&gt; &#123;</span><br><span class="line">            <span class="comment">// ... 自动实现 ziplineFunctions()</span></span><br><span class="line">            <span class="comment">// ... 自动实现 outboundService()</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">GeneratedOutboundService</span>(</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">val</span> callHandler: OutboundCall.Handler</span><br><span class="line">            ) : EchoService &#123; <span class="comment">// 代理类实现了原始接口</span></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">echo</span><span class="params">(request: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">                    <span class="comment">// 将调用转发给 Zipline 底层通信机制</span></span><br><span class="line">                    <span class="keyword">return</span> callHandler.call(<span class="keyword">this</span>, <span class="number">0</span>, request) <span class="keyword">as</span> String</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ---  END: CODE GENERATED BY ZIPLINE IR PLUGIN  ---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过分析 Kotlin 编译器插件的测试框架，我们可以看到：</p><ul><li><strong>诊断测试</strong> 和 <strong>黑盒测试</strong> 是保障插件质量的两种核心手段，分别关注编译过程的正确性和最终代码的运行时行为。</li><li><strong>测试指令</strong>（如 <code>RUN_PIPELINE_TILL</code>）提供了精细控制编译流程的能力。</li><li><strong>IR 变换</strong> 是编译器插件实现功能强大的代码织入与修改的关键，Zipline 等项目充分展示了其在实际应用中的巨大潜力。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/Kotlin/compiler-plugin-template">Kotlin&#x2F;compiler-plugin-template on GitHub</a></li><li><a href="https://github.com/JetBrains/kotlin/blob/master/docs/fir/fir-basics.md">Kotlin FIR (Frontend IR) Documentation</a></li><li><a href="https://github.com/JetBrains/kotlin/blob/master/docs/compiler-plugins/basics.md">Kotlin Compiler Plugins Basics</a></li><li><a href="https://github.com/cashapp/zipline">Cash App&#x2F;zipline on GitHub</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Kotlin Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Emoji</title>
      <link href="/2025/10/17/Git/Git%20Emoji/"/>
      <url>/2025/10/17/Git/Git%20Emoji/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">标签</th><th align="center">代码</th><th align="left">含义 (中文)</th><th align="left">含义 (英文)</th></tr></thead><tbody><tr><td align="center">📦</td><td align="center"><code>:package:</code></td><td align="left">添加或更新编译后的文件或包。</td><td align="left">Add or update compiled files or packages.</td></tr><tr><td align="center">✨</td><td align="center"><code>:sparkles:</code></td><td align="left">引入新功能。</td><td align="left">Introduce new features.</td></tr><tr><td align="center">🐛</td><td align="center"><code>:bug:</code></td><td align="left">修复 Bug。</td><td align="left">Fix a bug.</td></tr><tr><td align="center">⚡️</td><td align="center"><code>:zap:</code></td><td align="left">提高性能。</td><td align="left">Improve performance.</td></tr><tr><td align="center">📝</td><td align="center"><code>:memo:</code></td><td align="left">添加或更新文档。</td><td align="left">Add or update documentation.</td></tr><tr><td align="center">🚀</td><td align="center"><code>:rocket:</code></td><td align="left">部署相关。</td><td align="left">Deploy stuff.</td></tr><tr><td align="center">💄</td><td align="center"><code>:lipstick:</code></td><td align="left">更新 UI 和样式文件。</td><td align="left">Add or update the UI and style files.</td></tr><tr><td align="center">🎉</td><td align="center"><code>:tada:</code></td><td align="left">开始项目 &#x2F; 初始提交。</td><td align="left">Initial commit.</td></tr><tr><td align="center">✅</td><td align="center"><code>:white_check_mark:</code></td><td align="left">添加、更新或通过测试。</td><td align="left">Add, update, or pass tests.</td></tr><tr><td align="center">🔒️</td><td align="center"><code>:lock:</code></td><td align="left">修复安全或隐私问题。</td><td align="left">Fix security or privacy issues.</td></tr><tr><td align="center">🍎</td><td align="center"><code>:apple:</code></td><td align="left">修复 macOS 相关的 Bug。</td><td align="left">Fix stuff on macOS.</td></tr><tr><td align="center">🐧</td><td align="center"><code>:penguin:</code></td><td align="left">修复 Linux 相关的 Bug。</td><td align="left">Fix stuff on Linux.</td></tr><tr><td align="center">🏁</td><td align="center"><code>:checkered_flag:</code></td><td align="left">修复 Windows 相关的 Bug。</td><td align="left">Fix stuff on Windows.</td></tr><tr><td align="center">🚑️</td><td align="center"><code>:ambulance:</code></td><td align="left">紧急热修复。</td><td align="left">Critical hotfix.</td></tr><tr><td align="center">🚧</td><td align="center"><code>:construction:</code></td><td align="left">进行中的工作。</td><td align="left">Work in progress.</td></tr><tr><td align="center">💚</td><td align="center"><code>:green_heart:</code></td><td align="left">修复 CI (持续集成) 构建。</td><td align="left">Fix CI build.</td></tr><tr><td align="center">⬇️</td><td align="center"><code>:arrow_down:</code></td><td align="left">降级依赖。</td><td align="left">Downgrade dependencies.</td></tr><tr><td align="center">⬆️</td><td align="center"><code>:arrow_up:</code></td><td align="left">升级依赖。</td><td align="left">Upgrade dependencies.</td></tr><tr><td align="center">📌</td><td align="center"><code>:pushpin:</code></td><td align="left">锁定依赖的版本。</td><td align="left">Pin dependencies to specific versions.</td></tr><tr><td align="center">👷</td><td align="center"><code>:construction_worker:</code></td><td align="left">添加或更新 CI 构建系统。</td><td align="left">Add or update CI build system.</td></tr><tr><td align="center">📈</td><td align="center"><code>:chart_with_upwards_trend:</code></td><td align="left">添加分析或跟踪代码。</td><td align="left">Add analytics or tracking code.</td></tr><tr><td align="center">♻️</td><td align="center"><code>:recycle:</code></td><td align="left">重构特定的代码逻辑。</td><td align="left">Refactor specific code logic.</td></tr><tr><td align="center">🎨</td><td align="center"><code>:art:</code></td><td align="left">改进代码结构或格式。</td><td align="left">Improve structure &#x2F; format of the code.</td></tr><tr><td align="center">🔨</td><td align="center"><code>:hammer:</code></td><td align="left">进行重构 &#x2F; 通用代码改进。</td><td align="left">Refactor code &#x2F; General update.</td></tr><tr><td align="center">🔥</td><td align="center"><code>:fire:</code></td><td align="left">移除代码或文件。</td><td align="left">Remove code or files.</td></tr><tr><td align="center">🗑️</td><td align="center"><code>:wastebasket:</code></td><td align="left">废弃代码或文件。</td><td align="left">Deprecate code or files.</td></tr><tr><td align="center">🌐</td><td align="center"><code>:globe_with_meridians:</code></td><td align="left">国际化和本地化。</td><td align="left">Internationalization and localization.</td></tr><tr><td align="center">🔧</td><td align="center"><code>:wrench:</code></td><td align="left">添加或更新配置文件。</td><td align="left">Add or update configuration files.</td></tr><tr><td align="center">🚨</td><td align="center"><code>:rotating_light:</code></td><td align="left">修复编译器&#x2F;Linter 警告。</td><td align="left">Fix compiler &#x2F; linter warnings.</td></tr><tr><td align="center">💡</td><td align="center"><code>:bulb:</code></td><td align="left">添加注释或文档字符串。</td><td align="left">Add or update comments in source code.</td></tr><tr><td align="center">👥</td><td align="center"><code>:busts_in_silhouette:</code></td><td align="left">添加贡献者或团队信息。</td><td align="left">Add contributor(s) or community.</td></tr><tr><td align="center">⏪</td><td align="center"><code>:rewind:</code></td><td align="left">撤销更改。</td><td align="left">Revert changes.</td></tr><tr><td align="center">🚚</td><td align="center"><code>:truck:</code></td><td align="left">移动或重命名文件、路径。</td><td align="left">Move or rename resources.</td></tr><tr><td align="center">💥</td><td align="center"><code>:boom:</code></td><td align="left">引入破坏性变更。</td><td align="left">Introduce breaking changes.</td></tr><tr><td align="center">🍻</td><td align="center"><code>:beers:</code></td><td align="left">醉酒写的代码 &#x2F; 测试性提交。</td><td align="left">Write bad code that needs to be improved. (Often humorous or test-related)</td></tr><tr><td align="center">💩</td><td align="center"><code>:poop:</code></td><td align="left">糟糕的代码，需要改进。</td><td align="left">Write bad code that needs to be improved.</td></tr><tr><td align="center">♿️</td><td align="center"><code>:wheelchair:</code></td><td align="left">改善可访问性。</td><td align="left">Improve accessibility.</td></tr><tr><td align="center">🐳</td><td align="center"><code>:whale:</code></td><td align="left">Docker 相关更改。</td><td align="left">Docker related changes.</td></tr><tr><td align="center">➕</td><td align="center"><code>:heavy_plus_sign:</code></td><td align="left">添加依赖项。</td><td align="left">Add a dependency.</td></tr><tr><td align="center">➖</td><td align="center"><code>:heavy_minus_sign:</code></td><td align="left">移除依赖项。</td><td align="left">Remove a dependency.</td></tr><tr><td align="center">🧪</td><td align="center"><code>:test_tube:</code></td><td align="left">添加一个失败的测试。</td><td align="left">Add a failing test.</td></tr><tr><td align="center">👔</td><td align="center"><code>:necktie:</code></td><td align="left">添加或更新业务逻辑。</td><td align="left">Add or update business logic.</td></tr><tr><td align="center">📱</td><td align="center"><code>:iphone:</code></td><td align="left">修复响应式设计或移动端问题。</td><td align="left">Work on responsive design or mobile views.</td></tr><tr><td align="center">💻</td><td align="center"><code>:computer:</code></td><td align="left">修复桌面端（非 Web）相关问题。</td><td align="left">Work on desktop application.</td></tr><tr><td align="center">⚙️</td><td align="center"><code>:gear:</code></td><td align="left">更新设置或配置。</td><td align="left">Update settings or configuration.</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neovim快速搭建 以及对于Kotlin LSP的总结</title>
      <link href="/2025/10/13/Vim/nvim%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/"/>
      <url>/2025/10/13/Vim/nvim%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<div class="note info simple"><p>本文介绍如何在不同平台快速搭建 Neovim，以及 Kotlin LSP 的使用体验和踩坑总结。</p></div><h2 id="🖥️-各平台安装"><a href="#🖥️-各平台安装" class="headerlink" title="🖥️ 各平台安装"></a>🖥️ 各平台安装</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">Windows</button><button type="button" class="tab">Linux</button><button type="button" class="tab">MacOS</button></div><div class="tab-contents"><div class="tab-item-content active"><p>Windows 环境需要先安装 Chocolatey 包管理器。</p><p><strong>安装 Chocolatey：</strong></p><p>PowerShell 方式：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Bypass <span class="literal">-Scope</span> <span class="keyword">Process</span> <span class="literal">-Force</span>; [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol <span class="operator">-bor</span> <span class="number">3072</span>; <span class="built_in">iex</span> ((<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">&#x27;https://community.chocolatey.org/install.ps1&#x27;</span>))</span><br></pre></td></tr></table></figure><p>CMD 方式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&quot;<span class="variable">%SystemRoot%</span>\System32\WindowsPowerShell\v1.<span class="number">0</span>\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;[System.<span class="built_in">Net</span>.ServicePointManager]::SecurityProtocol = <span class="number">3072</span>; iex ((New-Object System.<span class="built_in">Net</span>.WebClient).DownloadString(&#x27;https://community.chocolatey.org/install.ps1&#x27;))&quot; &amp;&amp; <span class="built_in">SET</span> &quot;<span class="built_in">PATH</span>=<span class="variable">%PATH%</span>;<span class="variable">%ALLUSERSPROFILE%</span>\chocolatey\bin&quot;</span><br></pre></td></tr></table></figure><p><strong>安装 Neovim：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install nvim</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p>Linux 系统（包括 WSL）可直接使用 apt 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install neovim</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p>macOS 使用 Homebrew 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install neovim</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="⚙️-配置文件"><a href="#⚙️-配置文件" class="headerlink" title="⚙️ 配置文件"></a>⚙️ 配置文件</h2><p>安装完成后输入 <code>nvim</code> 即可启动。配置文件需手动创建：</p><div class="note warning simple"><p><strong>配置文件路径：</strong></p><ul><li>Windows: <code>C:\Users\${你的用户名}\AppData\Local\nvim</code></li><li>Mac&#x2F;Linux: <code>~/.config/nvim/</code></li></ul></div><h3 id="全选复制操作"><a href="#全选复制操作" class="headerlink" title="全选复制操作"></a>全选复制操作</h3><p>在普通模式下（可用 <code>hjkl</code> 移动光标）：</p><ol><li>输入 <code>ggvG</code> 全选</li><li>输入 <code>:&quot;+y</code> 复制到系统剪贴板</li></ol><h3 id="推荐配置方案"><a href="#推荐配置方案" class="headerlink" title="推荐配置方案"></a>推荐配置方案</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">LazyVim 框架</button><button type="button" class="tab">Neovimdots 框架</button></div><div class="tab-contents"><div class="tab-item-content active"><p>LazyVim 简化了 Neovim 配置流程，推荐新手使用。</p><p><a href="https://github.com/crowforkotlin/nvim-config," title="https:&#x2F;&#x2F;github.githubassets.com&#x2F;favicons&#x2F;favicon.svg" target="">Neovim Config,</a></p></div><div class="tab-item-content"><p>功能更全面的配置框架，集成了大量插件。</p><p><a href="https://github.com/ayamir/nvimdots," title="https:&#x2F;&#x2F;github.githubassets.com&#x2F;favicons&#x2F;favicon.svg" target="">Neovimdots,</a></p><div class="note danger simple"><p><strong>Windows 安装要求：</strong></p><ul><li>PowerShell 7+</li><li>Chocolatey</li></ul></div><p><strong>常见问题：</strong></p><ul><li>安装过程一路回车即可</li><li>若报错，需提前手动安装 nvim 或删除旧配置</li><li>LSP 初始化失败时，需通过 npm 手动安装依赖</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🚀-快速开始"><a href="#🚀-快速开始" class="headerlink" title="🚀 快速开始"></a>🚀 快速开始</h2><p>配置部署后，Neovim 会自动通过 LSP 下载插件到：</p><ul><li>Windows: <code>~\AppData\Local\nvim-data\lazy</code></li><li>Mac&#x2F;Linux: <code>~\.config\nvim-data</code></li></ul><div class="note warning simple"><p><strong>插件下载失败？</strong><br>即使配置了代理，git clone 也可能失败。解决方法：退出 nvim 后重新打开，重复操作直到插件完全下载。</p></div><h3 id="LSP-与-Mason"><a href="#LSP-与-Mason" class="headerlink" title="LSP 与 Mason"></a>LSP 与 Mason</h3><p>查看我的 LSP 配置：</p><a href="https://github.com/crowforkotlin/nvim-config/blob/main/lua/plugins/lsp.lua" title="https:&#x2F;&#x2F;github.githubassets.com&#x2F;favicons&#x2F;favicon.svg" target="">LSP 配置文件,</a><div class="note info simple"><p><strong>核心组件：</strong></p><ul><li><strong>LSP</strong>: 提供代码解析、类型检查、格式化等 IDE 功能</li><li><strong>Mason</strong>: 自动管理语言服务器和工具的安装</li></ul></div><h2 id="💡-Kotlin-LSP-使用总结"><a href="#💡-Kotlin-LSP-使用总结" class="headerlink" title="💡 Kotlin LSP 使用总结"></a>💡 Kotlin LSP 使用总结</h2><div class="note danger simple"><p>Kotlin LSP 目前存在较多问题，不推荐在 Neovim&#x2F;VSCode 中使用，建议使用 IntelliJ IDEA 或 Android Studio。</p></div><p><strong>主要问题：</strong></p><ul><li>响应速度慢，大型项目频繁报错</li><li>泛型、内联等复杂语法支持不佳</li><li>Android 项目支持极差，补全提示缺失</li></ul><h3 id="第三方解决方案"><a href="#第三方解决方案" class="headerlink" title="第三方解决方案"></a>第三方解决方案</h3><p>尝试过以下工具，但体验仍不理想：</p><ul><li><a href="https://github.com/desugar-64/kotlin-lsp-workspace-generator," title="https:&#x2F;&#x2F;github.githubassets.com&#x2F;favicons&#x2F;favicon.svg" target="">kotlin-lsp-workspace-generator,</a></li><li><a href="https://github.com/yamsergey/yamsergey.adt," title="https:&#x2F;&#x2F;github.githubassets.com&#x2F;favicons&#x2F;favicon.svg" target="">yamsergey.adt,</a></li></ul><div class="note warning simple"><p>虽然解决了 Android 支持问题，但引入了新问题：大量爆红、编译缓慢。结论：Kotlin 开发还是用 IDEA&#x2F;AS 更高效。</p></div><h2 id="🔗-相关链接"><a href="#🔗-相关链接" class="headerlink" title="🔗 相关链接"></a>🔗 相关链接</h2><ul><li><a href="https://learn.microsoft.com/zh-tw/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.5">PowerShell 安装指南</a></li><li><a href="https://docs.chocolatey.org/en-us/choco/setup/">Chocolatey 文档</a></li><li><a href="https://github.com/ayamir/nvimdots">Neovimdots</a></li><li><a href="https://github.com/crowforkotlin/nvim-config">我的 Neovim 配置</a></li><li><a href="https://github.com/crowforkotlin/nvim-config/blob/main/lua/plugins/lsp.lua">LSP 配置详情</a></li><li><a href="https://github.com/desugar-64/kotlin-lsp-workspace-generator">Kotlin LSP Workspace Generator</a></li><li><a href="https://github.com/yamsergey/yamsergey.adt">Yamsergey ADT</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>adb shell &amp; wsl root 实现彩色命令提示符</title>
      <link href="/2025/08/08/Android/adb%20shell%20&amp;%20wsl%20root%E5%AE%9E%E7%8E%B0%E5%BD%A9%E8%89%B2%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6/"/>
      <url>/2025/08/08/Android/adb%20shell%20&amp;%20wsl%20root%E5%AE%9E%E7%8E%B0%E5%BD%A9%E8%89%B2%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="WSL-终端彩色提示符"><a href="#WSL-终端彩色提示符" class="headerlink" title="WSL 终端彩色提示符"></a>WSL 终端彩色提示符</h2><p><img src="https://gitlab.com/crowforkotlin/page-storage/-/raw/main/image/post/image03.png" alt="wsl-ubuntu-prompt"></p><div class="note info modern"><p>编辑 <code>./root/.bashrc</code>，取消以下注释并使其生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">force_color_prompt=<span class="built_in">yes</span></span><br><span class="line"><span class="built_in">source</span> ./root/.bashrc</span><br></pre></td></tr></table></figure></div><h2 id="Android-Shell-彩色提示符（需-Root）"><a href="#Android-Shell-彩色提示符（需-Root）" class="headerlink" title="Android Shell 彩色提示符（需 Root）"></a>Android Shell 彩色提示符（需 Root）</h2><p><img src="https://gitlab.com/crowforkotlin/page-storage/-/raw/main/image/post/image04.png" alt="android-shell-prompt"></p><blockquote><p>使用 termux 的 vim 编辑：<code>vim /system/etc/mkshrc</code>，追加以下内容：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PS4=<span class="string">&#x27;[$EPOCHREALTIME] &#x27;</span></span><br><span class="line">HISTSIZE=1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Colored Aliases ---</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">&#x27;grep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> fgrep=<span class="string">&#x27;fgrep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> egrep=<span class="string">&#x27;egrep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls -CF&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Colors ---</span></span><br><span class="line">C_GREEN=$<span class="string">&#x27;\033[0;32m&#x27;</span></span><br><span class="line">C_BLUE=$<span class="string">&#x27;\033[0;34m&#x27;</span></span><br><span class="line">C_RED=$<span class="string">&#x27;\033[0;31m&#x27;</span></span><br><span class="line">C_RESET=$<span class="string">&#x27;\033[0m&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Prompt ---</span></span><br><span class="line"><span class="keyword">if</span> (( USER_ID )); <span class="keyword">then</span></span><br><span class="line">  PROMPT_CHAR=<span class="string">&#x27;$&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  PROMPT_CHAR=<span class="string">&#x27;#&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">EXIT_CODE_PROMPT=<span class="string">&#x27;$&#123;|</span></span><br><span class="line"><span class="string">  local e=$?</span></span><br><span class="line"><span class="string">  (( e )) &amp;&amp; REPLY+=&quot;$&#123;C_RED&#125;$e$&#123;C_RESET&#125;|&quot;</span></span><br><span class="line"><span class="string">  return $e</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">PS1=<span class="string">&quot;$EXIT_CODE_PROMPT<span class="variable">$&#123;C_GREEN&#125;</span>\$HOSTNAME<span class="variable">$&#123;C_RESET&#125;</span>:<span class="variable">$&#123;C_BLUE&#125;</span>\$&#123;PWD:-?&#125;<span class="variable">$&#123;C_RESET&#125;</span> <span class="variable">$&#123;PROMPT_CHAR&#125;</span> &quot;</span></span><br></pre></td></tr></table></figure><div class="note info modern"><p>使配置生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /system/etc/mkshrc</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Adb </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Adb </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux/Ubuntu su后前缀用户丢失颜色</title>
      <link href="/2025/08/08/Unix/Linux%20su%E5%90%8E%E5%89%8D%E7%BC%80%E4%B8%A2%E5%A4%B1%E9%A2%9C%E8%89%B2/"/>
      <url>/2025/08/08/Unix/Linux%20su%E5%90%8E%E5%89%8D%E7%BC%80%E4%B8%A2%E5%A4%B1%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>sudo nvim &#x2F;root&#x2F;.bashrc -&gt; <code>force_color_prompt=yes</code> 取消注释这一行</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Unix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim全选复制</title>
      <link href="/2025/08/08/Vim/Vim%E5%85%A8%E9%80%89%E5%A4%8D%E5%88%B6/"/>
      <url>/2025/08/08/Vim/Vim%E5%85%A8%E9%80%89%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在普通模式下输入 :echo has(‘clipboard’)，然后按 Enter。 如果返回 1，说明你的 Vim 支持系统剪贴板。 如果返回 0，说明你的 Vim 不支持。</p></blockquote><blockquote><p>安装neovim，默认支持，输入ggvG”+y</p></blockquote><ul><li><p>“：告诉 Neovim 你要使用一个寄存器来操作。</p></li><li><p>+：指定使用系统剪贴板寄存器。这是 Neovim 与系统剪贴板通信的关键。</p></li><li><p>y：执行复制（yank）操作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin/Native Windows 本机库开发指南</title>
      <link href="/2025/07/24/Kotlin/Kotlin%20Native%20Library/"/>
      <url>/2025/07/24/Kotlin/Kotlin%20Native%20Library/</url>
      
        <content type="html"><![CDATA[<h2 id="Ⅰ-Kotlin-x2F-Native-简介"><a href="#Ⅰ-Kotlin-x2F-Native-简介" class="headerlink" title="Ⅰ. Kotlin&#x2F;Native 简介"></a>Ⅰ. Kotlin&#x2F;Native 简介</h2><p>Kotlin&#x2F;Native 是一项将 Kotlin 代码直接编译为本机二进制文件（无需 JVM）的技术。其核心优势在于：</p><ul><li><strong>高效执行</strong>：基于 LLVM 后端，生成针对特定平台优化的机器码。</li><li><strong>无缝互操作</strong>：可以轻松调用 C&#x2F;C++ 等系统原生库。</li><li><strong>跨平台支持</strong>：最初为 iOS 设计，现已扩展至 Windows, Linux, macOS, Android 等多个平台。</li></ul><hr><h2 id="Ⅱ-Windows-平台本机库概览"><a href="#Ⅱ-Windows-平台本机库概览" class="headerlink" title="Ⅱ. Windows 平台本机库概览"></a>Ⅱ. Windows 平台本机库概览</h2><p>在 Windows 系统中，代码库主要有以下几种形式，了解它们的区别对于开发至关重要。</p><table><thead><tr><th align="center">文件类型</th><th align="center">扩展名</th><th align="left">功能</th><th align="left">类比</th></tr></thead><tbody><tr><td align="center"><strong>动态链接库</strong></td><td align="center"><code>.dll</code></td><td align="left">在程序运行时按需加载，可被多个程序共享。</td><td align="left">Linux <code>.so</code></td></tr><tr><td align="center"><strong>静态链接库</strong></td><td align="center"><code>.lib</code></td><td align="left">在编译链接阶段，其代码被完整复制到最终的可执行文件中。</td><td align="left">Linux <code>.a</code></td></tr><tr><td align="center"><strong>导入库</strong></td><td align="center"><code>.lib</code></td><td align="left">同样是 <code>.lib</code> 文件，但它仅包含符号引用，用于告诉链接器去哪里找对应的 <code>.dll</code>。</td><td align="left">-</td></tr></tbody></table><blockquote><p>💡 <strong><code>.lib</code> 文件的“双重身份”</strong></p><p>Windows 下的 <code>.lib</code> 文件存在歧义：</p><ol><li>**静态库 (Static Library)**：包含完整的二进制代码（<code>.obj</code> 文件的集合），由 <code>cl.exe</code> (MSVC) 或 <code>ar</code> (MinGW) 生成，文件体积较大。</li><li>**导入库 (Import Library)**：仅包含一个指向 <code>.dll</code> 的符号列表和元数据，本身不含任何可执行代码。它在链接时使用，文件体积非常小 (通常只有几 KB)。</li></ol></blockquote><hr><h2 id="Ⅲ-实战：创建并使用-Kotlin-x2F-Native-动态库"><a href="#Ⅲ-实战：创建并使用-Kotlin-x2F-Native-动态库" class="headerlink" title="Ⅲ. 实战：创建并使用 Kotlin&#x2F;Native 动态库"></a>Ⅲ. 实战：创建并使用 Kotlin&#x2F;Native 动态库</h2><p>本节将完整演示如何使用 Kotlin&#x2F;Native 创建一个 <code>.dll</code> 动态库，并再创建一个 Kotlin&#x2F;Native 程序来调用它。</p><blockquote><p>📦 <strong>环境准备</strong></p><ul><li><strong>Gradle 项目</strong>: 建议使用官方提供的 KMP 模板项目 <code>git clone https://github.com/Kotlin/kmp-native-wizard.git</code></li><li><strong>Visual Studio Build Tools</strong>: 用于生成导入库 <code>.lib</code> 文件。它比完整的 Visual Studio 更轻量。<ul><li><a href="https://visualstudio.microsoft.com/downloads/">下载地址</a> (选择 Tools for Visual Studio -&gt; Build Tools for Visual Studio)。</li></ul></li></ul></blockquote><h3 id="第-1-阶段：创建-Kotlin-x2F-Native-动态库-dll"><a href="#第-1-阶段：创建-Kotlin-x2F-Native-动态库-dll" class="headerlink" title="第 1 阶段：创建 Kotlin&#x2F;Native 动态库 (.dll)"></a>第 1 阶段：创建 Kotlin&#x2F;Native 动态库 (<code>.dll</code>)</h3><h4 id="步骤-1-配置-Gradle-构建脚本"><a href="#步骤-1-配置-Gradle-构建脚本" class="headerlink" title="步骤 1: 配置 Gradle 构建脚本"></a>步骤 1: 配置 Gradle 构建脚本</h4><p>在 <code>build.gradle.kts</code> 文件中，声明我们的目标平台为 <code>mingwX64</code>，并配置生成一个动态库。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build.gradle.kts</span></span><br><span class="line">kotlin &#123;</span><br><span class="line">    <span class="comment">// 仅针对 Windows MinGW 64位平台</span></span><br><span class="line">    mingwX64(<span class="string">&quot;native&quot;</span>) &#123; <span class="comment">// &quot;native&quot; 是一个自定义的目标名称</span></span><br><span class="line">        binaries &#123;</span><br><span class="line">            <span class="comment">// 配置生成一个名为 &quot;mordecai&quot; 的动态库 (mordecai.dll)</span></span><br><span class="line">            sharedLib &#123;</span><br><span class="line">                baseName = <span class="string">&quot;mordecai&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤-2-编写要导出的-Kotlin-代码"><a href="#步骤-2-编写要导出的-Kotlin-代码" class="headerlink" title="步骤 2: 编写要导出的 Kotlin 代码"></a>步骤 2: 编写要导出的 Kotlin 代码</h4><p>创建一个 Kotlin 文件，并使用 <code>@CName</code> 注解来导出一个函数，使其能被 C&#x2F;C++ 调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/nativeMain/kotlin/Mordecai.kt</span></span><br><span class="line"><span class="keyword">import</span> kotlin.experimental.ExperimentalNativeApi</span><br><span class="line"></span><br><span class="line"><span class="comment">// @CName 将此函数导出为 C 语言符号 &quot;sayHelloFromKotlinNative&quot;</span></span><br><span class="line"><span class="meta">@CName(<span class="string">&quot;sayHelloFromKotlinNative&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello, this message is from Kotlin/Native!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤-3-编译生成动态库"><a href="#步骤-3-编译生成动态库" class="headerlink" title="步骤 3: 编译生成动态库"></a>步骤 3: 编译生成动态库</h4><p>执行 Gradle 任务来编译项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行此命令</span></span><br><span class="line">./gradlew linkNativeDebugShared   <span class="comment"># 或 linkNativeReleaseShared</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译成功后，产物会出现在以下目录：</span></span><br><span class="line"><span class="comment"># build/bin/native/debugShared/mordecai.dll</span></span><br><span class="line"><span class="comment"># build/bin/native/debugShared/mordecai.def</span></span><br><span class="line"><span class="comment"># build/bin/native/debugShared/mordecai_api.h</span></span><br></pre></td></tr></table></figure><p>产物说明：</p><ul><li><code>mordecai.dll</code>: 核心的动态库文件。</li><li><code>mordecai.def</code>: 模块定义文件，描述了 DLL 导出的函数。</li><li><code>mordecai_api.h</code>: C&#x2F;C++ 头文件，包含了导出函数的声明。</li></ul><h3 id="第-2-阶段：在-Kotlin-x2F-Native-程序中调用动态库"><a href="#第-2-阶段：在-Kotlin-x2F-Native-程序中调用动态库" class="headerlink" title="第 2 阶段：在 Kotlin&#x2F;Native 程序中调用动态库"></a>第 2 阶段：在 Kotlin&#x2F;Native 程序中调用动态库</h3><p>现在，我们将创建一个可执行文件 (<code>.exe</code>) 来调用刚刚生成的 <code>.dll</code>。</p><h4 id="步骤-4-生成导入库-lib"><a href="#步骤-4-生成导入库-lib" class="headerlink" title="步骤 4: 生成导入库 (.lib)"></a>步骤 4: 生成导入库 (<code>.lib</code>)</h4><p>为了让链接器能够识别 <code>.dll</code> 中的函数，我们需要从 <code>.def</code> 文件生成一个导入库 <code>.lib</code>。</p><ol><li><p>打开 <code>x64 Native Tools Command Prompt for VS 2022</code> (通过开始菜单搜索)。</p></li><li><p>进入 DLL 所在的目录。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> path\to\your\project\build\bin\native\debugShared</span><br></pre></td></tr></table></figure></li><li><p>执行 <code>lib.exe</code> 命令生成导入库。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /def: 指定定义文件</span></span><br><span class="line"><span class="comment"># /out: 指定输出的导入库文件名</span></span><br><span class="line"><span class="comment"># /machine:x64 必须指定目标平台为 x64，否则可能因架构不匹配而链接失败</span></span><br><span class="line">lib /def:mordecai.def /out:mordecai.lib /machine:x64</span><br></pre></td></tr></table></figure></li></ol><p>   执行完毕后，当前目录下会生成 <code>mordecai.lib</code> 文件。</p><h4 id="步骤-5-组织-C-互操作文件"><a href="#步骤-5-组织-C-互操作文件" class="headerlink" title="步骤 5: 组织 C 互操作文件"></a>步骤 5: 组织 C 互操作文件</h4><p>为了让 Kotlin&#x2F;Native 的 C 互操作工具 (<code>cinterop</code>) 能够找到库文件和头文件，我们需要将它们组织到项目中。</p><ol><li><p>在 <code>src/</code> 目录下创建以下结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">└── nativeInterop/</span><br><span class="line">    └── cinterop/</span><br><span class="line">        ├── include/      # 存放头文件</span><br><span class="line">        │   └── mordecai_api.h</span><br><span class="line">        └── libs/         # 存放库文件</span><br><span class="line">            ├── mordecai.dll</span><br><span class="line">            └── mordecai.lib</span><br></pre></td></tr></table></figure></li><li><p><strong>拷贝文件</strong>：</p><ul><li>将步骤 3 生成的 <code>mordecai_api.h</code> 拷贝到 <code>include/</code> 目录。</li><li>将步骤 3 生成的 <code>mordecai.dll</code> 和步骤 4 生成的 <code>mordecai.lib</code> 拷贝到 <code>libs/</code> 目录。</li></ul></li></ol><h4 id="步骤-6-配置-C-互操作-cinterop"><a href="#步骤-6-配置-C-互操作-cinterop" class="headerlink" title="步骤 6: 配置 C 互操作 (cinterop)"></a>步骤 6: 配置 C 互操作 (<code>cinterop</code>)</h4><p>回到 <code>build.gradle.kts</code>，添加 <code>cinterop</code> 配置，告诉 Kotlin 如何与我们的 C 库进行交互。同时，添加一个 <code>executable</code> 配置来生成 <code>.exe</code> 文件。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build.gradle.kts</span></span><br><span class="line">kotlin &#123;</span><br><span class="line">    mingwX64(<span class="string">&quot;native&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// ... sharedLib 配置保留 ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增 executable 配置，用于生成 .exe 文件</span></span><br><span class="line">        binaries &#123;</span><br><span class="line">            sharedLib &#123; baseName = <span class="string">&quot;mordecai&quot;</span> &#125; <span class="comment">// 可以保留</span></span><br><span class="line">            executable &#123;</span><br><span class="line">                <span class="comment">// entryPoint 的默认值就是 &quot;main&quot;，可以省略</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        compilations.getByName(<span class="string">&quot;main&quot;</span>) &#123;</span><br><span class="line">            cinterops &#123;</span><br><span class="line">                <span class="comment">// 创建一个名为 &quot;mordecai&quot; 的 cinterop 配置</span></span><br><span class="line">                <span class="keyword">val</span> mordecai <span class="keyword">by</span> creating &#123;</span><br><span class="line">                    <span class="comment">// 指定 .def 文件，cinterop 会据此生成 Kotlin 绑定</span></span><br><span class="line">                    defFile(project.file(<span class="string">&quot;src/nativeInterop/cinterop/mordecai.def&quot;</span>))</span><br><span class="line">                    <span class="comment">// 添加头文件搜索路径</span></span><br><span class="line">                    includeDirs(<span class="string">&quot;src/nativeInterop/cinterop/include&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，创建 <code>src/nativeInterop/cinterop/mordecai.def</code> 文件，用于指导 <code>cinterop</code> 工具。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># src/nativeInterop/cinterop/mordecai.def</span><br><span class="line"></span><br><span class="line"># 生成的 Kotlin 代码将位于此包下</span><br><span class="line">package = com.mordecai.kn.tools</span><br><span class="line"></span><br><span class="line"># 需要解析的头文件</span><br><span class="line">headers = mordecai_api.h</span><br><span class="line"></span><br><span class="line"># 链接器选项</span><br><span class="line"># -L: 指定库文件的搜索路径</span><br><span class="line"># -l: 指定要链接的库名 (mordecai.lib -&gt; -lmordecai)</span><br><span class="line">linkerOpts.mingw_x64 = -Lsrc/nativeInterop/cinterop/libs -lmordecai</span><br></pre></td></tr></table></figure><p>配置完成后，<strong>同步 Gradle 项目</strong> (Sync Project with Gradle Files)，<code>cinterop</code> 会自动运行并生成 Kotlin 绑定代码。</p><h4 id="步骤-7-编写主程序并运行"><a href="#步骤-7-编写主程序并运行" class="headerlink" title="步骤 7: 编写主程序并运行"></a>步骤 7: 编写主程序并运行</h4><p>现在可以编写 <code>main</code> 函数来调用库中的 <code>sayHelloFromKotlinNative</code> 函数了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/nativeMain/kotlin/Main.kt</span></span><br><span class="line"><span class="keyword">import</span> com.mordecai.kn.tools.sayHelloFromKotlinNative</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Calling the function from our DLL...&quot;</span>)</span><br><span class="line">    sayHelloFromKotlinNative()</span><br><span class="line">    println(<span class="string">&quot;Call finished.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 Gradle 任务来运行程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew runDebugExecutableMingwX64</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ <strong>运行时错误？</strong></p><p>第一次运行时，你可能会遇到一个错误，提示找不到 <code>mordecai.dll</code>。这是因为 <code>.exe</code> 在运行时需要在其所在目录或系统路径中找到它依赖的 <code>.dll</code> 文件。</p><p><strong>解决方案</strong>：将 <code>src/nativeInterop/cinterop/libs/mordecai.dll</code> 文件手动复制到可执行文件的输出目录 <code>build/bin/native/debugExecutable/</code> 下，然后再次运行命令即可成功。</p></blockquote><hr><h2 id="Ⅳ-简化流程：使用静态库"><a href="#Ⅳ-简化流程：使用静态库" class="headerlink" title="Ⅳ. 简化流程：使用静态库"></a>Ⅳ. 简化流程：使用静态库</h2><p>如果不想处理 <code>.dll</code> 运行时依赖的问题，可以选择静态链接。这会将库代码直接编译进最终的 <code>.exe</code> 文件中，使其成为一个独立的单文件程序，但会增加可执行文件的体积。</p><ol><li><p><strong>配置 Gradle 生成静态库</strong>：<br>在 <code>build.gradle.kts</code> 的 <code>binaries</code> 块中，添加 <code>staticLib</code> 配置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kotlin &#123;</span><br><span class="line">    mingwX64(<span class="string">&quot;native&quot;</span>) &#123;</span><br><span class="line">        binaries &#123;</span><br><span class="line">            <span class="comment">// 生成静态库 mordecai.a (MinGW 默认) 或 mordecai.lib (MSVC)</span></span><br><span class="line">            staticLib &#123; baseName = <span class="string">&quot;mordecai&quot;</span> &#125;</span><br><span class="line">            executable() <span class="comment">// 保持可执行文件配置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... cinterop 配置保持不变 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编译生成静态库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew linkNativeDebugStatic <span class="comment"># 或 linkNativeReleaseStatic</span></span><br></pre></td></tr></table></figure><p>这会在 <code>build/bin/native/debugStatic/</code> 目录下生成 <code>libmordecai.a</code> 文件。</p></li><li><p><strong>组织并链接</strong>：</p><ul><li>将 <code>libmordecai.a</code> 和 <code>mordecai_api.h</code> 拷贝到 <code>src/nativeInterop/cinterop/</code> 下对应的 <code>libs</code> 和 <code>include</code> 目录。</li><li><code>mordecai.def</code> 文件中的 <code>linkerOpts</code> 配置保持不变，链接器会自动识别并使用 <code>.a</code> 文件。</li><li>同步 Gradle 项目。</li></ul></li><li><p><strong>直接运行</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew runDebugExecutableMingwX64</span><br></pre></td></tr></table></figure><p>由于所有代码都已链接进 <code>.exe</code>，这次无需再手动拷贝任何文件，程序可以直接运行。</p></li></ol><hr><h2 id="Ⅴ-总结"><a href="#Ⅴ-总结" class="headerlink" title="Ⅴ. 总结"></a>Ⅴ. 总结</h2><p>本文详细介绍了在 Windows 平台上使用 Kotlin&#x2F;Native 创建和消费原生库的两种主要方式：</p><ul><li><strong>动态链接</strong>：通过 <code>.dll</code> 和导入库 <code>.lib</code> 实现。优点是代码共享、模块化更新；缺点是需要处理运行时依赖。</li><li><strong>静态链接</strong>：通过静态库 <code>.a</code> 或 <code>.lib</code> 实现。优点是部署简单、单文件分发；缺点是可执行文件体积较大。</li></ul><p>掌握这两种技术，可以让你无缝地将 Kotlin&#x2F;Native 集成到现有的 C&#x2F;C++ 项目中，或者为其他语言提供高性能的 Kotlin 库。</p><blockquote><p>⭐ <strong>参考源码与自动化插件</strong></p><p>本文所有流程的实现代码，以及一个可以自动拷贝依赖文件的 Gradle 插件，都可以在以下仓库找到：<br><a href="https://github.com/crowforkotlin/mordecai-kn-mingw-example">https://github.com/crowforkotlin/mordecai-kn-mingw-example</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Kotlin Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用mklink节省磁盘空间</title>
      <link href="/2025/07/21/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/%E5%88%A9%E7%94%A8mklink%E8%8A%82%E7%9C%81%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4/"/>
      <url>/2025/07/21/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/%E5%88%A9%E7%94%A8mklink%E8%8A%82%E7%9C%81%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>he <code>mklink</code> command in Windows is used to create symbolic links (also known as symlinks), hard links, or directory junctions. These links act as pointers to other files or directories, allowing you to access them from a different location as if they were there.</p><p>Windows 中的 mklink 命令用于创建符号链接 (也称为 symlink)、硬链接或目录连接。这些链接充当指向其他文件或目录的指针，允许您从其他位置访问它们，就好像它们就在那里一样。</p></blockquote><blockquote><p>In your specific command, <code>mklink /D &quot;C:\Users\CrowF\.vscode&quot; &quot;D:\software\cache\&quot;</code>, you are using the <code>/D</code> switch. This switch indicates that you are creating a directory symbolic link.</p><p>在您的具体命令 mklink &#x2F;D “C:\Users\CrowF.vscode” “D:\software\cache&quot; 中 ，您使用了 &#x2F;D 开关。此开关表示您正在创建目录符号链接 。</p></blockquote><p>Here’s a breakdown of what your command does:</p><ul><li><p><strong><code>mklink</code></strong>: The command to create a link.<br>mklink ：创建链接的命令。</p></li><li><p><strong><code>/D</code></strong>: Specifies that the link being created is for a directory.<br>&#x2F;D ：指定正在创建的链接用于目录。</p></li><li><p><strong><code>&quot;C:\Users\CrowF\.vscode&quot;</code></strong>: This is the <em>link name</em> or the path where the symbolic link will be created. In this case, it’s creating a link in your <code>.vscode</code> folder.<br>“C:\Users\CrowF.vscode” ：这是链接名称或将创建符号链接的路径。在本例中，它将在 .vscode 文件夹中创建一个链接。</p></li><li><p><strong><code>&quot;D:\software\cache\&quot;</code></strong>: This is the <em>target</em> path. The symbolic link at <code>C:\Users\CrowF\.vscode</code> will point to this directory.<br>“D:\software\cache&quot; ：这是目标路径。C :\Users\CrowF.vscode 的符号链接将指向此目录。</p></li></ul><p><strong>Essentially, this command makes your <code>.vscode</code> folder on the C: drive act as a shortcut to the <code>D:\software\cache\</code> directory.</strong> This is often used to save space on the C: drive or to redirect application data to a larger storage location.<br>本质上，此命令使 C: 盘上的 .vscode 文件夹充当 D:\software\cache\ 目录的快捷方式。 这通常用于节省 C: 盘空间或将应用程序数据重定向到更大的存储位置。</p>]]></content>
      
      
      <categories>
          
          <category> Command </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adb Shell 分配伪终端解决方案</title>
      <link href="/2025/07/02/Android/Adb%20shell%20%E5%88%86%E9%85%8D%E4%BC%AA%E7%BB%88%E7%AB%AF/"/>
      <url>/2025/07/02/Android/Adb%20shell%20%E5%88%86%E9%85%8D%E4%BC%AA%E7%BB%88%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="🔧-问题描述"><a href="#🔧-问题描述" class="headerlink" title="🔧 问题描述"></a>🔧 问题描述</h2><div class="note warning modern"><p>在通过 <code>adb shell</code> 执行 shell 脚本时，遇到了权限拒绝的问题。即使分配了 root 权限，在 shell 外部执行脚本仍然会失败。</p></div><h2 id="💡-解决方案"><a href="#💡-解决方案" class="headerlink" title="💡 解决方案"></a>💡 解决方案</h2><h3 id="方法一：使用-t-参数"><a href="#方法一：使用-t-参数" class="headerlink" title="方法一：使用 -t 参数"></a>方法一：使用 -t 参数</h3><div class="note info modern"><p>通过搜索发现需要为 adb shell 分配伪终端，使用 <code>-t</code> 参数：</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell -t <span class="string">&quot;/sdcard/&lt;your_shell&gt;.sh&quot;</span></span><br></pre></td></tr></table></figure><h3 id="方法二：在构建脚本中使用"><a href="#方法二：在构建脚本中使用" class="headerlink" title="方法二：在构建脚本中使用"></a>方法二：在构建脚本中使用</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">Gradle</button><button type="button" class="tab">Java ProcessBuilder</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec &#123;</span><br><span class="line">    commandLine(<span class="string">&quot;adb&quot;</span>, <span class="string">&quot;shell&quot;</span>, <span class="string">&quot;-t&quot;</span>, <span class="string">&quot;/sdcard/&lt;your_shell&gt;.sh&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProcessBuilder(<span class="string">&quot;powershell&quot;</span>, <span class="string">&quot;-c&quot;</span>,<span class="string">&quot;\&quot;adb shell -t \&quot;sh /sdcard/1.sh\&quot;\&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="⚠️-常见错误"><a href="#⚠️-常见错误" class="headerlink" title="⚠️ 常见错误"></a>⚠️ 常见错误</h2><div class="note danger modern"><p><strong>错误信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remote PTY will not be allocated because stdin is not a terminal.</span><br></pre></td></tr></table></figure></div><h2 id="✅-最终解决方案"><a href="#✅-最终解决方案" class="headerlink" title="✅ 最终解决方案"></a>✅ 最终解决方案</h2><div class="note success modern"><p><strong>使用 <code>-tt</code> 参数</strong><br>在 <code>-t</code> 后面再加一个 <code>t</code>，即使用 <code>-tt</code> 参数来强制分配伪终端。</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell -tt <span class="string">&quot;/sdcard/&lt;your_shell&gt;.sh&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Adb </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BlurMaskFilter 内存泄露</title>
      <link href="/2025/07/02/Android/BlurMaskFilter%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
      <url>/2025/07/02/Android/BlurMaskFilter%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如标题，参考源码和效果</p></blockquote><blockquote><p><a href="https://github.com/crowforkotlin/android-canvas-drawline-blur-leak">https://github.com/crowforkotlin/android-canvas-drawline-blur-leak</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> 内存泄露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 离屏渲染详解</title>
      <link href="/2025/07/02/Android/Android%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"/>
      <url>/2025/07/02/Android/Android%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>📚 <strong>本文导读</strong><br>本文将从基础概念出发，详细讲解Android中的离屏渲染技术，包括其工作原理、应用场景以及性能优化策略。通过代码示例和对比分析，帮助开发者深入理解这一重要的图形渲染技术。</p></div><h2 id="📖-什么是离屏渲染？"><a href="#📖-什么是离屏渲染？" class="headerlink" title="📖 什么是离屏渲染？"></a>📖 什么是离屏渲染？</h2><div class="note primary modern"><p><strong>离屏渲染（Off-Screen Rendering）</strong><br>离屏渲染是指将图形内容渲染到一个不直接显示在屏幕上的缓冲区中，而不是直接渲染到屏幕上的帧缓冲区。这个过程创建了一个中间的渲染目标，可以在后续的渲染过程中被重复使用或进行额外的处理。</p></div><h2 id="🎨-效果对比演示"><a href="#🎨-效果对比演示" class="headerlink" title="🎨 效果对比演示"></a>🎨 效果对比演示</h2><h3 id="📱-普通绘制效果"><a href="#📱-普通绘制效果" class="headerlink" title="📱 普通绘制效果"></a>📱 普通绘制效果</h3><div class="note info modern"><p><strong>未使用离屏渲染的原始效果</strong><br>下图展示了直接在画布上绘制红色方块、文本和绿色方块的效果，没有应用任何合成模式。</p></div><p><img src="https://gitlab.com/crowforkotlin/page-storage/-/raw/main/image/post/img02.png" alt="普通绘制效果"></p><h3 id="🎯-离屏渲染效果"><a href="#🎯-离屏渲染效果" class="headerlink" title="🎯 离屏渲染效果"></a>🎯 离屏渲染效果</h3><div class="note success modern"><p><strong>绘制顺序分析</strong></p><ol><li>🔴 红色方块 → 📝 文本 → 🟢 绿色方块</li></ol><p>下图展示了使用离屏渲染后的效果，绿色方块覆盖在文本上，并设置合成模式为 <code>SRC_IN</code>。</p></div><p><img src="https://gitlab.com/crowforkotlin/page-storage/-/raw/main/image/post/img01.png" alt="离屏渲染效果图"></p><h3 id="🔍-合成模式详解"><a href="#🔍-合成模式详解" class="headerlink" title="🔍 合成模式详解"></a>🔍 合成模式详解</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">SRC_IN模式</button><button type="button" class="tab">为什么不是红色方块</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="note warning modern"><p><strong>SRC_IN 模式含义</strong><br>保持覆盖目标像素的源像素，丢弃剩余的源和目标像素。</p><ul><li><strong>目标像素</strong>：绿色方块</li><li><strong>源像素</strong>：文本</li></ul></div></div><div class="tab-item-content"><div class="note blue modern"><p><strong>图层分离机制</strong><br>在绘制完红色方块后，通过 <code>canvas.saveLayer()</code> 创建了一个离屏渲染层。这个图层会在绘制完文本后，才会被合成到屏幕上。就是在一个新的Canvas上作画，这个图层只包含了文本和绿色方块。</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="⚡-saveLayer-vs-save-对比"><a href="#⚡-saveLayer-vs-save-对比" class="headerlink" title="⚡ saveLayer vs save 对比"></a>⚡ saveLayer vs save 对比</h3><div class="note orange modern"><p><strong>关键区别</strong></p><ul><li><code>save()</code>：只保存变换矩阵、裁剪区域等状态</li><li><code>saveLayer()</code>：创建新的图层，合成模式仅影响该图层</li></ul></div><blockquote><p>上面效果所示，绿色方块覆盖在文本上。此时设置合成模式为SRC_IN，意思就是“保持覆盖目标像素的源像素，丢弃剩余的源和目标像素。这里目标像素是绿色方块，源像素是文本。这里说明一下为什么不是红色方块，因为在绘制完红色方块后，这里通过canvas.saveLayer()创建了一个离屏渲染的，这个图层会在绘制完文本后，才会被合成到屏幕上。就是在一个新的Canvas上作画，这个图层只包含了文本和绿色方块。如果这里不选择使用saveLayer而是save()这种操作的话只会保存变换矩阵、裁剪区域等状态。合成模式还是会针对这个主画布进行影响，而saveLayer恰好解决了这个问题</p></blockquote><h2 id="⚠️-性能注意事项"><a href="#⚠️-性能注意事项" class="headerlink" title="⚠️ 性能注意事项"></a>⚠️ 性能注意事项</h2><div class="note danger modern"><p><strong>性能警告</strong><br>官方说明 <code>saveLayer</code> API 需要谨慎使用，性能、内存消耗过大，只有复杂视图才需要这种实现效果。</p></div><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">内存分配</button><button type="button" class="tab">绘制开销</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="note red modern"><p><strong>内存占用计算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存占用 = width × height × 4字节(RGBA) × 采样倍数（例如抗锯齿）</span><br></pre></td></tr></table></figure></div></div><div class="tab-item-content"><div class="note red modern"><p><strong>双重绘制</strong></p><ol><li>在新的画布绘制一次</li><li>合成到主画布上绘制一次</li></ol></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="💻-代码实现"><a href="#💻-代码实现" class="headerlink" title="💻 代码实现"></a>💻 代码实现</h2><h3 id="🎯-方法一：使用-saveLayer"><a href="#🎯-方法一：使用-saveLayer" class="headerlink" title="🎯 方法一：使用 saveLayer"></a>🎯 方法一：使用 saveLayer</h3><details class="toggle" ><summary class="toggle-button" style="">查看 saveLayer 实现代码</summary><div class="toggle-content"><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LayerView</span> : <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context) : <span class="keyword">super</span>(context)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet) : <span class="keyword">super</span>(context, attrs)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet, style: <span class="built_in">Int</span>) : <span class="keyword">super</span>(context, attrs, style)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制背景红色方块</span></span><br><span class="line">        canvas.withSave &#123; </span><br><span class="line">            canvas.drawRect(<span class="number">200f</span>, <span class="number">200f</span>, <span class="number">600f</span>, <span class="number">600f</span>, Paint().apply &#123; </span><br><span class="line">                color = Color.RED </span><br><span class="line">            &#125;) </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建离屏渲染图层</span></span><br><span class="line">        <span class="keyword">val</span> layerPointer = canvas.saveLayer(<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在图层上绘制文本</span></span><br><span class="line">        canvas.drawText(<span class="string">&quot;文本A&quot;</span>, <span class="number">300f</span>, <span class="number">300f</span>, Paint().apply &#123;</span><br><span class="line">            color = Color.WHITE</span><br><span class="line">            textSize = <span class="number">50f</span></span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在图层上绘制绿色方块（使用SRC_IN合成模式）</span></span><br><span class="line">        canvas.drawRect(<span class="number">300f</span>, <span class="number">280f</span>, <span class="number">500f</span>, <span class="number">500f</span>, Paint().apply &#123;</span><br><span class="line">            xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)</span><br><span class="line">            color = Color.GREEN</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 恢复图层</span></span><br><span class="line">        canvas.restoreToCount(layerPointer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><h3 id="🎯-方法二：使用-Bitmap-离屏渲染实现类似savelayer方式"><a href="#🎯-方法二：使用-Bitmap-离屏渲染实现类似savelayer方式" class="headerlink" title="🎯 方法二：使用 Bitmap 离屏渲染实现类似savelayer方式"></a>🎯 方法二：使用 Bitmap 离屏渲染实现类似savelayer方式</h3><div class="note info modern"><p><strong>替代方案</strong><br>通过手动创建 Bitmap 和 Canvas 来实现离屏渲染，可以更精确地控制内存和性能。</p></div><details class="toggle" ><summary class="toggle-button" style="">查看 Bitmap 实现代码</summary><div class="toggle-content"><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LayerView</span> : <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context) : <span class="keyword">super</span>(context)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet) : <span class="keyword">super</span>(context, attrs)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet, style: <span class="built_in">Int</span>) : <span class="keyword">super</span>(context, attrs, style)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> offscreenCanvas = Canvas()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> offscreenBitmap: Bitmap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        MainScope().launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            invalidate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSizeChanged</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>, oldw: <span class="type">Int</span>, oldh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">        </span><br><span class="line">        CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class="line">            <span class="keyword">val</span> createTime = measureTimeMillis &#123;</span><br><span class="line">                <span class="comment">// 创建离屏Bitmap</span></span><br><span class="line">                offscreenBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)</span><br><span class="line">                offscreenCanvas = Canvas(offscreenBitmap)</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(<span class="string">&quot;LayerView&quot;</span>, <span class="string">&quot;创建bitmap及canvas耗时: <span class="subst">$&#123;createTime&#125;</span>ms&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在离屏画布上绘制大量元素</span></span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                offscreenCanvas.drawText(</span><br><span class="line">                    <span class="string">&quot;数值A&quot;</span>, </span><br><span class="line">                    (<span class="number">0.</span><span class="number">.300</span>).random().toFloat(), </span><br><span class="line">                    (<span class="number">0.</span><span class="number">.400</span>).random().toFloat(), </span><br><span class="line">                    Paint().apply &#123;</span><br><span class="line">                        color = Color.WHITE</span><br><span class="line">                        textSize = <span class="number">50f</span></span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">                </span><br><span class="line">                offscreenCanvas.drawRect(<span class="number">300f</span>, <span class="number">290f</span>, <span class="number">500f</span>, <span class="number">500f</span>, Paint().apply &#123;</span><br><span class="line">                    color = Color.GREEN</span><br><span class="line">                    xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制背景红色方块</span></span><br><span class="line">        canvas.withSave &#123; </span><br><span class="line">            canvas.drawRect(<span class="number">200f</span>, <span class="number">200f</span>, <span class="number">600f</span>, <span class="number">600f</span>, Paint().apply &#123; </span><br><span class="line">                color = Color.RED </span><br><span class="line">            &#125;) </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将离屏渲染的结果绘制到主画布</span></span><br><span class="line">        <span class="keyword">if</span> (::offscreenBitmap.isInitialized) &#123;</span><br><span class="line">            <span class="keyword">val</span> drawTime = measureNanoTime &#123; </span><br><span class="line">                canvas.drawBitmap(offscreenBitmap, <span class="number">0f</span>, <span class="number">0f</span>, Paint()) </span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(<span class="string">&quot;LayerView&quot;</span>, <span class="string">&quot;绘制bitmap耗时: <span class="subst">$&#123;drawTime&#125;</span>ns&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><h2 id="📊-性能对比分析"><a href="#📊-性能对比分析" class="headerlink" title="📊 性能对比分析"></a>📊 性能对比分析</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">saveLayer方式</button><button type="button" class="tab">Bitmap方式</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="note warning modern"><p><strong>saveLayer 特点</strong></p><ul><li>✅ 使用简单，API直接支持</li><li>❌ 内存占用大，系统自动管理</li><li>❌ 性能开销较大</li><li>⚠️ 适合简单的合成效果</li></ul></div></div><div class="tab-item-content"><div class="note success modern"><p><strong>Bitmap 特点</strong></p><ul><li>✅ 内存可控，可手动回收</li><li>✅ 性能上可控，特别是重复使用时</li><li>✅ 可在子线程处理</li><li>✅ 灵活性更高</li><li>❌ 需要手动管理生命周期</li></ul></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🎯-最佳实践建议"><a href="#🎯-最佳实践建议" class="headerlink" title="🎯 最佳实践建议"></a>🎯 最佳实践建议</h2><div class="note primary modern"><p><strong>选择建议</strong></p><ol><li><strong>简单合成效果</strong>：使用 <code>saveLayer</code></li><li><strong>复杂图形处理</strong>：使用 Bitmap 离屏渲染</li><li><strong>频繁重绘场景</strong>：优先考虑 Bitmap 方式</li><li><strong>内存敏感应用</strong>：谨慎使用离屏渲染</li></ol></div><div class="note success modern"><p><strong>优化技巧</strong></p><ul><li>🔧 合理控制离屏画布尺寸</li><li>🔧 及时回收 Bitmap 资源</li><li>🔧 避免在 onDraw 中创建 Bitmap</li><li>🔧 考虑使用硬件加速</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>① Hexo搭建并使用Butterfly主题</title>
      <link href="/2025/06/28/HEXO/01Hexo%E6%90%AD%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8Butterfly%E4%B8%BB%E9%A2%98/"/>
      <url>/2025/06/28/HEXO/01Hexo%E6%90%AD%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8Butterfly%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="🚀-环境准备"><a href="#🚀-环境准备" class="headerlink" title="🚀 环境准备"></a>🚀 环境准备</h2><div class="note info modern"><p><strong>前置要求</strong><br>在开始之前，请确保你的系统已经安装了以下环境：</p><ul><li>Node.js (建议使用最新LTS版本)</li><li>Git</li><li>一个代码编辑器 (推荐 VS Code)</li></ul></div><h3 id="1-安装-Node-js"><a href="#1-安装-Node-js" class="headerlink" title="1. 安装 Node.js"></a>1. 安装 Node.js</h3><div class="note warning no-icon flat"><p>需要提前安装 Node.js，并自行配置环境变量。如果使用 PowerShell 可能需要输入 <code>npm.cmd</code>，本教程采用的是 bash 环境。</p></div><h3 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h3><p>使用以下命令全局安装 Hexo CLI：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><a class="btn-beautify outline blue" href="https://hexo.io/zh-cn/docs/" title="Hexo官方文档"><i class="fas fa-external-link-alt"></i><span>Hexo官方文档</span></a><h2 id="📁-项目初始化"><a href="#📁-项目初始化" class="headerlink" title="📁 项目初始化"></a>📁 项目初始化</h2><h3 id="3-创建项目目录"><a href="#3-创建项目目录" class="headerlink" title="3. 创建项目目录"></a>3. 创建项目目录</h3><div class="note primary modern"><p>创建一个<strong>英文名称</strong>的文件夹，并在其中打开终端（PowerShell、CMD、Bash 任选其一）</p></div><h3 id="4-初始化-Hexo-项目"><a href="#4-初始化-Hexo-项目" class="headerlink" title="4. 初始化 Hexo 项目"></a>4. 初始化 Hexo 项目</h3><p>在项目根目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><h2 id="🎨-安装-Butterfly-主题"><a href="#🎨-安装-Butterfly-主题" class="headerlink" title="🎨 安装 Butterfly 主题"></a>🎨 安装 Butterfly 主题</h2><h3 id="5-下载主题源码"><a href="#5-下载主题源码" class="headerlink" title="5. 下载主题源码"></a>5. 下载主题源码</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">稳定版 (推荐)</button><button type="button" class="tab">开发版</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>开发版可能包含未测试的新功能，建议新手使用稳定版</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><a class="btn-beautify block center larger" href="https://github.com/jerryc127/hexo-theme-butterfly" title="Butterfly主题源码"><i class="fab fa-github"></i><span>Butterfly主题源码</span></a><h3 id="6-安装主题依赖"><a href="#6-安装主题依赖" class="headerlink" title="6. 安装主题依赖"></a>6. 安装主题依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-theme-butterfly</span><br></pre></td></tr></table></figure><h2 id="⚙️-配置主题"><a href="#⚙️-配置主题" class="headerlink" title="⚙️ 配置主题"></a>⚙️ 配置主题</h2><h3 id="7-配置文件设置"><a href="#7-配置文件设置" class="headerlink" title="7. 配置文件设置"></a>7. 配置文件设置</h3><div class="note success modern"><p><strong>重要步骤</strong></p><ol><li>将 <code>themes/butterfly/_config.yml</code> 复制到根目录</li><li>重命名为 <code>_config.butterfly.yml</code></li><li>修改根目录的 <code>_config.yml</code> 文件中的 <code>theme</code> 字段为 <code>butterfly</code></li></ol></div><h3 id="8-修改主题配置"><a href="#8-修改主题配置" class="headerlink" title="8. 修改主题配置"></a>8. 修改主题配置</h3><p>在根目录的 <code>_config.yml</code> 文件中找到 <code>theme</code> 字段，修改为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><h2 id="🎯-启动博客"><a href="#🎯-启动博客" class="headerlink" title="🎯 启动博客"></a>🎯 启动博客</h2><h3 id="9-清理并生成"><a href="#9-清理并生成" class="headerlink" title="9. 清理并生成"></a>9. 清理并生成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure><h3 id="10-启动本地服务器"><a href="#10-启动本地服务器" class="headerlink" title="10. 启动本地服务器"></a>10. 启动本地服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><div class="note success flat"><p><strong>🎉 恭喜！</strong><br>你的 Hexo 博客已经搭建完成！在浏览器中访问控制台提供的链接（通常是 <code>http://localhost:4000</code>），Ctrl + 鼠标左键点击即可访问你的博客。</p></div><h2 id="📋-命令总结"><a href="#📋-命令总结" class="headerlink" title="📋 命令总结"></a>📋 命令总结</h2><div class="btn-center"><a class="btn-beautify outline red" href="#" title="清理缓存"><i class="fas fa-broom"></i><span>清理缓存</span></a><a class="btn-beautify outline blue" href="#" title="生成静态文件"><i class="fas fa-cogs"></i><span>生成静态文件</span></a><a class="btn-beautify outline green" href="#" title="部署到服务器"><i class="fas fa-upload"></i><span>部署到服务器</span></a><a class="btn-beautify outline purple" href="#" title="启动本地服务"><i class="fas fa-server"></i><span>启动本地服务</span></a></div><details class="toggle" ><summary class="toggle-button" style="">完整命令列表</summary><div class="toggle-content"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理缓存和已生成的文件</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态文件</span></span><br><span class="line">hexo generate</span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动本地服务器</span></span><br><span class="line">hexo server</span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到远程服务器</span></span><br><span class="line">hexo deploy</span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成并部署</span></span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></div></details><hr>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>② Hexo 部署到GitLab Pages - 本地Runner自动化脚本</title>
      <link href="/2025/06/28/HEXO/02Hexo%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC%E5%8F%91%E5%B8%83%E6%9B%B4%E6%96%B0%E5%92%8C%E8%B0%83%E8%AF%95/"/>
      <url>/2025/06/28/HEXO/02Hexo%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC%E5%8F%91%E5%B8%83%E6%9B%B4%E6%96%B0%E5%92%8C%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>在第一篇教程中，我们已经详细介绍了如何搭建Hexo博客。接下来我们将学习如何将博客部署到GitLab Pages，并利用自定义脚本实现快捷运行和同步。</p><h2 id="🌐-什么是GitLab-Pages？"><a href="#🌐-什么是GitLab-Pages？" class="headerlink" title="🌐 什么是GitLab Pages？"></a>🌐 什么是GitLab Pages？</h2><div class="note info modern"><p><strong>GitLab Pages 简介</strong><br>GitLab Pages 是 GitLab 提供的静态网站托管服务。通过将网站文件推送到 GitLab 仓库，GitLab 会自动构建并部署网站，用户可以通过 GitLab 提供的域名访问自己的网站。</p></div><h3 id="📝-仓库命名规则"><a href="#📝-仓库命名规则" class="headerlink" title="📝 仓库命名规则"></a>📝 仓库命名规则</h3><div class="note warning flat"><p><strong>重要提醒</strong><br>假设你的用户名是 <code>crowforkotlin</code>，那么仓库名称必须是 <code>crowforkotlin.gitlab.io</code><br>这个命名规则是<strong>固定的</strong>，不能随意更改！</p></div><h3 id="⚙️-配置站点URL"><a href="#⚙️-配置站点URL" class="headerlink" title="⚙️ 配置站点URL"></a>⚙️ 配置站点URL</h3><p>在推送代码到GitLab之前，需要修改根目录的 <code>_config.yml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set your site url here</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://crowforkotlin.gitlab.io/</span></span><br></pre></td></tr></table></figure><h2 id="🏃‍♂️-什么是GitLab-Runner？"><a href="#🏃‍♂️-什么是GitLab-Runner？" class="headerlink" title="🏃‍♂️ 什么是GitLab Runner？"></a>🏃‍♂️ 什么是GitLab Runner？</h2><div class="note primary modern"><p><strong>GitLab Runner 介绍</strong><br>GitLab Runner 是一个开源项目，用于 GitLab CI&#x2F;CD 的执行环境。它可以在多种环境中运行，包括本地机器、虚拟机和云实例。GitLab Runner 负责接收来自 GitLab 的构建请求，并在指定的环境中执行相应的构建任务。</p></div><h2 id="📄-配置CI-x2F-CD文件"><a href="#📄-配置CI-x2F-CD文件" class="headerlink" title="📄 配置CI&#x2F;CD文件"></a>📄 配置CI&#x2F;CD文件</h2><p>当你把代码推送到GitLab后，此时GitLab Pages并不会生效，因为还需要一个 <code>.gitlab-ci.yml</code> 文件。这个文件是GitLab Runner的配置文件，GitLab Runner会根据这个文件来执行相应的脚本。</p><div class="note success modern"><p><strong>创建配置文件</strong><br>在项目根目录创建 <code>.gitlab-ci.yml</code> 文件</p></div><h3 id="CI-x2F-CD-配置示例"><a href="#CI-x2F-CD-配置示例" class="headerlink" title="CI&#x2F;CD 配置示例"></a>CI&#x2F;CD 配置示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">node:16.16.0</span>  <span class="comment"># 选用 Node.js 16.16.0 版本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pages:</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Home</span> <span class="comment"># 自定义标签，后续会用到</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_COMMIT_BRANCH</span> <span class="string">==</span> <span class="string">$CI_DEFAULT_BRANCH</span></span><br></pre></td></tr></table></figure><h2 id="🔧-安装和配置GitLab-Runner"><a href="#🔧-安装和配置GitLab-Runner" class="headerlink" title="🔧 安装和配置GitLab Runner"></a>🔧 安装和配置GitLab Runner</h2><div class="note info flat"><p><strong>为什么选择本地Runner？</strong><br>使用本地GitLab Runner可以：</p><ul><li>省去云端成本开销</li><li>减少云端启动容器时间</li><li>更好的控制构建环境</li><li>避免公共Runner的排队等待</li></ul></div><h3 id="步骤1-下载GitLab-Runner"><a href="#步骤1-下载GitLab-Runner" class="headerlink" title="步骤1: 下载GitLab Runner"></a>步骤1: 下载GitLab Runner</h3><a class="btn-beautify outline blue" href="https://docs.gitlab.com/runner/install/" title="GitLab Runner 官方下载"><i class="fas fa-download"></i><span>GitLab Runner 官方下载</span></a><a class="btn-beautify outline green" href="https://docs.gitlab.com/runner/register/?tab=Windows" title="Windows 注册指南"><i class="fas fa-book"></i><span>Windows 注册指南</span></a><h3 id="步骤2-注册Runner"><a href="#步骤2-注册Runner" class="headerlink" title="步骤2: 注册Runner"></a>步骤2: 注册Runner</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">获取注册令牌</button><button type="button" class="tab">执行注册命令</button></div><div class="tab-contents"><div class="tab-item-content active"><ol><li>打开你的GitLab Pages仓库</li><li>进入 <strong>Settings</strong> → <strong>CI&#x2F;CD</strong> → <strong>Runners</strong></li><li>点击 <strong>Create project runner</strong></li><li>输入你在 <code>.gitlab-ci.yml</code> 中设置的tags（如：<code>Home</code>）</li><li>点击 <strong>Create Runner</strong></li></ol></div><div class="tab-item-content"><p>复制页面显示的注册命令到命令行执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-runner register --url https://gitlab.com --token glrt-xxxxxxxxxx</span><br></pre></td></tr></table></figure><div class="note warning no-icon flat"><p>由于Windows下可能双击无反应，需要使用Git Bash、CMD或PowerShell等命令行工具执行</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="步骤3-配置Runner"><a href="#步骤3-配置Runner" class="headerlink" title="步骤3: 配置Runner"></a>步骤3: 配置Runner</h3><p>找到配置文件 <code>C:\Program Files\Git\config.toml</code>，可能需要手动修改shell为powershell：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[runners]]</span></span><br><span class="line">  <span class="attr">name</span> = <span class="string">&quot;Home&quot;</span></span><br><span class="line">  <span class="attr">url</span> = <span class="string">&quot;https://gitlab.com&quot;</span></span><br><span class="line">  <span class="attr">pre_clone_script</span> = <span class="string">&quot;git config --global --add safe.directory $&#123;CI_PROJECT_DIR&#125;&quot;</span></span><br><span class="line">  <span class="attr">id</span> = <span class="number">47770241</span></span><br><span class="line">  <span class="attr">token</span> = <span class="string">&quot;glrt-xxxxxxxxxx&quot;</span></span><br><span class="line">  <span class="attr">token_obtained_at</span> = <span class="number">2025</span>-<span class="number">06</span>-<span class="number">10</span>T07:<span class="number">33</span>:<span class="number">07</span>Z</span><br><span class="line">  <span class="attr">token_expires_at</span> = <span class="number">0001</span>-<span class="number">01</span>-<span class="number">01</span>T00:<span class="number">00</span>:<span class="number">00</span>Z</span><br><span class="line">  <span class="attr">executor</span> = <span class="string">&quot;shell&quot;</span></span><br><span class="line">  <span class="attr">shell</span> = <span class="string">&quot;powershell&quot;</span>  <span class="comment"># 重要：设置为powershell</span></span><br><span class="line">  <span class="section">[runners.cache]</span></span><br><span class="line">    <span class="attr">MaxUploadedArchiveSize</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="步骤4-启动Runner"><a href="#步骤4-启动Runner" class="headerlink" title="步骤4: 启动Runner"></a>步骤4: 启动Runner</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">gitlab-runner stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务  </span></span><br><span class="line">gitlab-runner start</span><br></pre></td></tr></table></figure><h2 id="🚀-部署流程"><a href="#🚀-部署流程" class="headerlink" title="🚀 部署流程"></a>🚀 部署流程</h2><ol><li><strong>推送代码到GitLab</strong></li><li><strong>启动本地Runner服务</strong></li><li><strong>查看构建过程</strong></li><li><strong>访问你的网站</strong>：<code>https://your-username.gitlab.io/</code></li></ol><div class="note success flat"><p><strong>🎉 部署成功！</strong><br>现在你可以通过GitLab提供的域名访问你的博客了</p></div><h2 id="🛠️-自动化脚本集合"><a href="#🛠️-自动化脚本集合" class="headerlink" title="🛠️ 自动化脚本集合"></a>🛠️ 自动化脚本集合</h2><div class="note green icon-padding modern"><i class="note-icon fas fa-magic"></i><p><strong>提升效率</strong><br>每次手动执行一大串流程确实繁琐，我编写了一套自动化脚本来快速完成日常操作。</p></div><h3 id="📦-脚本下载"><a href="#📦-脚本下载" class="headerlink" title="📦 脚本下载"></a>📦 脚本下载</h3><a class="btn-beautify block center larger" href="https://gitlab.com/crowforkotlin/page-storage-hexo-script" title="获取完整脚本"><i class="fab fa-gitlab"></i><span>获取完整脚本</span></a><h3 id="🔧-使用方法"><a href="#🔧-使用方法" class="headerlink" title="🔧 使用方法"></a>🔧 使用方法</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">下载和配置</button><button type="button" class="tab">路径配置示例</button><button type="button" class="tab">权限设置</button></div><div class="tab-contents"><div class="tab-item-content active"><ol><li><p><strong>克隆脚本仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitlab.com/crowforkotlin/page-storage-hexo-script.git</span><br></pre></td></tr></table></figure></li><li><p><strong>修改脚本配置</strong></p><ul><li>编辑脚本中的 <code>BLOG_PATH</code> 变量</li><li>根据你的项目路径进行调整</li></ul></li><li><p><strong>配置环境变量</strong></p><ul><li>将脚本目录添加到系统 PATH</li><li>或者直接在脚本目录下使用</li></ul></li><li><p><strong>运行环境</strong></p><ul><li>Git Bash（推荐）</li><li>CMD</li><li>PowerShell</li></ul></li></ol></div><div class="tab-item-content"><p>在每个脚本中找到并修改以下路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改为你的博客项目路径</span></span><br><span class="line">BLOG_PATH=<span class="string">&quot;/d/fish/your-username.gitlab.io&quot;</span></span><br></pre></td></tr></table></figure><p><strong>常见路径格式</strong>：</p><ul><li>Windows: <code>/d/fish/crowforkotlin.gitlab.io</code></li><li>Linux&#x2F;Mac: <code>/home/user/crowforkotlin.gitlab.io</code></li></ul><div class="note warning no-icon flat"><p><strong>注意</strong>：路径中不要包含中文字符，建议使用英文路径</p></div></div><div class="tab-item-content"><p><strong>Linux&#x2F;Mac 用户</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给脚本添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x *.sh</span><br></pre></td></tr></table></figure><p><strong>Windows 用户</strong>：</p><ul><li>确保已安装 Git Bash</li><li>可能需要以管理员身份运行某些脚本</li><li>部分脚本会自动请求管理员权限</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">🚀 启动Runner</button><button type="button" class="tab">📤 推送到GitLab</button><button type="button" class="tab">🖥️ 本地调试</button><button type="button" class="tab">⚡ 一键部署</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>功能</strong>：自动检测权限并启动GitLab Runner服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查管理员权限</span></span><br><span class="line">net session &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 已经是管理员</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Running with administrator privileges...&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Restarting GitLab Runner service...&quot;</span></span><br><span class="line">  </span><br><span class="line">  gitlab-runner stop</span><br><span class="line">  gitlab-runner start</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Service restart command issued.&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># 需要提权</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Administrator privileges required. Attempting to re-launch with elevation...&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 使用PowerShell提权重新运行</span></span><br><span class="line">  powershell.exe -Command <span class="string">&quot;Start-Process -FilePath &#x27;bash&#x27; -ArgumentList &#x27;-c \&quot;<span class="subst">$(readlink -f <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>\&quot;&#x27; -Verb RunAs&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p><strong>功能</strong>：一键提交并推送代码到GitLab仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义博客项目路径</span></span><br><span class="line">BLOG_PATH=<span class="string">&quot;/d/fish/crowforkotlin.gitlab.io&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;===================================&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;push blog to git&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;===================================&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Working directory: <span class="variable">$BLOG_PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到博客项目目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$BLOG_PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;:label: update&quot;</span></span><br><span class="line">git push origin main -f</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p><strong>功能</strong>：清理、生成并启动本地预览服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义博客项目路径</span></span><br><span class="line">BLOG_PATH=<span class="string">&quot;/d/fish/crowforkotlin.gitlab.io&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;===================================&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; Hexo Blog Workflow Started&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;===================================&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Working directory: <span class="variable">$BLOG_PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到博客项目目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$BLOG_PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[1/3] Cleaning old files...&quot;</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[2/3] Generating new static files...&quot;</span></span><br><span class="line">hexo g -f</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[3/3] Starting local server for preview...&quot;</span></span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;===================================&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; All tasks completed.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; Local server is running at http://localhost:4000&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;===================================&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让窗口保持打开</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Press Enter to exit...&quot;</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p><strong>功能</strong>：组合脚本，一键完成启动Runner和推送代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🚀 Starting automated deployment...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动GitLab Runner</span></span><br><span class="line">./gitlab-start.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;⏳ Waiting for runner to start...&quot;</span></span><br><span class="line"><span class="built_in">sleep</span> 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送代码到GitLab</span></span><br><span class="line">./gitlab-update.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;✅ Deployment process completed!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🌐 Check your GitLab Pages site for updates&quot;</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="📚-参考资源"><a href="#📚-参考资源" class="headerlink" title="📚 参考资源"></a>📚 参考资源</h2><div class="btn-center"><a class="btn-beautify larger" href="https://gitlab.com/crowforkotlin/page-storage-hexo-script" title="自动化脚本仓库"><i class="fab fa-gitlab"></i><span>自动化脚本仓库</span></a><a class="btn-beautify blue larger" href="https://docs.gitlab.com/runner/register/?tab=Windows" title="Runner注册指南"><i class="fas fa-book"></i><span>Runner注册指南</span></a><a class="btn-beautify green larger" href="https://docs.gitlab.com/ee/user/project/pages/" title="GitLab Pages文档"><i class="fas fa-file-alt"></i><span>GitLab Pages文档</span></a></div><h2 id="🎯-快捷方式配置与使用"><a href="#🎯-快捷方式配置与使用" class="headerlink" title="🎯 快捷方式配置与使用"></a>🎯 快捷方式配置与使用</h2><div class="note green icon-padding modern"><i class="note-icon fas fa-rocket"></i><p><strong>极简操作</strong><br>通过快捷脚本，参考我已经开源的script仓库，只需要输入 <code>launch</code> 即可自动推送并运行runner，当然你也可以根据需求自定义脚本功能。</p></div><h3 id="🚀-一键部署-launch-命令"><a href="#🚀-一键部署-launch-命令" class="headerlink" title="🚀 一键部署 - launch 命令"></a>🚀 一键部署 - launch 命令</h3><p>使用开源的脚本仓库，你可以实现：</p><ul><li><strong>一键启动</strong>：自动运行GitLab Runner</li><li><strong>自动推送</strong>：提交并推送代码到GitLab</li></ul><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">创建系统快捷方式</button><button type="button" class="tab">uTools启动器配置</button><button type="button" class="tab">自定义脚本</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>方法一：Windows快捷方式</strong></p><p>在创建快捷方式时，输入对象的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;C:\Program Files\Git\git-bash.exe&quot;</span> -c <span class="string">&quot;launch&quot;</span></span><br></pre></td></tr></table></figure><p><strong>配置步骤</strong>：</p><ol><li>右键桌面 → 新建 → 快捷方式</li><li>输入上述命令路径</li><li>命名为 “Hexo Deploy” 或其他你喜欢的名称</li><li>完成创建</li></ol><div class="note warning no-icon flat"><p><strong>提醒</strong>：需要先将脚本目录添加到系统环境变量PATH中</p></div></div><div class="tab-item-content"><p><strong>方法二：uTools工具（推荐）</strong></p><div class="note primary flat"><p><strong>为什么选择uTools？</strong></p><ul><li>全局快速启动</li><li>无需记忆复杂路径</li><li>支持关键词搜索</li><li>界面美观易用</li></ul></div><p><strong>配置步骤</strong>：</p><ol><li>下载并安装 <a href="https://u.tools/">uTools</a></li><li>打开uTools设置</li><li>进入 <strong>设置</strong> → <strong>文件启动选项</strong></li><li>将launch脚本快捷方式拖入启动选项</li><li>设置关键词（如：<code>launch</code>、<code>hexo</code>、<code>deploy</code>）</li></ol><p><strong>使用方法</strong>：</p><ul><li>按下 <code>Alt + Space</code> 唤起uTools</li><li>输入 <code>launch</code> 或设置的关键词</li><li>回车执行，完成一键部署</li></ul><div class="note success no-icon flat"><p><strong>效果</strong>：更新整个Hexo博客并推送更新到GitLab Pages，只需要输入一个关键词！</p></div></div><div class="tab-item-content"><p><strong>方法三：自定义launch脚本</strong></p><p>你可以根据需求修改launch脚本的功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># launch.sh - 自定义一键部署脚本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🚀 Starting Hexo deployment workflow...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：添加预处理步骤</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;📝 Checking for new posts...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动GitLab Runner</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🔧 Starting GitLab Runner...&quot;</span></span><br><span class="line">./gitlab-start.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待Runner启动</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;⏳ Waiting for runner to initialize...&quot;</span></span><br><span class="line"><span class="built_in">sleep</span> 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送代码</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;📤 Pushing to GitLab...&quot;</span></span><br><span class="line">./gitlab-update.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：打开浏览器预览</span></span><br><span class="line"><span class="comment"># echo &quot;🌐 Opening browser preview...&quot;</span></span><br><span class="line"><span class="comment"># start https://your-username.gitlab.io</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;✅ Deployment completed successfully!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🎉 Your blog is now updated!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保持窗口打开以查看结果</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Press Enter to exit...&quot;</span></span><br></pre></td></tr></table></figure><p><strong>自定义选项</strong>：</p><ul><li>添加构建前检查</li><li>集成图片压缩</li><li>自动打开浏览器预览</li><li>发送部署完成通知</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="🛠️-环境变量配置"><a href="#🛠️-环境变量配置" class="headerlink" title="🛠️ 环境变量配置"></a>🛠️ 环境变量配置</h3><div class="note info modern"><p><strong>环境变量设置</strong><br>为了在任意位置使用脚本命令，需要配置系统环境变量</p></div><p><strong>Windows 配置步骤</strong>：</p><ol><li>右键 “此电脑” → 属性</li><li>高级系统设置 → 环境变量</li><li>在系统变量中找到 “Path”</li><li>添加脚本所在目录路径</li><li>确定保存</li></ol><p><strong>验证配置</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在任意目录打开命令行，输入：</span></span><br><span class="line">launch</span><br><span class="line"><span class="comment"># 如果能正常执行，说明配置成功</span></span><br></pre></td></tr></table></figure><h2 id="📋-常用命令速查"><a href="#📋-常用命令速查" class="headerlink" title="📋 常用命令速查"></a>📋 常用命令速查</h2><div class="btn-center"><a class="btn-beautify outline green" href="#" title="启动Runner"><i class="fas fa-play"></i><span>启动Runner</span></a><a class="btn-beautify outline red" href="#" title="停止Runner"><i class="fas fa-stop"></i><span>停止Runner</span></a><a class="btn-beautify outline blue" href="#" title="推送代码"><i class="fas fa-upload"></i><span>推送代码</span></a><a class="btn-beautify outline purple" href="#" title="本地预览"><i class="fas fa-eye"></i><span>本地预览</span></a></div><details class="toggle" ><summary class="toggle-button" style="">完整命令列表</summary><div class="toggle-content"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GitLab Runner 管理</span></span><br><span class="line">gitlab-runner start    <span class="comment"># 启动服务</span></span><br><span class="line">gitlab-runner stop     <span class="comment"># 停止服务</span></span><br><span class="line">gitlab-runner status   <span class="comment"># 查看状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Git 操作</span></span><br><span class="line">git add -A                    <span class="comment"># 添加所有文件</span></span><br><span class="line">git commit -m <span class="string">&quot;message&quot;</span>       <span class="comment"># 提交变更</span></span><br><span class="line">git push origin main -f       <span class="comment"># 强制推送到主分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hexo 操作</span></span><br><span class="line">hexo clean      <span class="comment"># 清理缓存</span></span><br><span class="line">hexo generate   <span class="comment"># 生成静态文件</span></span><br><span class="line">hexo server     <span class="comment"># 启动本地服务器</span></span><br><span class="line">hexo deploy     <span class="comment"># 部署到远程</span></span><br></pre></td></tr></table></figure></div></details><hr><h2 id="💡-故障排除"><a href="#💡-故障排除" class="headerlink" title="💡 故障排除"></a>💡 故障排除</h2><div class="note danger modern"><p><strong>常见问题解决方案</strong></p></div><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">Runner无法启动</button><button type="button" class="tab">构建失败</button><button type="button" class="tab">脚本权限问题</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>问题现象</strong>：Runner服务无法正常启动</p><p><strong>解决方案</strong>：</p><ol><li>检查管理员权限</li><li>确认Runner已正确注册</li><li>检查配置文件路径</li><li>重新安装Runner服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新安装服务</span></span><br><span class="line">gitlab-runner uninstall</span><br><span class="line">gitlab-runner install</span><br><span class="line">gitlab-runner start</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p><strong>问题现象</strong>：CI&#x2F;CD流水线构建失败</p><p><strong>解决方案</strong>：</p><ol><li>检查 <code>.gitlab-ci.yml</code> 语法</li><li>确认Node.js版本兼容性</li><li>检查依赖包安装</li><li>查看详细构建日志</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地测试构建过程</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p><strong>问题现象</strong>：脚本无法执行或权限不足</p><p><strong>解决方案</strong>：</p><ol><li>以管理员身份运行</li><li>修改脚本执行权限</li><li>检查路径配置</li><li>确认Git Bash环境</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux/Mac 添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x script-name.sh</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🎉-部署成功检查"><a href="#🎉-部署成功检查" class="headerlink" title="🎉 部署成功检查"></a>🎉 部署成功检查</h2><div class="note success icon-padding modern"><i class="note-icon fas fa-check-circle"></i><p><strong>部署完成后的验证步骤</strong></p><ol><li>✅ GitLab Pages构建成功</li><li>✅ 网站可正常访问</li><li>✅ 样式和资源加载正常</li><li>✅ 文章内容显示正确</li></ol></div><div class="note success icon-padding modern"><i class="note-icon fas fa-lightbulb"></i><p><strong>进阶小贴士</strong></p><ul><li>脚本路径需要根据实际情况修改</li><li>建议将常用脚本添加到系统环境变量中</li><li>可以根据需求自定义脚本功能</li><li>记得定期检查GitLab Runner的运行状态</li><li>建议定期备份重要的配置文件</li><li>可以设置定时任务自动执行部署脚本</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📱 Android虚拟机Root教程</title>
      <link href="/2025/06/11/Android/Avd%20Root/"/>
      <url>/2025/06/11/Android/Avd%20Root/</url>
      
        <content type="html"><![CDATA[<h2 id="🛠️-工具介绍"><a href="#🛠️-工具介绍" class="headerlink" title="🛠️ 工具介绍"></a>🛠️ 工具介绍</h2><div class="note blue icon-padding modern"><i class="note-icon fab fa-github"></i><p><strong>开源工具：RootAVD</strong></p><ul><li>项目地址：<a href="https://github.com/crowforkotlin/rootAVD">RootAVD - GitHub</a></li><li>专门用于Android虚拟机Root的自动化工具</li><li>支持多种Android API版本</li></ul></div><h2 id="🚀-操作流程"><a href="#🚀-操作流程" class="headerlink" title="🚀 操作流程"></a>🚀 操作流程</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">虚拟机创建</button><button type="button" class="tab">Root安装</button><button type="button" class="tab">Magisk配置</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="📱-选择虚拟机配置"><a href="#📱-选择虚拟机配置" class="headerlink" title="📱 选择虚拟机配置"></a>📱 选择虚拟机配置</h3><div class="note warning icon-padding modern"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>推荐配置：</strong></p><ul><li>Android API 25 (Android 7.1)</li><li>架构：64位</li><li>类型：Google APIs</li></ul></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建虚拟机后建议重新命名</span></span><br><span class="line"><span class="comment"># 例如：RootAvd25、RootAvdXX</span></span><br></pre></td></tr></table></figure><div class="note info icon-padding modern"><i class="note-icon fas fa-info-circle"></i><p><strong>版本选择说明：</strong><br>经测试API 35、34版本可能遇到问题，API 25稳定性较好</p></div></div><div class="tab-item-content"><h3 id="🔧-执行Root操作"><a href="#🔧-执行Root操作" class="headerlink" title="🔧 执行Root操作"></a>🔧 执行Root操作</h3><div class="note success icon-padding modern"><i class="note-icon fas fa-magic"></i><p><strong>自动Root流程：</strong></p><ol><li>运行RootAVD脚本选择对应镜像</li><li>工具会自动安装Magisk</li><li>打开Magisk统一权限，等待5秒自动重启</li></ol></div><h3 id="⚙️-重要配置"><a href="#⚙️-重要配置" class="headerlink" title="⚙️ 重要配置"></a>⚙️ 重要配置</h3><div class="note primary icon-padding modern"><i class="note-icon fas fa-cogs"></i><p><strong>参考配置说明：</strong><br>详见 <a href="https://github.com/crowforkotlin/rootAVD?tab=readme-ov-file#automotive-notes">RootAVD Notes</a></p></div></div><div class="tab-item-content"><h3 id="🎯-Magisk设置"><a href="#🎯-Magisk设置" class="headerlink" title="🎯 Magisk设置"></a>🎯 Magisk设置</h3><div class="note purple icon-padding modern"><i class="note-icon fas fa-android"></i><p><strong>Magisk配置步骤：</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 勾选启用Magisk</span></span><br><span class="line"><span class="comment"># 2. Magisk App -&gt; Settings -&gt; Multiuser Mode -&gt; User-Independent</span></span><br><span class="line"><span class="comment"># 3. 重启AVD</span></span><br><span class="line"><span class="comment"># 4. 在Magisk中选择reboot</span></span><br></pre></td></tr></table></figure><h3 id="🔓-系统写入权限"><a href="#🔓-系统写入权限" class="headerlink" title="🔓 系统写入权限"></a>🔓 系统写入权限</h3><div class="note orange icon-padding modern"><i class="note-icon fas fa-terminal"></i><p><strong>启用系统写入权限：</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以可写系统模式运行AVD</span></span><br><span class="line">emulator -writable-system -avd Avd71</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后续可通过mount、remount挂载操作</span></span><br><span class="line"><span class="comment"># 实现系统文件的增删改功能</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🔗-相关链接"><a href="#🔗-相关链接" class="headerlink" title="🔗 相关链接"></a>🔗 相关链接</h2><div class="btn-center"><a class="btn-beautify blue larger" href="https://github.com/crowforkotlin/rootAVD" title="RootAVD工具"><i class="fab fa-github"></i><span>RootAVD工具</span></a><a class="btn-beautify green larger" href="https://github.com/topjohnwu/Magisk" title="Magisk项目"><i class="fab fa-github"></i><span>Magisk项目</span></a></div>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Root </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Avd </tag>
            
            <tag> Magisk </tag>
            
            <tag> Root </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python环境快速搭建指南</title>
      <link href="/2025/06/11/Python/Python%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
      <url>/2025/06/11/Python/Python%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<div class="note modern"><p>🎯 <strong>学习目标</strong>：掌握Python开发环境的搭建和虚拟环境管理，为Python项目开发打下坚实基础</p></div><h2 id="📥-Python安装"><a href="#📥-Python安装" class="headerlink" title="📥 Python安装"></a>📥 Python安装</h2><h3 id="🌐-下载与安装"><a href="#🌐-下载与安装" class="headerlink" title="🌐 下载与安装"></a>🌐 下载与安装</h3><div class="note info icon-padding flat"><i class="note-icon fas fa-download"></i><p><strong>官方下载地址</strong>：<a href="https://www.python.org/downloads/">Python官方网站</a><br><strong>推荐版本</strong>：Python 3.11+ (具备更好的性能和特性)</p></div><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">🪟 Windows 安装</button><button type="button" class="tab">🐧 Linux 安装</button><button type="button" class="tab">🍎 macOS 安装</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="Windows-安装步骤"><a href="#Windows-安装步骤" class="headerlink" title="Windows 安装步骤"></a>Windows 安装步骤</h3><ol><li><p><strong>下载安装包</strong></p><ul><li>访问Python官网下载最新版本</li><li>选择适合系统架构的安装包（32位&#x2F;64位）</li></ul></li><li><p><strong>安装配置</strong></p><div class="note warning icon-padding flat"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>重要</strong>：安装时务必勾选以下选项</p></div><ul><li>✅ <strong>Add Python to PATH</strong> (添加到环境变量)</li><li>✅ <strong>Install pip</strong> (安装包管理器)</li><li>🔧 选择自定义安装路径（可选）</li></ul></li><li><p><strong>环境变量验证</strong></p><p>确认以下路径已添加到系统环境变量 <code>Path</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\program\Python311\</span><br><span class="line">D:\program\Python311\Scripts\</span><br></pre></td></tr></table></figure></li></ol><div class="note success icon-padding flat"><i class="note-icon fas fa-check-circle"></i><p><strong>验证安装</strong>：打开命令行输入 <code>python --version</code> 检查安装是否成功</p></div></div><div class="tab-item-content"><h3 id="Ubuntu-x2F-Debian-系统"><a href="#Ubuntu-x2F-Debian-系统" class="headerlink" title="Ubuntu&#x2F;Debian 系统"></a>Ubuntu&#x2F;Debian 系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新包管理器</span></span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Python</span></span><br><span class="line">sudo apt install python3 python3-pip python3-venv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">python3 --version</span><br><span class="line">pip3 --version</span><br></pre></td></tr></table></figure><h3 id="CentOS-x2F-RHEL-系统"><a href="#CentOS-x2F-RHEL-系统" class="headerlink" title="CentOS&#x2F;RHEL 系统"></a>CentOS&#x2F;RHEL 系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Python</span></span><br><span class="line">sudo yum install python3 python3-pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用dnf (较新版本)</span></span><br><span class="line">sudo dnf install python3 python3-pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">python3 --version</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h3 id="使用-Homebrew（推荐）"><a href="#使用-Homebrew（推荐）" class="headerlink" title="使用 Homebrew（推荐）"></a>使用 Homebrew（推荐）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Homebrew (如果未安装)</span></span><br><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Python</span></span><br><span class="line">brew install python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">python3 --version</span><br><span class="line">pip3 --version</span><br></pre></td></tr></table></figure><h3 id="使用官方安装包"><a href="#使用官方安装包" class="headerlink" title="使用官方安装包"></a>使用官方安装包</h3><ul><li>下载 macOS 专用的 <code>.pkg</code> 安装包</li><li>双击安装并按提示操作</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🚀-虚拟环境管理"><a href="#🚀-虚拟环境管理" class="headerlink" title="🚀 虚拟环境管理"></a>🚀 虚拟环境管理</h2><div class="note blue icon-padding modern"><i class="note-icon fas fa-info-circle"></i><p><strong>为什么需要虚拟环境？</strong><br>虚拟环境为每个项目创建独立的Python运行环境，避免依赖冲突，便于项目管理和部署。</p></div><h3 id="📁-项目初始化"><a href="#📁-项目初始化" class="headerlink" title="📁 项目初始化"></a>📁 项目初始化</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">📂 创建项目</button><button type="button" class="tab">🌍 创建虚拟环境</button><button type="button" class="tab">⚡ 激活环境</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>创建项目目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><div class="note green icon-padding flat"><i class="note-icon fas fa-folder"></i><p><strong>建议</strong>：使用有意义的项目名称，如 <code>my-python-project</code></p></div></div><div class="tab-item-content"><p><strong>创建虚拟环境</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m venv venv</span><br></pre></td></tr></table></figure><div class="note purple icon-padding flat"><i class="note-icon fas fa-magic"></i><p><strong>命令解析</strong>：<code>venv</code> 是Python内置的虚拟环境模块，第二个 <code>venv</code> 是环境目录名</p></div></div><div class="tab-item-content"><p><strong>激活虚拟环境</strong></p><p><strong>Windows 系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">venv\Scripts\activate</span><br></pre></td></tr></table></figure><p><strong>Linux&#x2F;macOS 系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br></pre></td></tr></table></figure><div class="note success icon-padding flat"><i class="note-icon fas fa-check"></i><p><strong>成功标志</strong>：激活后命令行前会显示 <code>(venv)</code> 标识</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="🔧-环境配置"><a href="#🔧-环境配置" class="headerlink" title="🔧 环境配置"></a>🔧 环境配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新pip到最新版本</span></span><br><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure><div class="note warning icon-padding flat"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>注意</strong>：建议每次创建新环境后都更新pip，确保使用最新功能</p></div><h2 id="📦-依赖包管理"><a href="#📦-依赖包管理" class="headerlink" title="📦 依赖包管理"></a>📦 依赖包管理</h2><h3 id="🔽-安装依赖包"><a href="#🔽-安装依赖包" class="headerlink" title="🔽 安装依赖包"></a>🔽 安装依赖包</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">📥 单个安装</button><button type="button" class="tab">📄 批量管理</button><button type="button" class="tab">🔍 查看与卸载</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>安装单个包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install package_name</span><br></pre></td></tr></table></figure><p><strong>常用包安装示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HTTP请求库</span></span><br><span class="line">pip install requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据分析库</span></span><br><span class="line">pip install numpy pandas</span><br><span class="line"></span><br><span class="line"><span class="comment"># Web框架</span></span><br><span class="line">pip install flask django</span><br><span class="line"></span><br><span class="line"><span class="comment"># 机器学习</span></span><br><span class="line">pip install scikit-learn tensorflow</span><br></pre></td></tr></table></figure><div class="note blue icon-padding flat"><i class="note-icon fas fa-lightbulb"></i><p><strong>提示</strong>：可以指定版本 <code>pip install package_name==1.2.3</code></p></div></div><div class="tab-item-content"><p><strong>生成依赖文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><p><strong>安装依赖文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><div class="note green icon-padding flat"><i class="note-icon fas fa-file-alt"></i><p><strong>最佳实践</strong>：每次修改依赖后都要更新 <code>requirements.txt</code></p></div></div><div class="tab-item-content"><p><strong>查看已安装的包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure><p><strong>查看包详细信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show package_name</span><br></pre></td></tr></table></figure><p><strong>卸载包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall package_name</span><br></pre></td></tr></table></figure><div class="note red icon-padding flat"><i class="note-icon fas fa-trash"></i><p><strong>注意</strong>：卸载包时会询问确认，使用 <code>-y</code> 参数可跳过确认</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🔄-环境切换与管理"><a href="#🔄-环境切换与管理" class="headerlink" title="🔄 环境切换与管理"></a>🔄 环境切换与管理</h2><h3 id="❌-退出虚拟环境"><a href="#❌-退出虚拟环境" class="headerlink" title="❌ 退出虚拟环境"></a>❌ 退出虚拟环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><div class="note info icon-padding flat"><i class="note-icon fas fa-sign-out-alt"></i><p>退出后回到全局Python环境，命令行前的 <code>(venv)</code> 标识会消失</p></div><h3 id="🗑️-删除虚拟环境"><a href="#🗑️-删除虚拟环境" class="headerlink" title="🗑️ 删除虚拟环境"></a>🗑️ 删除虚拟环境</h3><p><strong>Windows 系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> /s venv</span><br></pre></td></tr></table></figure><p><strong>Linux&#x2F;macOS 系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf venv</span><br></pre></td></tr></table></figure><div class="note danger icon-padding flat"><i class="note-icon fas fa-exclamation-circle"></i><p><strong>警告</strong>：删除虚拟环境会丢失所有已安装的包，请确保已备份 <code>requirements.txt</code></p></div><h2 id="�-快速参考"><a href="#�-快速参考" class="headerlink" title="� 快速参考"></a>� 快速参考</h2><h3 id="🔧-常用命令速查表"><a href="#🔧-常用命令速查表" class="headerlink" title="🔧 常用命令速查表"></a>🔧 常用命令速查表</h3><table><thead><tr><th>命令</th><th>功能描述</th></tr></thead><tbody><tr><td><code>python -m venv venv</code></td><td>🆕 创建虚拟环境</td></tr><tr><td><code>venv\Scripts\activate</code></td><td>▶️ 激活环境(Windows)</td></tr><tr><td><code>source venv/bin/activate</code></td><td>▶️ 激活环境(Linux&#x2F;Mac)</td></tr><tr><td><code>deactivate</code></td><td>⏹️ 退出虚拟环境</td></tr><tr><td><code>pip install package</code></td><td>📥 安装包</td></tr><tr><td><code>pip freeze &gt; requirements.txt</code></td><td>📄 导出依赖列表</td></tr><tr><td><code>pip install -r requirements.txt</code></td><td>📦 安装依赖列表</td></tr><tr><td><code>pip list</code></td><td>📋 查看已安装包</td></tr><tr><td><code>pip uninstall package</code></td><td>🗑️ 卸载包</td></tr></tbody></table><h3 id="🎯-最佳实践建议"><a href="#🎯-最佳实践建议" class="headerlink" title="🎯 最佳实践建议"></a>🎯 最佳实践建议</h3><div class="note green icon-padding modern"><i class="note-icon fas fa-lightbulb"></i><p><strong>项目隔离</strong>：每个项目使用独立虚拟环境，避免依赖冲突</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-sync"></i><p><strong>及时更新</strong>：新增依赖后及时更新 <code>requirements.txt</code>，保持团队环境同步</p></div><div class="note purple icon-padding modern"><i class="note-icon fas fa-code-branch"></i><p><strong>版本控制</strong>：将 <code>requirements.txt</code> 纳入Git管理，但排除 <code>venv/</code> 目录</p></div><h3 id="📝-gitignore-配置"><a href="#📝-gitignore-配置" class="headerlink" title="📝 .gitignore 配置"></a>📝 .gitignore 配置</h3><div class="note orange icon-padding flat"><i class="note-icon fab fa-git-alt"></i><p><strong>推荐配置</strong>：在项目根目录创建 <code>.gitignore</code> 文件</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Python 虚拟环境</span><br><span class="line">venv/</span><br><span class="line">env/</span><br><span class="line"></span><br><span class="line"># Python 缓存文件</span><br><span class="line">__pycache__/</span><br><span class="line">*.pyc</span><br><span class="line">*.pyo</span><br><span class="line">*.pyd</span><br><span class="line"></span><br><span class="line"># IDE 配置文件</span><br><span class="line">.vscode/</span><br><span class="line">.idea/</span><br><span class="line"></span><br><span class="line"># 系统文件</span><br><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br></pre></td></tr></table></figure><h2 id="🔧-故障排除"><a href="#🔧-故障排除" class="headerlink" title="🔧 故障排除"></a>🔧 故障排除</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">❗ 常见问题</button><button type="button" class="tab">✅ 安装验证</button><button type="button" class="tab">� 性能优化</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="note danger icon-padding flat"><i class="note-icon fas fa-bug"></i><p><strong>问题1</strong>: <code>python</code> 命令不识别<br><strong>解决方案</strong>: 检查环境变量Path配置，确保Python安装路径已添加</p></div><div class="note danger icon-padding flat"><i class="note-icon fas fa-bug"></i><p><strong>问题2</strong>: <code>pip</code> 命令不识别<br><strong>解决方案</strong>: 重新安装Python，确保勾选了”Install pip”选项</p></div><div class="note danger icon-padding flat"><i class="note-icon fas fa-bug"></i><p><strong>问题3</strong>: 虚拟环境激活失败<br><strong>解决方案</strong>: 检查路径分隔符，Windows使用反斜杠 <code>\</code>，Linux&#x2F;Mac使用正斜杠 <code>/</code></p></div><div class="note danger icon-padding flat"><i class="note-icon fas fa-bug"></i><p><strong>问题4</strong>: 包安装速度慢<br><strong>解决方案</strong>: 使用国内镜像源加速下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple package_name</span><br></pre></td></tr></table></figure></div></div><div class="tab-item-content"><p><strong>验证Python安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">python -V</span><br></pre></td></tr></table></figure><p><strong>验证pip安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip --version</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">pip -V</span><br></pre></td></tr></table></figure><p><strong>测试虚拟环境</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在虚拟环境中</span></span><br><span class="line">python -c <span class="string">&quot;import sys; print(sys.executable)&quot;</span></span><br></pre></td></tr></table></figure><div class="note success icon-padding flat"><i class="note-icon fas fa-check-circle"></i><p>正确配置后应显示虚拟环境中的Python路径</p></div></div><div class="tab-item-content"><p><strong>配置pip镜像源（永久）</strong></p><p>创建pip配置文件：</p><p><strong>Windows</strong>: <code>%APPDATA%\pip\pip.ini</code><br><strong>Linux&#x2F;Mac</strong>: <code>~/.pip/pip.conf</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">index-url</span> = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="attr">trusted-host</span> = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p><strong>常用国内镜像源</strong></p><ul><li>清华大学：<code>https://pypi.tuna.tsinghua.edu.cn/simple</code></li><li>阿里云：<code>https://mirrors.aliyun.com/pypi/simple</code></li><li>豆瓣：<code>https://pypi.douban.com/simple</code></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🎉-总结"><a href="#🎉-总结" class="headerlink" title="🎉 总结"></a>🎉 总结</h2><div class="note success icon-padding modern"><i class="note-icon fas fa-graduation-cap"></i><p><strong>恭喜！</strong> 你已经掌握了Python环境搭建的核心技能</p></div><h3 id="�💡-学习路径建议"><a href="#�💡-学习路径建议" class="headerlink" title="�💡 学习路径建议"></a>�💡 学习路径建议</h3><div class="note blue icon-padding flat"><i class="note-icon fas fa-route"></i><p><strong>初学者路径</strong>：基础语法 → 标准库 → 第三方库 → 实战项目</p></div><div class="note purple icon-padding flat"><i class="note-icon fas fa-rocket"></i><p><strong>进阶路径</strong>：Web开发 &#x2F; 数据分析 &#x2F; 机器学习 &#x2F; 自动化运维</p></div><hr><div class="note pink icon-padding modern"><i class="note-icon fas fa-heart"></i><p><strong>小贴士</strong>：虚拟环境是Python开发的最佳实践，熟练掌握后将大大提升开发效率！</p></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📡 TCP原始数据包抓取详解</title>
      <link href="/2025/06/11/%E6%8A%93%E5%8C%85/TCP%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE/"/>
      <url>/2025/06/11/%E6%8A%93%E5%8C%85/TCP%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="🚀-抓包流程"><a href="#🚀-抓包流程" class="headerlink" title="🚀 抓包流程"></a>🚀 抓包流程</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">环境检查</button><button type="button" class="tab">执行抓包</button><button type="button" class="tab">数据分析</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="🔍-网络接口查看"><a href="#🔍-网络接口查看" class="headerlink" title="🔍 网络接口查看"></a>🔍 网络接口查看</h3><div class="note blue icon-padding modern"><i class="note-icon fas fa-network-wired"></i><p><strong>查看可用的网络接口</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络接口信息</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用ip命令</span></span><br><span class="line">ip addr show</span><br></pre></td></tr></table></figure><div class="note info icon-padding modern"><i class="note-icon fas fa-info-circle"></i><p><strong>常见网络接口：</strong></p><ul><li><code>wlan0</code> - WiFi接口</li><li><code>rmnet0</code> - 移动数据接口  </li><li><code>eth0</code> - 以太网接口</li><li><code>lo</code> - 回环接口</li></ul></div></div><div class="tab-item-content"><h3 id="🎯-tcpdump命令详解"><a href="#🎯-tcpdump命令详解" class="headerlink" title="🎯 tcpdump命令详解"></a>🎯 tcpdump命令详解</h3><div class="note purple icon-padding modern"><i class="note-icon fas fa-terminal"></i><p><strong>核心抓包命令</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本抓包命令</span></span><br><span class="line">tcpdump -i &lt;interface_name&gt; -s 0 -w /sdcard/capture.pcap</span><br></pre></td></tr></table></figure><div class="note success icon-padding modern"><i class="note-icon fas fa-cogs"></i><p><strong>参数说明：</strong></p><ul><li><code>-i &lt;interface_name&gt;</code> - 指定网络接口（如wlan0）</li><li><code>-s 0</code> - 捕获完整数据包（不截断）</li><li><code>-w filename</code> - 将数据写入文件</li><li><code>/sdcard/capture.pcap</code> - 输出文件路径</li></ul></div><h3 id="📝-实际操作示例"><a href="#📝-实际操作示例" class="headerlink" title="📝 实际操作示例"></a>📝 实际操作示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例1：抓取WiFi接口的所有数据包</span></span><br><span class="line">tcpdump -i wlan0 -s 0 -w /sdcard/wifi_capture.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：抓取特定端口的数据包</span></span><br><span class="line">tcpdump -i wlan0 -s 0 port 80 -w /sdcard/http_capture.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3：抓取特定主机的数据包</span></span><br><span class="line">tcpdump -i wlan0 -s 0 host 192.168.1.1 -w /sdcard/host_capture.pcap</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h3 id="📤-文件传输"><a href="#📤-文件传输" class="headerlink" title="📤 文件传输"></a>📤 文件传输</h3><div class="note green icon-padding modern"><i class="note-icon fas fa-download"></i><p><strong>第三步：传输pcap文件到电脑</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用adb pull命令传输文件</span></span><br><span class="line">adb pull /sdcard/capture.pcap ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者指定具体路径</span></span><br><span class="line">adb pull /sdcard/capture.pcap C:\captures\</span><br></pre></td></tr></table></figure><h3 id="🔬-Wireshark分析"><a href="#🔬-Wireshark分析" class="headerlink" title="🔬 Wireshark分析"></a>🔬 Wireshark分析</h3><div class="note blue icon-padding modern"><i class="note-icon fas fa-search"></i><p><strong>第四步：使用Wireshark打开pcap文件进行分析</strong></p></div><div class="note info icon-padding modern"><i class="note-icon fas fa-lightbulb"></i><p><strong>Wireshark分析要点：</strong></p><ul><li>使用过滤器筛选特定协议：<code>tcp</code>, <code>http</code>, <code>dns</code></li><li>查看数据包详细信息和十六进制数据</li><li>分析网络流量模式和异常行为</li><li>导出特定会话或对象</li></ul></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🔧-高级技巧"><a href="#🔧-高级技巧" class="headerlink" title="🔧 高级技巧"></a>🔧 高级技巧</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">过滤选项</button><button type="button" class="tab">实时监控</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="🎛️-tcpdump过滤器"><a href="#🎛️-tcpdump过滤器" class="headerlink" title="🎛️ tcpdump过滤器"></a>🎛️ tcpdump过滤器</h3><div class="note primary icon-padding modern"><i class="note-icon fas fa-filter"></i><p><strong>常用过滤条件</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只抓取TCP协议</span></span><br><span class="line">tcpdump -i wlan0 tcp -w tcp_only.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取特定端口范围</span></span><br><span class="line">tcpdump -i wlan0 portrange 80-443 -w web_traffic.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取来自/到特定IP的数据包</span></span><br><span class="line">tcpdump -i wlan0 src 192.168.1.100 -w from_host.pcap</span><br><span class="line">tcpdump -i wlan0 dst 192.168.1.100 -w to_host.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合条件（HTTP和HTTPS流量）</span></span><br><span class="line">tcpdump -i wlan0 <span class="string">&#x27;port 80 or port 443&#x27;</span> -w web_all.pcap</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h3 id="📊-实时数据包监控"><a href="#📊-实时数据包监控" class="headerlink" title="📊 实时数据包监控"></a>📊 实时数据包监控</h3><div class="note orange icon-padding modern"><i class="note-icon fas fa-eye"></i><p><strong>实时查看数据包（不保存文件）</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时显示数据包摘要</span></span><br><span class="line">tcpdump -i wlan0 -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示详细的数据包内容</span></span><br><span class="line">tcpdump -i wlan0 -A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示十六进制和ASCII内容</span></span><br><span class="line">tcpdump -i wlan0 -X</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制显示的数据包数量</span></span><br><span class="line">tcpdump -i wlan0 -c 100</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🐛-常见问题排查"><a href="#🐛-常见问题排查" class="headerlink" title="🐛 常见问题排查"></a>🐛 常见问题排查</h2><h3 id="🔴-权限问题"><a href="#🔴-权限问题" class="headerlink" title="🔴 权限问题"></a>🔴 权限问题</h3><div class="note red icon-padding modern"><i class="note-icon fas fa-times-circle"></i><p><strong>问题：Permission denied</strong></p></div><div class="note green icon-padding modern"><i class="note-icon fas fa-lightbulb"></i><p><strong>解决方案：</strong></p><ol><li>确保设备已获得Root权限</li><li>使用<code>su</code>命令切换到超级用户</li><li>检查tcpdump工具是否正确安装</li></ol></div><h3 id="🟡-接口不存在"><a href="#🟡-接口不存在" class="headerlink" title="🟡 接口不存在"></a>🟡 接口不存在</h3><div class="note warning icon-padding modern"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>问题：指定的网络接口不存在</strong></p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-tools"></i><p><strong>解决方案：</strong><br>使用<code>ifconfig</code>或<code>ip addr</code>命令查看实际可用的网络接口名称</p></div><h2 id="🔗-相关工具"><a href="#🔗-相关工具" class="headerlink" title="🔗 相关工具"></a>🔗 相关工具</h2><div class="btn-center"><a class="btn-beautify blue larger" href="https://www.wireshark.org" title="Wireshark官网"><i class="fas fa-external-link-alt"></i><span>Wireshark官网</span></a><a class="btn-beautify green larger" href="https://www.tcpdump.org" title="tcpdump官网"><i class="fas fa-external-link-alt"></i><span>tcpdump官网</span></a></div>]]></content>
      
      
      <categories>
          
          <category> 抓包 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Fragment重建踩坑</title>
      <link href="/2025/06/11/Android/ui/fragment/Fragment%E9%87%8D%E5%BB%BA%E8%B8%A9%E5%9D%91/"/>
      <url>/2025/06/11/Android/ui/fragment/Fragment%E9%87%8D%E5%BB%BA%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当使用Navigationd进行Fragment的导航时，返回到上一个fragmentA会导致fragmentA的界面重新创建此时数据要自己去回复，大部分的view&#x2F;viewgroup的state默认已经做好恢复处理，例如coordinator，只需要指定id才能解决恢复问题，还有recyclerview。但是如果遇到了动态addView要如何解决？我这里动态addView的视图是一个ViewPager，要实现重建时动态添加的View能够正确的恢复，必须在重建前onViewCreate去AddView，并且viewpager的adapter需要继承FragmentStateAdapter</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 踩坑 </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android GridLayoutManager踩坑</title>
      <link href="/2025/06/11/Android/ui/recyclerview/GridLayoutManager%E8%B8%A9%E5%9D%91/"/>
      <url>/2025/06/11/Android/ui/recyclerview/GridLayoutManager%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SpanSizeLookUp 可以设置item占满的大小，和spancount意思不同！如SpanCount &#x3D; 4, ItemA span size &#x3D; 4  代表1个Item占满大小1行 即 4&#x2F;4 ， ItemB span size &#x3D; 1 代表一个1个Item占一行的 四分之一, 将会均分4份！之前因为这里排查了不少时间</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 踩坑 </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>① 利用Blutter反编译Flutter Apk的Dart文件</title>
      <link href="/2025/06/11/%E9%80%86%E5%90%91/Flutter%E9%80%86%E5%90%91%E6%B5%81%E7%A8%8B/"/>
      <url>/2025/06/11/%E9%80%86%E5%90%91/Flutter%E9%80%86%E5%90%91%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="📖-概述"><a href="#📖-概述" class="headerlink" title="📖 概述"></a>📖 概述</h2><div class="note info modern"><p><strong>Flutter逆向分析是移动安全研究的重要组成部分</strong></p><ul><li>本文将详细介绍使用blutter工具对Flutter应用进行逆向分析的完整流程</li><li>包含环境配置、工具使用和常见问题解决方案</li></ul></div><h2 id="🛠️-工具介绍"><a href="#🛠️-工具介绍" class="headerlink" title="🛠️ 工具介绍"></a>🛠️ 工具介绍</h2><div class="note blue icon-padding modern"><i class="note-icon fab fa-github"></i><p><strong>推荐工具：blutter</strong></p><ul><li>项目地址：<a href="https://github.com/crowforkotlin/blutter">blutter - GitHub</a></li><li>专门用于Flutter应用的逆向分析工具</li><li>支持将Flutter so文件反编译为Dart源码</li></ul></div><h2 id="🚀-完整流程"><a href="#🚀-完整流程" class="headerlink" title="🚀 完整流程"></a>🚀 完整流程</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">环境准备</button><button type="button" class="tab">依赖安装</button><button type="button" class="tab">执行逆向</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="📋-系统要求"><a href="#📋-系统要求" class="headerlink" title="📋 系统要求"></a>📋 系统要求</h3><div class="note warning icon-padding modern"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>重要提示：</strong></p><ul><li>blutter工具对GCC版本有严格要求，需要GCC 13版本以上</li><li>推荐使用WSL Ubuntu-24.04环境进行操作</li></ul></div><h3 id="🔧-WSL环境配置"><a href="#🔧-WSL环境配置" class="headerlink" title="🔧 WSL环境配置"></a>🔧 WSL环境配置</h3><div class="note success icon-padding modern"><i class="note-icon fas fa-terminal"></i><p><strong>第一步：安装WSL Ubuntu-24.04</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可用的Linux发行版</span></span><br><span class="line">wsl -list -online</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Ubuntu-24.04</span></span><br><span class="line">wsl --install Ubuntu-24.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动指定发行版</span></span><br><span class="line">wsl --distribution Ubuntu-24.04</span><br></pre></td></tr></table></figure><div class="note success icon-padding modern"><i class="note-icon fas fa-user-cog"></i><p><strong>第二步：配置用户权限</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置root密码</span></span><br><span class="line">sudo passwd root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到root用户</span></span><br><span class="line">su</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h3 id="📦-安装编译工具链"><a href="#📦-安装编译工具链" class="headerlink" title="📦 安装编译工具链"></a>📦 安装编译工具链</h3><div class="note primary icon-padding modern"><i class="note-icon fas fa-download"></i><p><strong>更新系统包管理器</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新包列表</span></span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><div class="note primary icon-padding modern"><i class="note-icon fas fa-code"></i><p><strong>安装GCC 13工具链</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装GCC 13和G++ 13</span></span><br><span class="line">sudo apt install gcc-13 g++-13</span><br></pre></td></tr></table></figure><div class="note info icon-padding modern"><i class="note-icon fas fa-cogs"></i><p><strong>可选：设置GCC默认版本</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置GCC默认版本</span></span><br><span class="line">sudo update-alternatives --config gcc</span><br><span class="line">sudo update-alternatives --config g++</span><br></pre></td></tr></table></figure><h3 id="🔗-安装项目依赖"><a href="#🔗-安装项目依赖" class="headerlink" title="🔗 安装项目依赖"></a>🔗 安装项目依赖</h3><div class="note success icon-padding modern"><i class="note-icon fas fa-puzzle-piece"></i><p><strong>安装所有必需的依赖包</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装blutter所需的全部依赖</span></span><br><span class="line">apt install python3-pyelftools python3-requests git cmake ninja-build \</span><br><span class="line">build-essential pkg-config libicu-dev libcapstone-dev</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h3 id="🎯-运行blutter工具"><a href="#🎯-运行blutter工具" class="headerlink" title="🎯 运行blutter工具"></a>🎯 运行blutter工具</h3><div class="note purple icon-padding modern"><i class="note-icon fas fa-play"></i><p><strong>执行反编译命令</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用blutter对arm64-v8a so文件进行反编译</span></span><br><span class="line">python3 blutter.py arm64-v8a/ out_dir</span><br></pre></td></tr></table></figure><div class="note info icon-padding modern"><i class="note-icon fas fa-info-circle"></i><p><strong>参数说明：</strong></p><ul><li><code>arm64-v8a/</code> - 输入目录，包含Flutter的so文件</li><li><code>out_dir</code> - 输出目录，将生成反编译后的Dart文件</li></ul></div><h3 id="📁-输出结果"><a href="#📁-输出结果" class="headerlink" title="📁 输出结果"></a>📁 输出结果</h3><div class="note success icon-padding modern"><i class="note-icon fas fa-check-circle"></i><p><strong>成功标志：</strong><br>如果配置正确，将会在<code>out_dir</code>目录中生成反编译出来的Dart源码文件</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="⚠️-常见问题与解决方案"><a href="#⚠️-常见问题与解决方案" class="headerlink" title="⚠️ 常见问题与解决方案"></a>⚠️ 常见问题与解决方案</h2><div class="note danger icon-padding modern"><i class="note-icon fas fa-bug"></i><p><strong>已知问题：blutter在某些环境下存在兼容性问题</strong></p></div><h3 id="🔴-问题1：Debian环境编译错误"><a href="#🔴-问题1：Debian环境编译错误" class="headerlink" title="🔴 问题1：Debian环境编译错误"></a>🔴 问题1：Debian环境编译错误</h3><div class="note red icon-padding modern"><i class="note-icon fas fa-times-circle"></i><p><strong>问题描述：</strong><br>在WSL Debian环境下，安装了GCC 13，使用blutter对arm64-v8a so进行反编译时仍然产生大量错误</p></div><div class="note green icon-padding modern"><i class="note-icon fas fa-lightbulb"></i><p><strong>解决方案：</strong><br>建议使用WSL Ubuntu-24.04替代Debian，Ubuntu-24.04对blutter的兼容性更好</p></div><h3 id="🟡-问题2：GCC版本不兼容"><a href="#🟡-问题2：GCC版本不兼容" class="headerlink" title="🟡 问题2：GCC版本不兼容"></a>🟡 问题2：GCC版本不兼容</h3><div class="note warning icon-padding modern"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>问题描述：</strong><br>系统默认GCC版本低于13，导致编译失败</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-tools"></i><p><strong>解决方案：</strong><br>按照上述流程安装GCC 13，并配置为默认版本</p></div><h2 id="🔗-相关资源"><a href="#🔗-相关资源" class="headerlink" title="🔗 相关资源"></a>🔗 相关资源</h2><div class="btn-center"><a class="btn-beautify blue larger" href="https://github.com/crowforkotlin/blutter" title="blutter工具"><i class="fab fa-github"></i><span>blutter工具</span></a><a class="btn-beautify green larger" href="https://flutter.dev" title="Flutter官网"><i class="fas fa-external-link-alt"></i><span>Flutter官网</span></a></div>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modbus通信协议实战指南</title>
      <link href="/2023/10/07/%E5%8D%8F%E8%AE%AE/Modbus/"/>
      <url>/2023/10/07/%E5%8D%8F%E8%AE%AE/Modbus/</url>
      
        <content type="html"><![CDATA[<div class="note modern"><p>🎯 <strong>学习目标</strong>：全面掌握Modbus协议的原理、应用和实战技巧，成为工业通信领域的专家</p></div><h2 id="🚀-协议概述"><a href="#🚀-协议概述" class="headerlink" title="🚀 协议概述"></a>🚀 协议概述</h2><p><strong>Modbus</strong> 是工业自动化领域使用最广泛的通信协议之一，具有简单、可靠、开放的特点。</p><div class="note info icon-padding flat"><i class="note-icon fas fa-network-wired"></i><p><strong>协议特点</strong>：开放性强、实现简单、设备兼容性好、在工业控制系统中应用广泛</p></div><h3 id="🏗️-架构模式"><a href="#🏗️-架构模式" class="headerlink" title="🏗️ 架构模式"></a>🏗️ 架构模式</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">👥 主从架构</button><button type="button" class="tab">🌐 网络拓扑</button><button type="button" class="tab">📊 数据模型</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>基本概念：</strong></p><ul><li>🖥️ <strong>主站（Master）</strong>：相当于客户端，主动发起通信请求</li><li>🔧 <strong>从站（Slave）</strong>：相当于服务端，被动响应主站请求</li><li>📡 <strong>通信特点</strong>：半双工通信，主站轮询从站</li></ul><div class="note blue icon-padding flat"><i class="note-icon fas fa-exchange-alt"></i><p><strong>通信流程</strong>：主站发送请求 → 从站处理并响应 → 主站接收数据</p></div></div><div class="tab-item-content"><p><strong>支持的网络类型：</strong></p><ul><li>🔌 <strong>Modbus RTU</strong>：基于RS-485串行通信</li><li>🌍 <strong>Modbus TCP</strong>：基于以太网TCP&#x2F;IP</li><li>⚡ <strong>Modbus ASCII</strong>：ASCII编码的串行通信</li></ul><div class="note green icon-padding flat"><i class="note-icon fas fa-sitemap"></i><p><strong>网络特点</strong>：支持1个主站和最多247个从站设备</p></div></div><div class="tab-item-content"><p><strong>四种数据类型：</strong></p><ul><li>🔘 <strong>线圈（Coils）</strong>：单比特可读写数据</li><li>📥 <strong>离散输入（Discrete Inputs）</strong>：单比特只读数据  </li><li>📋 <strong>保持寄存器（Holding Registers）</strong>：16位可读写数据</li><li>📤 <strong>输入寄存器（Input Registers）</strong>：16位只读数据</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="📚-基础概念理解"><a href="#📚-基础概念理解" class="headerlink" title="📚 基础概念理解"></a>📚 基础概念理解</h2><h3 id="关键术语"><a href="#关键术语" class="headerlink" title="关键术语"></a>关键术语</h3><p><strong>● 1字节（位） &#x3D; 1byte（一个字节） &#x3D; 8bit</strong></p><ul><li>1个字节可以表示0-255的数值</li><li>在Modbus中，地址、功能码等都以字节为单位</li></ul><p><strong>● 串行链路</strong>：数据一位一位按顺序传输的方式</p><ul><li>在广域网中提供远距离传输</li><li>分为”异步”和”同步”传输方式</li><li>以字节为单位进行数据传输</li></ul><blockquote><p>广域网（WAN）：连接不同地区局域网的远程网络，覆盖范围从几十公里到几千公里</p></blockquote><p><strong>● PDU（协议数据单元）</strong>：网络通信中传输的数据单位</p><ul><li>包含控制信息和用户数据</li><li>在不同网络层级有不同名称：包（Packet）、段（Segment）、帧（Frame）</li><li>Modbus中定义了与通信层无关的简单协议数据单元</li></ul><p><strong>● ASCII</strong>：美国信息交换标准代码，与UTF-8都是字符编码方式</p><h3 id="🔧-Modbus操作对象（通用数据类型）"><a href="#🔧-Modbus操作对象（通用数据类型）" class="headerlink" title="🔧 Modbus操作对象（通用数据类型）"></a>🔧 Modbus操作对象（通用数据类型）</h3><table><thead><tr><th>对象类型</th><th>地址范围</th><th>数据位数</th><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><strong>线圈</strong></td><td>00001-09999</td><td>1位</td><td>读写</td><td>PLC输出位，开关量</td></tr><tr><td><strong>离散输入</strong></td><td>10001-19999</td><td>1位</td><td>只读</td><td>PLC输入位，开关量</td></tr><tr><td><strong>输入寄存器</strong></td><td>30001-39999</td><td>16位</td><td>只读</td><td>模拟量输入</td></tr><tr><td><strong>保持寄存器</strong></td><td>40001-49999</td><td>16位</td><td>读写</td><td>模拟量输出</td></tr></tbody></table><p><strong>通用数据结构说明</strong>：</p><ul><li><strong>1位数据</strong>：线圈和离散输入，存储开关状态（0&#x2F;1）</li><li><strong>16位数据</strong>：寄存器类型，存储数值（0-65535）</li><li><strong>地址编码</strong>：前缀数字区分不同类型，实际传输时使用相对地址</li></ul><h2 id="🔢-功能码详解"><a href="#🔢-功能码详解" class="headerlink" title="🔢 功能码详解"></a>🔢 功能码详解</h2><table><thead><tr><th>功能码</th><th>名称</th><th>操作对象</th><th>描述</th></tr></thead><tbody><tr><td><strong>01</strong></td><td>读线圈状态</td><td>00001-09999</td><td>读取离散输出状态</td></tr><tr><td><strong>02</strong></td><td>读离散输入</td><td>10001-19999</td><td>读取离散输入状态</td></tr><tr><td><strong>03</strong></td><td>读保持寄存器</td><td>40001-49999</td><td>读取模拟输出值</td></tr><tr><td><strong>04</strong></td><td>读输入寄存器</td><td>30001-39999</td><td>读取模拟输入值</td></tr><tr><td><strong>05</strong></td><td>写单个线圈</td><td>00001-09999</td><td>写入单个线圈</td></tr><tr><td><strong>06</strong></td><td>写单个寄存器</td><td>40001-49999</td><td>写入单个寄存器</td></tr><tr><td><strong>0F(15)</strong></td><td>写多个线圈</td><td>00001-09999</td><td>写入多个线圈</td></tr><tr><td><strong>10(16)</strong></td><td>写多个寄存器</td><td>40001-49999</td><td>写入多个寄存器</td></tr></tbody></table><h2 id="📦-数据帧格式"><a href="#📦-数据帧格式" class="headerlink" title="📦 数据帧格式"></a>📦 数据帧格式</h2><h3 id="通用PDU结构"><a href="#通用PDU结构" class="headerlink" title="通用PDU结构"></a>通用PDU结构</h3><table><thead><tr><th align="center">功能码</th><th align="center">数据</th></tr></thead><tbody><tr><td align="center">1字节</td><td align="center">不定长</td></tr></tbody></table><h3 id="MBAP报文头（TCP专用）"><a href="#MBAP报文头（TCP专用）" class="headerlink" title="MBAP报文头（TCP专用）"></a>MBAP报文头（TCP专用）</h3><table><thead><tr><th align="center">事务处理标识</th><th align="center">协议标识</th><th align="center">长度</th><th align="center">单元标识符</th></tr></thead><tbody><tr><td align="center">2字节</td><td align="center">2字节</td><td align="center">2字节</td><td align="center">1字节</td></tr></tbody></table><p><strong>字节含义说明</strong>：</p><ul><li><strong>事务处理标识</strong>：报文序列号，每次通信后加1</li><li><strong>协议标识符</strong>：00 00表示Modbus TCP协议  </li><li><strong>长度</strong>：后续数据长度（字节数）</li><li><strong>单元标识符</strong>：设备地址</li></ul><h3 id="1-Modbus-RTU帧模式"><a href="#1-Modbus-RTU帧模式" class="headerlink" title="1. Modbus RTU帧模式"></a>1. Modbus RTU帧模式</h3><table><thead><tr><th align="center">设备地址</th><th align="center">功能代码</th><th align="center">数据格式</th><th align="center">CRC16校验</th></tr></thead><tbody><tr><td align="center">1字节</td><td align="center">1字节</td><td align="center">N字节</td><td align="center">2字节</td></tr></tbody></table><p><strong>读&#x2F;写单个操作</strong>：</p><table><thead><tr><th align="center">设备地址</th><th align="center">功能代码</th><th align="center">起始地址（高位）</th><th align="center">起始地址（低位）</th><th align="center">数量（高位）</th><th align="center">数量（低位）</th><th align="center">CRC16校验</th></tr></thead><tbody><tr><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">2字节</td></tr></tbody></table><p><strong>读&#x2F;写多个操作</strong>：</p><table><thead><tr><th align="center">设备地址</th><th align="center">功能代码</th><th align="center">起始地址（高位）</th><th align="center">起始地址（低位）</th><th align="center">数量（高位）</th><th align="center">数量（低位）</th><th align="center">字节数</th><th align="center">数据</th><th align="center">CRC16校验</th></tr></thead><tbody><tr><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">N字节</td><td align="center">2字节</td></tr></tbody></table><h3 id="2-Modbus-ASCII帧模式"><a href="#2-Modbus-ASCII帧模式" class="headerlink" title="2. Modbus ASCII帧模式"></a>2. Modbus ASCII帧模式</h3><table><thead><tr><th align="center">帧头</th><th align="center">设备地址</th><th align="center">功能码</th><th align="center">数据</th><th align="center">校验码LRC</th><th align="center">回车</th><th align="center">换行</th></tr></thead><tbody><tr><td align="center">1字符</td><td align="center">2字符</td><td align="center">2字符</td><td align="center">N字符</td><td align="center">2字符</td><td align="center">1字符</td><td align="center">1字符</td></tr><tr><td align="center"><code>:</code></td><td align="center">01</td><td align="center">03</td><td align="center">00 00 00 01</td><td align="center">FB</td><td align="center"><code>\r</code></td><td align="center"><code>\n</code></td></tr></tbody></table><h3 id="3-Modbus-TCP帧模式"><a href="#3-Modbus-TCP帧模式" class="headerlink" title="3. Modbus TCP帧模式"></a>3. Modbus TCP帧模式</h3><table><thead><tr><th align="center">MBAP报文头</th><th align="center">功能码</th><th align="center">数据</th></tr></thead><tbody><tr><td align="center">7字节</td><td align="center">1字节</td><td align="center">N字节</td></tr></tbody></table><h2 id="🔧-通用数据封装思路"><a href="#🔧-通用数据封装思路" class="headerlink" title="🔧 通用数据封装思路"></a>🔧 通用数据封装思路</h2><p><strong>三种帧格式的共同点</strong>：</p><ol><li><strong>核心数据</strong>：设备地址、功能码、起始地址、数量&#x2F;数值</li><li><strong>数据部分</strong>：根据功能码决定是否包含字节数和具体数值</li><li><strong>校验方式</strong>：RTU用CRC16，ASCII用LRC，TCP无需校验</li></ol><p><strong>封装策略</strong>：</p><ul><li>先构建通用的PDU部分（功能码+数据）</li><li>根据传输模式添加不同的头部和校验</li><li>字节序按照大端模式（高位在前）</li></ul><h2 id="💻-代码实现"><a href="#💻-代码实现" class="headerlink" title="💻 代码实现"></a>💻 代码实现</h2><h3 id="RTU模式构建"><a href="#RTU模式构建" class="headerlink" title="RTU模式构建"></a>RTU模式构建</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RTU</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">( function: <span class="type">ModbusFunction</span>, slave: <span class="type">Int</span>, startAddress: <span class="type">Int</span>, count: <span class="type">Int</span>, value: <span class="type">Int</span>? = <span class="literal">null</span>, values: <span class="type">IntArray</span>? = <span class="literal">null</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> output = buildOutput(slave, function, startAddress, count, value, values)</span><br><span class="line">    toCalculateCRC16(output.toByteArray(), output)</span><br><span class="line">    <span class="keyword">return</span> output.toByteArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCP模式构建"><a href="#TCP模式构建" class="headerlink" title="TCP模式构建"></a>TCP模式构建</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> mTransactionId: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mProtocol: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">(function: <span class="type">ModbusFunction</span>, slave: <span class="type">Int</span>, startAddress: <span class="type">Int</span>, count: <span class="type">Int</span>,value: <span class="type">Int</span>? = <span class="literal">null</span>, values: <span class="type">IntArray</span>? = <span class="literal">null</span>, transactionId: <span class="type">Int</span> = mTransactionId)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> pdu = buildOutput(slave, function, startAddress, count, value, values, isTcp = <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">val</span> size = pdu.size()</span><br><span class="line">    <span class="keyword">val</span> mbap = BytesOutput()</span><br><span class="line">    mbap.writeInt16(transactionId)</span><br><span class="line">    mbap.writeInt16(mProtocol)</span><br><span class="line">    mbap.writeInt16(size + <span class="number">1</span>)</span><br><span class="line">    mbap.writeInt8(slave)</span><br><span class="line">    mbap.write(pdu.toByteArray())</span><br><span class="line">    mTransactionId++</span><br><span class="line">    <span class="keyword">return</span> mbap.toByteArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ASCII模式构建"><a href="#ASCII模式构建" class="headerlink" title="ASCII模式构建"></a>ASCII模式构建</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ASCII</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> HEAD = <span class="number">0x3A</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> END = byteArrayOf(<span class="number">0x0d</span>, <span class="number">0x0A</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">( function: <span class="type">ModbusFunction</span>, slave: <span class="type">Int</span>, startAddress: <span class="type">Int</span>, count: <span class="type">Int</span>, value: <span class="type">Int</span>? = <span class="literal">null</span>, values: <span class="type">IntArray</span>? = <span class="literal">null</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> bytes = BytesOutput()</span><br><span class="line">    <span class="keyword">val</span> output = buildOutput(slave, function, startAddress, count, value, values).toByteArray()</span><br><span class="line">    <span class="keyword">val</span> pLRC = fromAsciiInt8(toCalculateLRC(output))</span><br><span class="line">    <span class="keyword">val</span> outputAscii = toAsciiHexBytes(output)</span><br><span class="line">    bytes.writeInt8(HEAD)</span><br><span class="line">    bytes.writeBytes(outputAscii, outputAscii.size)</span><br><span class="line">    bytes.writeInt8(pLRC.first)</span><br><span class="line">    bytes.writeInt8(pLRC.second)</span><br><span class="line">    bytes.writeBytes(END, END.size)</span><br><span class="line">    <span class="keyword">return</span> bytes.toByteArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心构建函数"><a href="#核心构建函数" class="headerlink" title="核心构建函数"></a>核心构建函数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心实现</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">KModbus</span> <span class="keyword">protected</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ● 构造输出的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ● 2023-10-16 16:42:18 周一 下午</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> crowforkotlin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">buildOutput</span><span class="params">(slave: <span class="type">Int</span>, function: <span class="type">ModbusFunction</span>, startAddress: <span class="type">Int</span>, count: <span class="type">Int</span>, value: <span class="type">Int</span>?, values: <span class="type">IntArray</span>?, isTcp: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>: BytesOutput &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查参数是否符合协议规定</span></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            slave !<span class="keyword">in</span> <span class="number">0.</span>.<span class="number">0xFF</span> -&gt; <span class="keyword">throw</span> ModbusException(ModbusErrorType.ModbusInvalidArgumentError, <span class="string">&quot;Invalid slave <span class="variable">$slave</span>&quot;</span>)</span><br><span class="line">            startAddress !<span class="keyword">in</span> <span class="number">0.</span>.<span class="number">0xFFFF</span> -&gt; <span class="keyword">throw</span> ModbusException(ModbusErrorType.ModbusInvalidArgumentError, <span class="string">&quot;Invalid startAddress <span class="variable">$startAddress</span>&quot;</span>)</span><br><span class="line">            count !<span class="keyword">in</span> <span class="number">1.</span>.<span class="number">0xFF</span> -&gt; <span class="keyword">throw</span> ModbusException(ModbusErrorType.ModbusInvalidArgumentError, <span class="string">&quot;Invalid count <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> output = BytesOutput()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isTcp) &#123;</span><br><span class="line">            output.writeInt8(slave)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">when</span>(function) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读线圈寄存器 、离散输入寄存器、保持寄存器、输入寄存器</span></span><br><span class="line">            ModbusFunction.READ_COILS, ModbusFunction.READ_DISCRETE_INPUTS, ModbusFunction.READ_INPUT_REGISTERS, ModbusFunction.READ_HOLDING_REGISTERS -&gt; &#123;</span><br><span class="line">                output.writeInt8(function.mCode)</span><br><span class="line">                output.writeInt16(startAddress)</span><br><span class="line">                output.writeInt16(count)</span><br><span class="line">            &#125;</span><br><span class="line">            ModbusFunction.WRITE_SINGLE_COIL, ModbusFunction.WRITE_SINGLE_REGISTER -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> valueCopy = value ?: <span class="keyword">throw</span> ModbusException(ModbusErrorType.ModbusInvalidArgumentError, <span class="string">&quot;Function Is <span class="variable">$function</span>\t , Data must be passed in!&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//写单个寄存器指令</span></span><br><span class="line">                <span class="keyword">if</span> (function == ModbusFunction.WRITE_SINGLE_COIL) <span class="keyword">if</span> (value != <span class="number">0</span>) valueCopy = <span class="number">0xff00</span> <span class="comment">//如果为线圈寄存器（写1时为 FF 00,写0时为00 00）</span></span><br><span class="line"></span><br><span class="line">                output.writeInt8(function.mCode)</span><br><span class="line">                output.writeInt16(startAddress)</span><br><span class="line">                output.writeInt16(valueCopy)</span><br><span class="line">            &#125;</span><br><span class="line">            ModbusFunction.WRITE_HOLDING_REGISTERS -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//写多个保持寄存器</span></span><br><span class="line">                output.writeInt8(function.mCode)</span><br><span class="line">                output.writeInt16(startAddress)</span><br><span class="line">                output.writeInt16(count)</span><br><span class="line">                output.writeInt8(<span class="number">2</span> * count)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//写入数据</span></span><br><span class="line">                (values ?: <span class="keyword">throw</span> ModbusException(ModbusErrorType.ModbusInvalidArgumentError, <span class="string">&quot;Function Is <span class="variable">$function</span>, Data must be passed in!&quot;</span>)).forEach &#123; output.writeInt16(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ModbusFunction.WRITE_COILS -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (values == <span class="literal">null</span> || values.isEmpty()) <span class="keyword">throw</span> ModbusException(ModbusErrorType.ModbusInvalidArgumentError, <span class="string">&quot;Function Is <span class="variable">$function</span>, Data must be passed in and cannot be empty!&quot;</span>)</span><br><span class="line">                output.writeInt8(function.mCode)</span><br><span class="line">                output.writeInt16(startAddress)</span><br><span class="line">                output.writeInt16(count)</span><br><span class="line">                output.writeInt8((count + <span class="number">7</span>) shr <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">val</span> chunkedValues = values.toList().chunked(<span class="number">8</span>)</span><br><span class="line">                <span class="keyword">for</span> (chunk <span class="keyword">in</span> chunkedValues) &#123;</span><br><span class="line">                    output.writeInt8(toDecimal(chunk.reversed().toIntArray()))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ● CRC校验</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ● 2023-10-16 16:06:48 周一 下午</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> crowforkotlin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toCalculateCRC16</span><span class="params">(output: <span class="type">BytesOutput</span>)</span></span>: BytesOutput &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算CRC校验码</span></span><br><span class="line">        output.writeInt16Reversal(CRC16.compute(output.toByteArray()))</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ● LRC校验</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ● 2023-10-16 16:06:41 周一 下午</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> crowforkotlin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toCalculateLRC</span><span class="params">(<span class="keyword">data</span>: <span class="type">ByteArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> iTmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="keyword">data</span>) &#123;</span><br><span class="line">            iTmp += x.toInt()</span><br><span class="line">        &#125;</span><br><span class="line">        iTmp %= <span class="number">256</span></span><br><span class="line">        iTmp = (iTmp.inv() + <span class="number">1</span>) and <span class="number">0xFF</span> <span class="comment">// 对补码取模，确保结果在0-255范围内</span></span><br><span class="line">        <span class="keyword">return</span> iTmp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ● Convert each digit component to decimal</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ● 2023-10-16 16:00:53 周一 下午</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> crowforkotlin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">toDecimal</span><span class="params">(<span class="keyword">data</span>: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (bit <span class="keyword">in</span> <span class="keyword">data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bit != <span class="number">0</span> &amp;&amp; bit != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment">// 数据数组中包含非二进制值，返回错误</span></span><br><span class="line">            &#125;</span><br><span class="line">            result = (result shl <span class="number">1</span>) + bit</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="📖-开源项目及参考资料"><a href="#📖-开源项目及参考资料" class="headerlink" title="📖 开源项目及参考资料"></a>📖 开源项目及参考资料</h2><ul><li>🔗 <a href="https://github.com/crowforkotlin/KModbus">KModbus - Kotlin实现</a></li><li>🔗 <a href="https://github.com/stephane/libmodbus">LibModbus - C实现</a></li><li>📚 <a href="https://zhuanlan.zhihu.com/p/484463923">知乎 - Modbus详解</a></li><li>📚 <a href="https://blog.csdn.net/tiandiren111/article/details/118347661">CSDN - Modbus教程</a></li></ul><hr><blockquote><p>💡 <strong>总结</strong>: 本文介绍了Modbus协议的基本概念、数据帧格式和Kotlin实现方法，适合工业自动化入门学习。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> Modbus </tag>
            
            <tag> 工业通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>② 通过JNI打开Android串口</title>
      <link href="/2023/09/27/Android/02JNI%E6%89%93%E5%BC%80%E5%AE%89%E5%8D%93%E4%B8%B2%E5%8F%A3/"/>
      <url>/2023/09/27/Android/02JNI%E6%89%93%E5%BC%80%E5%AE%89%E5%8D%93%E4%B8%B2%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="📖-说明"><a href="#📖-说明" class="headerlink" title="📖 说明"></a>📖 说明</h2><div class="note info modern"><p><strong>本篇文章将详细介绍如何通过JNI在Android中实现串口通信</strong></p><ul><li>在上一篇文章中我们配置了JNI的基础环境和相关上层、C层函数声明</li><li>接下来将编写相关代码来打开串口并进行通信</li></ul></div><h3 id="🔍-Android串口通信原理"><a href="#🔍-Android串口通信原理" class="headerlink" title="🔍 Android串口通信原理"></a>🔍 Android串口通信原理</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">基本原理</button><button type="button" class="tab">代码参考</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="note primary modern"><p><strong>Android串口通信的核心原理：</strong></p><ol><li><strong>Root权限要求</strong>：设备需要root权限才能访问串口文件</li><li><strong>文件句柄操作</strong>：通过文件句柄来管理串口的相关信息（位置、权限、IO信息等）</li><li><strong>串口配置</strong>：获取文件句柄后可以对串口进行配置、交互等操作</li></ol></div><div class="note warning modern"><p><strong>重要提示</strong>：文件句柄是用于管理文件相关信息的抽象概念，包括文件位置、权限、IO信息等</p></div></div><div class="tab-item-content"><div class="note blue icon-padding modern"><i class="note-icon fab fa-github"></i><p><strong>代码核心部分都添加了详细注释，完整源码请查看：</strong><br><a href="https://github.com/crowforkotlin/KModbus">KModbus - GitHub</a></p></div><div class="note green icon-padding modern"><i class="note-icon fas fa-code"></i><p><strong>参考资料：</strong><br><a href="https://github.com/stephane/libmodbus/blob/b25629bfb508bdce7d519884c0fa9810b7d98d44/src/modbus-rtu.c#L661">LibModbus 源码参考</a></p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🔧-串口查看与准备"><a href="#🔧-串口查看与准备" class="headerlink" title="🔧 串口查看与准备"></a>🔧 串口查看与准备</h2><div class="note warning icon-padding modern"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>前置要求：</strong></p><ul><li>确保设备已Root</li><li>准备ADB工具并配置环境变量</li></ul></div><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><div class="note success icon-padding modern"><i class="note-icon fas fa-terminal"></i><p><strong>串口检查命令：</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接设备shell</span></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取管理员权限</span></span><br><span class="line">su</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示串口列表</span></span><br><span class="line"><span class="built_in">ls</span> /dev | grep ttyS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个串口是否占用（以ttyS0为例）</span></span><br><span class="line">lsof /dev/ttyS0</span><br></pre></td></tr></table></figure><h2 id="💻-代码实现"><a href="#💻-代码实现" class="headerlink" title="💻 代码实现"></a>💻 代码实现</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">JNI实现</button><button type="button" class="tab">Kotlin实现</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="🔌-打开串口"><a href="#🔌-打开串口" class="headerlink" title="🔌 打开串口"></a>🔌 打开串口</h3><div class="note blue icon-padding modern"><i class="note-icon fas fa-code"></i><p><strong>核心函数：<code>Java_com_crow_modbus_serialport_SerialPort_open</code></strong></p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     android_serialport_SerialPort</span></span><br><span class="line"><span class="comment"> * Method:    open</span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * Opens a serial port and configures its parameters such as baud rate, data bits, stop bits, and parity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parameters:</span></span><br><span class="line"><span class="comment"> *   path     - The path to the serial port device (e.g., &quot;/dev/ttyS0&quot;).</span></span><br><span class="line"><span class="comment"> *   baudrate - The desired baud rate (e.g., 9600).</span></span><br><span class="line"><span class="comment"> *   flags    - Flags for opening the serial port (e.g., O_RDWR).</span></span><br><span class="line"><span class="comment"> *   parity   - Parity mode (0 for none, 1 for even, 2 for odd).</span></span><br><span class="line"><span class="comment"> *   stop_bit - Stop bit mode (1 or 2).</span></span><br><span class="line"><span class="comment"> *   data_bit - Data bits (5, 6, 7, or 8).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *   A FileDescriptor object representing the opened serial port, or NULL if an error occurs.</span></span><br><span class="line"><span class="comment"> * @author : revise by crowforkotlin </span></span><br><span class="line"><span class="comment"> * @link : https://github.com/stephane/libmodbus/blob/b25629bfb508bdce7d519884c0fa9810b7d98d44/src/modbus-rtu.c#L661</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jobject JNICALL <span class="title function_">Java_com_crow_modbus_serialport_SerialPort_open</span></span><br><span class="line"><span class="params">(JNIEnv *env, jclass thiz, jstring path, jint baudrate, jint flags, jint parity, jint stop_bit, jint data_bit)</span> &#123;</span><br><span class="line">    LOGD(<span class="string">&quot;----------------------------------------------------------&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">speed_t</span> speed;</span><br><span class="line">    jobject mFileDescriptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验波特率是否正确</span></span><br><span class="line">    &#123;</span><br><span class="line">        speed = getBaudrate(baudrate);</span><br><span class="line">        <span class="keyword">if</span> (speed == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">&quot;Invalid baudrate！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启串口 O_RDWR 开启读写权限</span></span><br><span class="line">    &#123;</span><br><span class="line">        jboolean iscopy;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *path_utf = (*env)-&gt;GetStringUTFChars(env, path, &amp;iscopy);</span><br><span class="line">        LOGD(<span class="string">&quot;Opening serial port %s with flags 0x%x&quot;</span>, path_utf, O_RDWR | flags);</span><br><span class="line">        fd = open(path_utf, O_RDWR | flags);</span><br><span class="line">        LOGD(<span class="string">&quot;open() fd = %d&quot;</span>, fd);</span><br><span class="line">        (*env)-&gt;ReleaseStringUTFChars(env, path, path_utf);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">&quot;Cannot open port&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置串口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">cfg</span>;</span></span><br><span class="line">        LOGD(<span class="string">&quot;Configuring serial port&quot;</span>);</span><br><span class="line">        <span class="comment">// 尝试获取文件描述符fd标识并存储到cfg结构体中</span></span><br><span class="line">        <span class="keyword">if</span> (tcgetattr(fd, &amp;cfg)) &#123;</span><br><span class="line">            LOGE(<span class="string">&quot;tcgetattr() failed&quot;</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置原始模式，禁用自动特殊字符处理、奇偶校验等功能</span></span><br><span class="line">        <span class="comment">// 以便更精确地控制串口数据的传输</span></span><br><span class="line">        cfmakeraw(&amp;cfg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置输入输出波特率</span></span><br><span class="line">        cfsetispeed(&amp;cfg, speed);</span><br><span class="line">        cfsetospeed(&amp;cfg, speed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置数据位 (5, 6, 7, 8 bits)</span></span><br><span class="line"><span class="comment">         * CSIZE Bit mask for data bits</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        cfg.c_cflag &amp;= ~CSIZE;</span><br><span class="line">        <span class="keyword">switch</span> (data_bit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                cfg.c_cflag |= CS5;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                cfg.c_cflag |= CS6;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                cfg.c_cflag |= CS7;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cfg.c_cflag |= CS8;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置停止位 (1 or 2) */</span></span><br><span class="line">        <span class="keyword">if</span> (stop_bit == <span class="number">1</span>)</span><br><span class="line">            cfg.c_cflag &amp;= ~CSTOPB;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* 2 */</span></span><br><span class="line">            cfg.c_cflag |= CSTOPB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置校验位模式 Enable parity bit </span></span><br><span class="line">        <span class="keyword">if</span> (parity == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGD(<span class="string">&quot;NONE&quot;</span>);</span><br><span class="line">            cfg.c_cflag &amp;= ~PARENB;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parity == <span class="number">1</span>) &#123;</span><br><span class="line">            LOGD(<span class="string">&quot;Even&quot;</span>);</span><br><span class="line">            cfg.c_cflag |= PARENB;</span><br><span class="line">            cfg.c_cflag &amp;= ~PARODD;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGD(<span class="string">&quot;ODD&quot;</span>);</span><br><span class="line">            cfg.c_cflag |= PARENB;</span><br><span class="line">            cfg.c_cflag |= PARODD;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (tcsetattr(fd, TCSANOW, &amp;cfg)) &#123;</span><br><span class="line">            LOGE(<span class="string">&quot;tcsetattr() failed&quot;</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件描述符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取类、构造函数ID、字段ID 最后实例化FileDescriptor后并设置字段</span></span><br><span class="line">        jclass cFileDescriptor = (*env)-&gt;FindClass(env, <span class="string">&quot;java/io/FileDescriptor&quot;</span>);</span><br><span class="line">        jmethodID iFileDescriptor = (*env)-&gt;GetMethodID(env, cFileDescriptor, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">        jfieldID descriptorID = (*env)-&gt;GetFieldID(env, cFileDescriptor, <span class="string">&quot;descriptor&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">        mFileDescriptor = (*env)-&gt;NewObject(env, cFileDescriptor, iFileDescriptor);</span><br><span class="line">        (*env)-&gt;SetIntField(env, mFileDescriptor, descriptorID, (jint) fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mFileDescriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🔒-关闭串口"><a href="#🔒-关闭串口" class="headerlink" title="🔒 关闭串口"></a>🔒 关闭串口</h3><div class="note blue icon-padding modern"><i class="note-icon fas fa-code"></i><p><strong>核心函数：<code>Java_com_crow_modbus_serialport_SerialPort_close</code></strong></p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     cedric_serial_SerialPort</span></span><br><span class="line"><span class="comment"> * Method:    close</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * Closes the serial port by releasing the file descriptor associated with it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL <span class="title function_">Java_com_crow_modbus_serialport_SerialPort_close</span><span class="params">(JNIEnv *env, jobject thiz)</span> &#123;</span><br><span class="line">    jclass SerialPortClass = (*env)-&gt;GetObjectClass(env, thiz);</span><br><span class="line">    jclass FileDescriptorClass = (*env)-&gt;FindClass(env, <span class="string">&quot;java/io/FileDescriptor&quot;</span>);</span><br><span class="line"></span><br><span class="line">    jfieldID mFdID = (*env)-&gt;GetFieldID(env, SerialPortClass, <span class="string">&quot;mFileDescriptor&quot;</span>, <span class="string">&quot;Ljava/io/FileDescriptor;&quot;</span>);</span><br><span class="line">    jfieldID descriptorID = (*env)-&gt;GetFieldID(env, FileDescriptorClass, <span class="string">&quot;fd&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line"></span><br><span class="line">    jobject mFd = (*env)-&gt;GetObjectField(env, thiz, mFdID);</span><br><span class="line">    jint descriptor = (*env)-&gt;GetIntField(env, mFd, descriptorID);</span><br><span class="line"></span><br><span class="line">    LOGD(<span class="string">&quot;close(fd = %d)&quot;</span>, descriptor);</span><br><span class="line">    close(descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><div class="note purple icon-padding modern"><i class="note-icon fab fa-kotlin"></i><ul><li>上层接口封装</li><li>数据读写操作  </li><li>异常处理机制</li><li>串口参数配置</li></ul></div><h3 id="🔌-接口声明"><a href="#🔌-接口声明" class="headerlink" title="🔌 接口声明"></a>🔌 接口声明</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SerialPort</span> <span class="keyword">protected</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mFileDescriptor: FileDescriptor? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            <span class="comment">// 加载共享库</span></span><br><span class="line">            System.loadLibrary(<span class="string">&quot;SerialPort&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ● 打开串口</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> path 串口文件路径</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> baudrate 波特率</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parity 校验</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> stopbit 停止位 1 或 2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> databit 数据位 5 - 8</span></span><br><span class="line"><span class="comment">    * ● 2023-09-25 18:29:58 周一 下午</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">open</span><span class="params">(path: <span class="type">String</span>, baudrate: <span class="type">Int</span>, parity: <span class="type">SerialPortParityFunction</span>, stopbit: <span class="type">Int</span>, databit: <span class="type">Int</span>)</span></span>: FileDescriptor &#123;</span><br><span class="line">        <span class="keyword">if</span> (stopbit !<span class="keyword">in</span> <span class="number">1.</span><span class="number">.2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;stopbit must in 1..2!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (databit !<span class="keyword">in</span> <span class="number">5.</span><span class="number">.8</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;databit must in 5..8!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">open</span>(path, baudrate, <span class="number">0</span>, parity.code, stopbit, databit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义JNI方法，用于打开串口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">open</span><span class="params">(path: <span class="type">String</span>, baudrate: <span class="type">Int</span>, flags: <span class="type">Int</span>, parity: <span class="type">Int</span>, stopbits: <span class="type">Int</span>, databits: <span class="type">Int</span>)</span></span>: FileDescriptor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义JNI方法，用于关闭串口</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩-串口管理封装"><a href="#🚩-串口管理封装" class="headerlink" title="🚩 串口管理封装"></a>🚩 串口管理封装</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SerialPortManager</span> : <span class="type">SerialPort</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> mutex = Mutex()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> parentJob = SupervisorJob()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> io = CoroutineScope(Dispatchers.IO + parentJob + CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">            loggerError(<span class="string">&quot;SerialPort an Exception occurs! context is <span class="variable">$coroutineContext</span> \t exception : <span class="subst">$&#123;throwable.stackTraceToString()&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mSuccessListener: IOpenSerialPortSuccess? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mFailureListener: IOpenSerialPortFailure? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mFileInputStream: FileInputStream? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mFileOutputStream: FileOutputStream? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mReadedBuffer = Bytes(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ● 修改文件权限为可读、可写、可执行</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * ● 2023-09-23 11:41:26 周六 上午</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">changeFilePermissions</span><span class="params">(file: <span class="type">File</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (file.takeIf &#123; it.exists() &#125; ?: <span class="literal">false</span>).runCatching &#123;</span><br><span class="line"></span><br><span class="line">            logger(<span class="string">&quot;info&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取ROOT权限</span></span><br><span class="line">            <span class="keyword">val</span> su = Runtime.getRuntime().exec(<span class="string">&quot;/system/bin/su&quot;</span>)</span><br><span class="line"></span><br><span class="line">            logger(su)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改文件属性为 [可读 可写 可执行]</span></span><br><span class="line">            <span class="keyword">val</span> cmd = <span class="string">&quot;chmod 777 <span class="subst">$&#123;file.absolutePath&#125;</span>\nexit\n&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将命令写入 su 进程的输出流</span></span><br><span class="line">            su.outputStream.write(cmd.toByteArray())</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 su 进程返回值为 0 并且文件可读、可写、可执行，则返回 true</span></span><br><span class="line">            (su.waitFor() == <span class="number">0</span> &amp;&amp; file.canRead() &amp;&amp; file.canWrite() &amp;&amp; file.canExecute())</span><br><span class="line">        &#125;</span><br><span class="line">        .onFailure &#123; <span class="keyword">catch</span> -&gt;</span><br><span class="line">            <span class="keyword">when</span> (<span class="keyword">catch</span>) &#123;</span><br><span class="line">                <span class="keyword">is</span> IOException -&gt; logger(<span class="string">&quot;No root permission!&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span> -&gt; logger(<span class="keyword">catch</span>.stackTraceToString())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .getOrElse &#123; <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ● 打开串口</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * ● 2023-09-23 16:02:30 周六 下午</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">openSerialPort</span><span class="params">(path: <span class="type">String</span>, baudRate: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> device = File(path)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验串口权限</span></span><br><span class="line">        <span class="keyword">if</span> (!device.canRead() || !device.canWrite()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changeFilePermissions(device)) &#123;</span><br><span class="line">                loggerError(<span class="string">&quot;openSerialPort : 没有读写权限!&quot;</span>)</span><br><span class="line">                mFailureListener?.onFailure(device, SerialPortState.NO_READ_WRITE_PERMISSION)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFileDescriptor = <span class="keyword">open</span>(device.absolutePath, baudRate, SerialPortParityFunction.EVEN, <span class="number">1</span>, <span class="number">8</span>)</span><br><span class="line">        mFileInputStream = FileInputStream(mFileDescriptor)</span><br><span class="line">        mFileOutputStream = FileOutputStream(mFileDescriptor)</span><br><span class="line">        mSuccessListener?.onSuccess(device)</span><br><span class="line">        logger(<span class="string">&quot;openSerialPort : 串口已经打开 <span class="variable">$mFileDescriptor</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ● 关闭串口</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * ● 2023-09-23 16:02:12 周六 下午</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">closeSerialPort</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> runCatching &#123;</span><br><span class="line">            parentJob.children.forEach &#123; job -&gt; job.cancel() &#125;</span><br><span class="line">            mFileDescriptor = <span class="literal">null</span></span><br><span class="line">            mFileInputStream?.close()</span><br><span class="line">            mFileOutputStream?.close()</span><br><span class="line">            mFileInputStream = <span class="literal">null</span></span><br><span class="line">            mFileOutputStream = <span class="literal">null</span></span><br><span class="line">            mSuccessListener = <span class="literal">null</span></span><br><span class="line">            mFailureListener = <span class="literal">null</span></span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onFailure &#123; <span class="keyword">catch</span> -&gt; loggerError(<span class="string">&quot;close serial port exception! <span class="subst">$&#123;catch.stackTraceToString()&#125;</span>&quot;</span>) &#125;</span><br><span class="line">        .getOrElse &#123; <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OptIn(ExperimentalStdlibApi::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">writeBytes</span><span class="params">(bytes: <span class="type">ByteArray</span>)</span></span> &#123;</span><br><span class="line">        io.launch &#123;</span><br><span class="line">            mutex.withLock &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != mFileDescriptor &amp;&amp; <span class="literal">null</span> != mFileInputStream &amp;&amp; <span class="literal">null</span> != mFileOutputStream) &#123;</span><br><span class="line">                    logger(<span class="string">&quot;writeBytes <span class="subst">$&#123;bytes.map &#123; it.toHexString() &#125;</span>&#125;&quot;</span>)</span><br><span class="line">                    mFileOutputStream!!.write(bytes)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBytes</span><span class="params">(iDataReceive: <span class="type">IDataReceive</span>)</span></span> &#123;</span><br><span class="line">        io.launch &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != mFileDescriptor &amp;&amp; <span class="literal">null</span> != mFileInputStream &amp;&amp; <span class="literal">null</span> != mFileOutputStream) &#123;</span><br><span class="line">                    <span class="keyword">val</span> length = mFileInputStream!!.read(mReadedBuffer)</span><br><span class="line">                    logger(<span class="string">&quot;<span class="variable">$length</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">if</span> (length &lt;= <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@launch</span></span><br><span class="line">                    <span class="keyword">val</span> buffer = Bytes(length)</span><br><span class="line">                    System.arraycopy(mReadedBuffer, <span class="number">0</span>, buffer, <span class="number">0</span>, length)</span><br><span class="line">                    iDataReceive.onReceive(buffer)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🎯-关键要点总结"><a href="#🎯-关键要点总结" class="headerlink" title="🎯 关键要点总结"></a>🎯 关键要点总结</h2><div class="note success icon-padding modern"><i class="note-icon fas fa-check-circle"></i><p><strong>本文重点内容：</strong></p><ol><li>✅ 理解Android串口通信的基本原理</li><li>✅ 掌握JNI层串口开启和关闭的实现</li><li>✅ 学会串口参数的配置方法</li><li>✅ 了解文件描述符创建和管理</li></ol></div><h2 id="🔗-相关链接"><a href="#🔗-相关链接" class="headerlink" title="🔗 相关链接"></a>🔗 相关链接</h2><div class="btn-center"><a class="btn-beautify blue larger" href="https://github.com/crowforkotlin/KModbus" title="KModbus项目"><i class="fab fa-github"></i><span>KModbus项目</span></a><a class="btn-beautify green larger" href="https://github.com/stephane/libmodbus" title="LibModbus参考"><i class="fab fa-github"></i><span>LibModbus参考</span></a></div>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> JNI </tag>
            
            <tag> Java </tag>
            
            <tag> Kotlin </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>① Android JNI 入门指南</title>
      <link href="/2023/09/27/Android/01JNI%E5%85%A5%E9%97%A8/"/>
      <url>/2023/09/27/Android/01JNI%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<div class="note modern"><p>🎯 <strong>学习目标</strong>：通过本教程，你将掌握 Android JNI 开发的基础知识，学会如何在 Android 项目中集成和使用 C&#x2F;C++ 代码。</p></div><h2 id="📖-概述"><a href="#📖-概述" class="headerlink" title="📖 概述"></a>📖 概述</h2><p><strong>JNI（Java Native Interface）</strong> 是 Java 平台的一部分，它允许在 Java 虚拟机内运行的 Java 代码调用并被用其他编程语言（如 C、C++）编写的应用程序和库调用。</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">🚀 性能优化</button><button type="button" class="tab">🔧 系统调用</button><button type="button" class="tab">📚 代码复用</button></div><div class="tab-contents"><div class="tab-item-content active"><p>将计算密集型任务移至 C&#x2F;C++ 层执行，充分利用原生代码的性能优势：</p><ul><li>图像处理算法</li><li>音视频编解码</li><li>加密解密运算</li><li>数学计算库</li></ul></div><div class="tab-item-content"><p>直接调用 Linux 系统底层 API，访问 Java 层无法直接使用的功能：</p><ul><li>串口通信</li><li>GPIO 控制</li><li>文件系统操作</li><li>网络底层协议</li></ul></div><div class="tab-item-content"><p>集成现有的成熟 C&#x2F;C++ 库，避免重复开发：</p><ul><li>OpenCV 图像处理</li><li>FFmpeg 音视频处理</li><li>OpenSSL 加密库</li><li>第三方算法库</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🛠️-基本配置步骤"><a href="#🛠️-基本配置步骤" class="headerlink" title="🛠️ 基本配置步骤"></a>🛠️ 基本配置步骤</h2><div class="note info icon-padding flat"><i class="note-icon fas fa-info-circle"></i><p><strong>开始之前</strong>：确保你已经安装了 Android Studio 和相关开发工具</p></div><h3 id="📋-前置要求"><a href="#📋-前置要求" class="headerlink" title="📋 前置要求"></a>📋 前置要求</h3><div class="note success icon-padding flat"><i class="note-icon fas fa-check-circle"></i><p>✅ <strong>必需工具清单</strong></p><ul><li>Android Studio（最新版本）</li><li>NDK（Native Development Kit）</li><li>CMake 构建工具</li><li>Git（用于版本管理）</li></ul></div><h3 id="�-配置流程"><a href="#�-配置流程" class="headerlink" title="� 配置流程"></a>� 配置流程</h3><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph TD    A[📱 创建 Android 项目] --&gt; B[⚙️ 配置 Gradle]    B --&gt; C[📁 创建 cpp 目录]    C --&gt; D[📝 编写 C&#x2F;C++ 代码]    D --&gt; E[🔗 声明 Native 方法]    E --&gt; F[📚 加载动态库]    F --&gt; G[🎉 编译运行]  </pre></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-lightbulb"></i><p><strong>开发提示</strong>：建议按照上述流程逐步配置，每完成一步都进行测试验证。</p></div><h2 id="⚙️-详细配置"><a href="#⚙️-详细配置" class="headerlink" title="⚙️ 详细配置"></a>⚙️ 详细配置</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">📝 Gradle 配置</button><button type="button" class="tab">🔨 CMake 配置</button><button type="button" class="tab">☕ Java/Kotlin 代码</button><button type="button" class="tab">🔧 C/C++ 实现</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="1-Gradle-配置"><a href="#1-Gradle-配置" class="headerlink" title="1. Gradle 配置"></a>1. Gradle 配置</h3><p>在 <code>app/build.gradle.kts</code> 文件中添加 NDK 和 CMake 配置：</p><div class="note orange icon-padding flat"><i class="note-icon fas fa-file-code"></i><p><strong>配置文件</strong>：<code>app/build.gradle.kts</code></p></div><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// ...其他配置</span></span><br><span class="line">    </span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="comment">// ...其他配置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 配置 NDK 支持的 ABI 架构</span></span><br><span class="line">        ndk &#123;</span><br><span class="line">            abiFilters += listOf(<span class="string">&quot;armeabi-v7a&quot;</span>, <span class="string">&quot;arm64-v8a&quot;</span>, <span class="string">&quot;x86&quot;</span>, <span class="string">&quot;x86_64&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 CMake 构建系统</span></span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path = file(<span class="string">&quot;CMakeLists.txt&quot;</span>)</span><br><span class="line">            version = <span class="string">&quot;3.18.1&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning icon-padding flat"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>注意</strong>：ABI 架构建议根据目标设备选择，过多的架构会增加 APK 体积。</p></div></div><div class="tab-item-content"><h3 id="2-CMake-配置"><a href="#2-CMake-配置" class="headerlink" title="2. CMake 配置"></a>2. CMake 配置</h3><p>在项目根目录创建 <code>CMakeLists.txt</code> 文件：</p><div class="note purple icon-padding flat"><i class="note-icon fas fa-hammer"></i><p><strong>配置文件</strong>：<code>CMakeLists.txt</code></p></div><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.18</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目名称</span></span><br><span class="line"><span class="keyword">project</span>(<span class="string">&quot;SerialPortDemo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加库文件 - 创建名为 SerialPort 的共享动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">    SerialPort                    <span class="comment"># 库名称</span></span><br><span class="line">    SHARED                        <span class="comment"># 库类型：共享库</span></span><br><span class="line">    src/main/cpp/SerialPort.h     <span class="comment"># 头文件</span></span><br><span class="line">    src/main/cpp/SerialPort.c     <span class="comment"># 源文件</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 Android 系统库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    SerialPort                    <span class="comment"># 目标库</span></span><br><span class="line">    android                       <span class="comment"># Android 系统库</span></span><br><span class="line">    log                          <span class="comment"># 日志库</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><div class="note green icon-padding modern"><i class="note-icon fas fa-check"></i><p><strong>构建说明</strong>：CMake 会自动处理跨平台编译，生成对应架构的 <code>.so</code> 动态库文件。</p></div></div><div class="tab-item-content"><h3 id="3-Java-x2F-Kotlin-中的-Native-方法声明"><a href="#3-Java-x2F-Kotlin-中的-Native-方法声明" class="headerlink" title="3. Java&#x2F;Kotlin 中的 Native 方法声明"></a>3. Java&#x2F;Kotlin 中的 Native 方法声明</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">🟢 Kotlin 版本</button><button type="button" class="tab">☕ Java 版本</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="note green icon-padding flat"><i class="note-icon fab fa-kotlin"></i><p><strong>推荐使用</strong>：Kotlin 是 Android 官方首选语言</p></div><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.serialport</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileDescriptor</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SerialPort</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">// 静态初始化块 - 加载 Native 库</span></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;SerialPort&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开串口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 串口设备路径，如 &quot;/dev/ttyS0&quot;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> baudrate 波特率，如 9600, 115200</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flags 标志位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parity 校验位：0-无校验，1-奇校验，2-偶校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stopbits 停止位：1 或 2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> databits 数据位：5, 6, 7, 8</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 文件描述符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        path: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        baudrate: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        flags: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        parity: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        stopbits: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        databits: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: FileDescriptor?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭串口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><div class="note orange icon-padding flat"><i class="note-icon fab fa-java"></i><p><strong>经典选择</strong>：适合熟悉传统 Java 开发的开发者</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.serialport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileDescriptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerialPort</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态初始化块 - 加载 Native 库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;SerialPort&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开串口（Native 方法）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> FileDescriptor <span class="title function_">open</span><span class="params">(String path, <span class="type">int</span> baudrate, <span class="type">int</span> flags, </span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> parity, <span class="type">int</span> stopbits, <span class="type">int</span> databits)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭串口（Native 方法）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tab-item-content"><h3 id="4-C-x2F-C-实现"><a href="#4-C-x2F-C-实现" class="headerlink" title="4. C&#x2F;C++ 实现"></a>4. C&#x2F;C++ 实现</h3><p>在 <code>app/src/main/cpp/SerialPort.c</code> 中实现 Native 方法：</p><div class="note red icon-padding flat"><i class="note-icon fas fa-code"></i><p><strong>核心代码</strong>：C&#x2F;C++ 原生实现</p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志标签</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_TAG <span class="string">&quot;SerialPort-JNI&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JNI 函数命名规则：</span></span><br><span class="line"><span class="comment"> * JNIEXPORT 返回类型 JNICALL Java_包名_类名_方法名</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param env JNI 环境指针</span></span><br><span class="line"><span class="comment"> * @param thiz 调用该方法的类实例（如果是静态方法则为类对象）</span></span><br><span class="line"><span class="comment"> * @param path 串口设备路径</span></span><br><span class="line"><span class="comment"> * @param baudrate 波特率</span></span><br><span class="line"><span class="comment"> * @param flags 打开标志</span></span><br><span class="line"><span class="comment"> * @param parity 校验位</span></span><br><span class="line"><span class="comment"> * @param stopbits 停止位</span></span><br><span class="line"><span class="comment"> * @param databits 数据位</span></span><br><span class="line"><span class="comment"> * @return 返回 FileDescriptor 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jobject JNICALL </span><br><span class="line"><span class="title function_">Java_com_example_serialport_SerialPort_open</span><span class="params">(JNIEnv *env, jobject thiz, </span></span><br><span class="line"><span class="params">                                           jstring path, jint baudrate, jint flags, </span></span><br><span class="line"><span class="params">                                           jint parity, jint stopbits, jint databits)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 Java String 转换为 C 字符串</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *path_utf = (*env)-&gt;GetStringUTFChars(env, path, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    LOGD(<span class="string">&quot;Opening serial port: %s&quot;</span>, path_utf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开串口设备</span></span><br><span class="line">    <span class="type">int</span> fd = open(path_utf, O_RDWR | O_NOCTTY | O_NONBLOCK);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放字符串内存</span></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, path, path_utf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">&quot;Failed to open serial port: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置串口参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">tios</span>;</span></span><br><span class="line">    tcgetattr(fd, &amp;tios);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置波特率、数据位、停止位、校验位等...</span></span><br><span class="line">    <span class="comment">// (具体实现省略)</span></span><br><span class="line">    </span><br><span class="line">    tcsetattr(fd, TCSANOW, &amp;tios);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 FileDescriptor 对象</span></span><br><span class="line">    jclass cFileDescriptor = (*env)-&gt;FindClass(env, <span class="string">&quot;java/io/FileDescriptor&quot;</span>);</span><br><span class="line">    jmethodID iFileDescriptor = (*env)-&gt;GetMethodID(env, cFileDescriptor, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    jobject jFileDescriptor = (*env)-&gt;NewObject(env, cFileDescriptor, iFileDescriptor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 fd 字段</span></span><br><span class="line">    jfieldID descriptorID = (*env)-&gt;GetFieldID(env, cFileDescriptor, <span class="string">&quot;descriptor&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">    (*env)-&gt;SetIntField(env, jFileDescriptor, descriptorID, (jint)fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> jFileDescriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭串口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL </span><br><span class="line"><span class="title function_">Java_com_example_serialport_SerialPort_close</span><span class="params">(JNIEnv *env, jobject thiz)</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭串口的实现</span></span><br><span class="line">    LOGD(<span class="string">&quot;Closing serial port&quot;</span>);</span><br><span class="line">    <span class="comment">// 具体实现...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note pink icon-padding modern"><i class="note-icon fas fa-magic"></i><p><strong>编程技巧</strong>：使用 Android Log 系统可以方便地调试 C&#x2F;C++ 代码。</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## JNI 函数命名规则</span><br><span class="line"></span><br><span class="line">JNI 函数必须遵循特定的命名规则：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JNIEXPORT 返回类型 JNICALL Java_完整包名_类名_方法名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 示例解析</span><br><span class="line"></span><br><span class="line">对于包名为 `com.example.serialport`，类名为 `SerialPort`，方法名为 `open` 的函数：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">JNIEXPORT jobject JNICALL </span><br><span class="line">Java_com_example_serialport_SerialPort_open(JNIEnv *env, jobject thiz, ...)</span><br></pre></td></tr></table></figure><ul><li><code>com.example.serialport</code> → <code>com_example_serialport</code></li><li>包名中的点(<code>.</code>)替换为下划线(<code>_</code>)</li><li>类名和方法名直接拼接</li></ul><h2 id="常见问题与注意事项"><a href="#常见问题与注意事项" class="headerlink" title="常见问题与注意事项"></a>常见问题与注意事项</h2><h3 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a>⚠️ 注意事项</h3><ol><li><strong>内存管理</strong>：使用 <code>GetStringUTFChars</code> 后必须调用 <code>ReleaseStringUTFChars</code></li><li><strong>异常处理</strong>：JNI 调用可能产生异常，需要适当处理</li><li><strong>线程安全</strong>：JNI 调用需要考虑线程安全问题</li><li><strong>性能影响</strong>：频繁的 Java-Native 调用会影响性能</li></ol><h3 id="🔧-常见错误"><a href="#🔧-常见错误" class="headerlink" title="🔧 常见错误"></a>🔧 常见错误</h3><ul><li><strong>UnsatisfiedLinkError</strong>：通常是库加载失败或函数签名不匹配</li><li><strong>FindClass 失败</strong>：类名路径错误或类不存在</li><li><strong>内存泄漏</strong>：忘记释放 JNI 分配的内存</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Android JNI 开发虽然入门门槛较高，但掌握基本流程后就能够：</p><ol><li><strong>性能优化</strong>：将计算密集型任务移至 C&#x2F;C++ 层</li><li><strong>系统调用</strong>：直接调用 Linux 系统 API</li><li><strong>代码复用</strong>：集成现有的 C&#x2F;C++ 库</li></ol><p>通过本教程的配置和示例，你应该能够开始自己的 JNI 开发之旅。建议从简单的函数开始，逐步深入学习更复杂的 JNI 特性。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://developer.android.com/ndk">Android NDK 官方文档</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/">JNI 规范</a></li><li><a href="https://cmake.org/documentation/">CMake 官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> JNI </tag>
            
            <tag> Java </tag>
            
            <tag> Kotlin </tag>
            
            <tag> C </tag>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
