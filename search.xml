<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Wasmtime JIT 编译机制与 Cranelift 内部原理：基于 Issue</title>
      <link href="/2026/01/01/Wasm/Wasmtime%E5%9F%BA%E4%BA%8EIssue12229%E8%A7%A3%E6%9E%90%E5%92%8CJit%E3%80%81Cranelift%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3/"/>
      <url>/2026/01/01/Wasm/Wasmtime%E5%9F%BA%E4%BA%8EIssue12229%E8%A7%A3%E6%9E%90%E5%92%8CJit%E3%80%81Cranelift%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇博客文章旨在对 GitHub Issue #12229 进行深度的技术复盘。补充了大量 Issue 中提及但未在之前详细解释的底层概念（如 Guard Pages, ART 信号冲突, AOT&#x2F;Pre-compilation, Winch 等…)</p></blockquote><ul><li><a href="https://github.com/bytecodealliance/wasmtime/issues/12229">Issues 12229</a></li></ul><h1 id="Wasmtime-JIT-编译机制与-Cranelift-内部原理：基于-Issue-12229-的全景技术解析"><a href="#Wasmtime-JIT-编译机制与-Cranelift-内部原理：基于-Issue-12229-的全景技术解析" class="headerlink" title="Wasmtime JIT 编译机制与 Cranelift 内部原理：基于 Issue #12229 的全景技术解析"></a>Wasmtime JIT 编译机制与 Cranelift 内部原理：基于 Issue #12229 的全景技术解析</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><p>在将 WebAssembly 引入移动端（Android）的高性能计算场景中，开发者面临着运行时环境与编译器底层的双重挑战。本文以 <strong>Wasmtime Issue #12229</strong> 为切入点，详细剖析了一个 781KB 的 Kotlin&#x2F;Wasm 模块如何在 JIT 编译阶段引发 <strong>1.6GB 内存峰值</strong> 并导致 <strong>“Code for function is too large”</strong> 错误的完整技术链路。我们将逐一解析涉及的操作系统内存模型、Android 运行时集成、Cranelift 编译器中间表示（IR）以及 SSA 形式等核心术语。</p></blockquote><h2 id="1-案例背景与运行时架构-Context-amp-Architecture"><a href="#1-案例背景与运行时架构-Context-amp-Architecture" class="headerlink" title="1. 案例背景与运行时架构 (Context &amp; Architecture)"></a>1. 案例背景与运行时架构 (Context &amp; Architecture)</h2><p>在深入底层之前，我们需要明确该 Issue 发生的技术栈环境。这是理解后续配置和错误的先决条件。</p><h3 id="Wasmtime"><a href="#Wasmtime" class="headerlink" title="Wasmtime"></a><strong>Wasmtime</strong></h3><p>Wasmtime 是一个字节码联盟（Bytecode Alliance）维护的独立 WebAssembly 运行时。</p><ul><li><strong>角色</strong>：在本项目中，它被作为原生库（Native Library）集成到 Android 应用中，负责加载和执行 Wasm 模块。</li><li><strong>关键点</strong>：它不依赖浏览器引擎（如 V8），而是拥有自己的内存管理和编译管道。</li></ul><h3 id="Kotlin-x2F-Wasm-WASI"><a href="#Kotlin-x2F-Wasm-WASI" class="headerlink" title="Kotlin&#x2F;Wasm (WASI)"></a><strong>Kotlin&#x2F;Wasm (WASI)</strong></h3><p>这是 Kotlin 语言的一种编译器后端（Compiler Backend）。</p><ul><li><strong>特性</strong>：它将 Kotlin 代码直接编译为 Wasm 字节码，并使用 <strong>WASI (WebAssembly System Interface)</strong> 作为系统调用标准。</li><li><strong>Wasm GC</strong>：与 Kotlin&#x2F;Native 不同，Kotlin&#x2F;Wasm 依赖 WebAssembly 的垃圾回收（GC）提案。这意味着生成的 Wasm 二进制文件中包含大量高级内存操作指令（如 <code>struct.new</code>），而非单纯的线性内存操作。</li></ul><h3 id="JIT-Just-In-Time-Compilation"><a href="#JIT-Just-In-Time-Compilation" class="headerlink" title="JIT (Just-In-Time) Compilation"></a><strong>JIT (Just-In-Time) Compilation</strong></h3><p>即时编译。Wasmtime 在加载 <code>.wasm</code> 模块时，会动态地将字节码翻译为宿主机器（Host Machine，此处为 Android aarch64）的机器码。</p><ul><li><strong>JIT Loading Phase</strong>：Issue 中提到的“加载阶段”，实际上是编译器高负载工作的阶段。此时需要构建中间数据结构，消耗大量 CPU 和内存。</li></ul><h3 id="AOT-Ahead-Of-Time-x2F-cwasm"><a href="#AOT-Ahead-Of-Time-x2F-cwasm" class="headerlink" title="AOT (Ahead-Of-Time) &#x2F; .cwasm"></a><strong>AOT (Ahead-Of-Time) &#x2F; .cwasm</strong></h3><p>为了解决 JIT 的启动延迟和内存开销，Wasmtime 支持 AOT 编译。</p><ul><li><strong>机制</strong>：开发者可以使用 <code>wasmtime compile</code> 命令预先将 <code>.wasm</code> 编译为 <code>.cwasm</code>（Compiled Wasm）格式。</li><li><strong>Issue 关联</strong>：开发者尝试通过 AOT 生成 <code>.cwasm</code> 来规避运行时崩溃，但在编译阶段同样遇到了编译器资源耗尽的问题。</li></ul><hr><h2 id="2-操作系统与内存模型-OS-amp-Memory-Configuration"><a href="#2-操作系统与内存模型-OS-amp-Memory-Configuration" class="headerlink" title="2. 操作系统与内存模型 (OS &amp; Memory Configuration)"></a>2. 操作系统与内存模型 (OS &amp; Memory Configuration)</h2><p>在 Android 这种受限环境下运行服务端级别的运行时（Wasmtime），需要精细的系统级配置。Issue 中暴露了几个关键的内存与信号处理术语。</p><h3 id="RSS-Resident-Set-Size"><a href="#RSS-Resident-Set-Size" class="headerlink" title="RSS (Resident Set Size)"></a><strong>RSS (Resident Set Size)</strong></h3><p><strong>常驻内存集</strong>。</p><ul><li><strong>解释</strong>：指进程在物理 RAM 中实际占用的内存大小，不包括被交换（Swap）出去的数据。</li><li><strong>现象</strong>：日志显示 <code>Rss Memory Size Change 234MB -&gt; 1612MB</code>。这证实了编译器在内存中构建的数据结构（IR Graph）实实在在地消耗了 1.6GB 的物理内存，导致内存压力剧增。</li></ul><h3 id="VSS-Virtual-Set-Size-amp-Memory-Guard-Size"><a href="#VSS-Virtual-Set-Size-amp-Memory-Guard-Size" class="headerlink" title="VSS (Virtual Set Size) &amp; Memory Guard Size"></a><strong>VSS (Virtual Set Size) &amp; Memory Guard Size</strong></h3><p><strong>虚拟内存集</strong>与<strong>内存保护页大小</strong>。</p><ul><li><strong>Guard Pages</strong>：Wasmtime 默认会在 4GB 的线性内存前后分配巨大的保留地址空间（例如 2GB 或更多），用于捕获越界访问（OOB）。这会显著增加 VSS，尽管不消耗物理 RAM。</li><li><strong>OOM</strong>：在 32 位 Android 设备或地址空间碎片严重的进程中，过大的 VSS 会导致虚拟地址耗尽。</li><li><strong>Issue 配置</strong>：<code>wasmtime_config_memory_guard_size_set(conf, 0)</code>。开发者显式将保护页设为 0，是为了防止 VSS 过大导致 OOM，这是移动端集成的常见优化。</li></ul><hr><h3 id="1-什么是-VSS-Virtual-Set-Size-？"><a href="#1-什么是-VSS-Virtual-Set-Size-？" class="headerlink" title="1. 什么是 VSS (Virtual Set Size)？"></a>1. 什么是 VSS (Virtual Set Size)？</h3><p><strong>—— “你可以用的名额”，而不是“你实际用的东西”。</strong></p><ul><li><strong>定义</strong>：虚拟内存集。它是操作系统承诺给一个进程使用的<strong>地址空间总大小</strong>。</li><li><strong>通俗类比</strong>：<br>想象你去一家自助餐厅。<ul><li><strong>VSS</strong> 是你手里拿的<strong>盘子的大小</strong>。你可以拿一个直径 1 米的巨型盘子（申请了 10GB 虚拟内存），这代表你“有权利”装这么多食物。</li><li><strong>RSS (物理内存)</strong> 是你盘子里<strong>实际装的食物</strong>。你虽然拿了个巨型盘子，但可能只放了一颗花生米（实际只用了 4KB 物理内存）。</li></ul></li><li><strong>关键点</strong>：<ul><li>VSS <strong>不消耗</strong> 物理 RAM（金钱）。</li><li>VSS <strong>消耗</strong> 系统的寻址范围（盘子的库存）。</li></ul></li><li><strong>为什么这是个问题？</strong><ul><li>在 <strong>64位系统</strong>（如服务器）上，地址空间几乎是无限的（盘子无限大），你申请 10TB 的 VSS 也没问题。</li><li>在 <strong>32位系统</strong>（如旧手机或某些 Android 进程）上，总共只有 <strong>4GB</strong> 的地址空间（盘子库存很少）。如果你申请了 2GB 的 VSS，哪怕你一点物理内存都不用，剩下的空间也只剩 2GB 了。一旦耗尽，程序就会因为“申请不到地址”而崩溃（OOM），尽管物理内存还剩很多。</li></ul></li></ul><hr><h3 id="2-什么是-Memory-Guard-Size-内存保护页-？"><a href="#2-什么是-Memory-Guard-Size-内存保护页-？" class="headerlink" title="2. 什么是 Memory Guard Size (内存保护页)？"></a>2. 什么是 Memory Guard Size (内存保护页)？</h3><p><strong>—— “为了省事而挖的护城河”。</strong></p><ul><li><strong>背景</strong>：WebAssembly 的内存是一个连续的数组（线性内存）。如果 Wasm 程序试图访问数组范围之外的内存（越界），必须报错。</li><li><strong>两种实现方式</strong>：<ol><li><strong>笨办法（显式检查）</strong>：在每一行读取内存的代码前，都加一句 <code>if (index &gt; max_length) 报错</code>。这很安全，但运行<strong>慢</strong>，因为 CPU 要多做一次判断。</li><li><strong>聪明办法（利用保护页）</strong>：不加 <code>if</code> 判断，直接读。但是，Wasmtime 会在有效内存后面，圈出一大块<strong>空白区域</strong>（比如 2GB），并告诉操作系统：“这块区域谁碰谁死”。<ul><li>这就是 <strong>Guard Pages（保护页）</strong>。</li><li>如果程序越界了，就会落入这个“护城河”，CPU 硬件会立刻触发异常（Signal），Wasmtime 捕获这个异常并报错。</li></ul></li></ol></li><li><strong>代价</strong>：<br>这个“护城河”虽然不占物理内存（里头没水），但它占<strong>地皮</strong>（占用了 VSS 虚拟地址空间）。</li></ul><hr><h3 id="3-设置保护页为-0-具体是什么意思？"><a href="#3-设置保护页为-0-具体是什么意思？" class="headerlink" title="3. 设置保护页为 0 具体是什么意思？"></a>3. 设置保护页为 0 具体是什么意思？</h3><p><code>wasmtime_config_memory_guard_size_set(conf, 0)</code></p><p><strong>—— “填平护城河，改用门卫检查”。</strong></p><p>当你把保护页大小设置为 0 时，发生了以下变化：</p><h4 id="1-动作："><a href="#1-动作：" class="headerlink" title="1. 动作："></a>1. 动作：</h4><p>Wasmtime 不再在 Wasm 内存块后面预留那 2GB+ 的虚拟地址空间了。</p><h4 id="2-对-VSS-的影响（好处）："><a href="#2-对-VSS-的影响（好处）：" class="headerlink" title="2. 对 VSS 的影响（好处）："></a>2. 对 VSS 的影响（好处）：</h4><p>进程的 <strong>VSS 瞬间大幅降低</strong>。</p><ul><li><strong>之前</strong>：加载 10 个 Wasm 模块，可能需要预留 <code>10 * 2GB = 20GB</code> 的虚拟地址。在 Android 上直接 OOM（崩溃）。</li><li><strong>现在</strong>：加载 10 个 Wasm 模块，只占用它们实际需要的空间。大大减少了因为“地址空间耗尽”而崩溃的风险。</li></ul><h4 id="3-对性能的影响（坏处）："><a href="#3-对性能的影响（坏处）：" class="headerlink" title="3. 对性能的影响（坏处）："></a>3. 对性能的影响（坏处）：</h4><p>既然没有“护城河”兜底了，如果程序越界访问，可能会读到后面不该读的数据（野指针），这很危险。<br>因此，Wasmtime 的编译器（Cranelift）被迫切换回<strong>“笨办法”</strong>：<br>它会在生成的机器码中，为每一次内存访问<strong>插入显式的边界检查指令</strong>（Explicit Bounds Checks）。</p><ul><li><strong>后果</strong>：生成的机器码体积稍微变大，运行速度稍微变慢（因为多了很多 <code>if</code> 判断指令）。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="left">概念</th><th align="left">解释</th><th align="left">形象比喻</th></tr></thead><tbody><tr><td align="left"><strong>VSS</strong></td><td align="left">申请的虚拟地址总量，包含未使用的保留区。</td><td align="left">你手里的餐盘大小（无论是否装满）。</td></tr><tr><td align="left"><strong>Guard Pages</strong></td><td align="left">Wasm 内存后预留的不可访问区域，用于通过硬件捕获越界。</td><td align="left">在房子周围挖的<strong>空</strong>护城河，防贼（越界）。</td></tr><tr><td align="left"><strong>Guard Size &#x3D; 0</strong></td><td align="left">放弃使用预留区域，改为在代码中插入检查指令。</td><td align="left"><strong>填平护城河</strong>，省下了地皮（VSS），但必须在门口雇<strong>保安</strong>（显式检查指令）来查每一个进出的人。</td></tr></tbody></table><p><strong>在 Android 上集成的常见优化</strong>：<br>正是因为移动设备（特别是 32 位应用）的虚拟地址空间太宝贵了，不够挖那么多“护城河”，所以开发者宁愿牺牲一点点运行速度（雇保安），也要把地皮省下来（设为 0），防止程序因为拿不到地皮而崩溃。</p><hr><h3 id="Signal-based-Traps-基于信号的陷阱"><a href="#Signal-based-Traps-基于信号的陷阱" class="headerlink" title="Signal-based Traps (基于信号的陷阱)"></a><strong>Signal-based Traps (基于信号的陷阱)</strong></h3><ul><li><strong>机制</strong>：Wasmtime 通常利用操作系统信号（如 Linux 的 <code>SIGSEGV</code>）来处理内存越界或除零错误。这种方式比在每条指令前插入显式的 <code>if</code> 检查要快得多。</li></ul><ul><li><strong>ART Conflict</strong>：Android Runtime (ART) 自身也通过信号链（Signal Chain）管理 Java 层的异常（如 NullPointerException）。</li></ul><ul><li><strong>Issue 配置</strong>：<code>wasmtime_config_signals_based_traps_set(conf, false)</code>。为了避免 Wasmtime 的信号处理器破坏 ART 的信号链导致 Crash，必须在 Android 上禁用基于信号的陷阱。</li></ul><hr><h2 id="3-编译器内部原理-Compiler-Internals-Cranelift"><a href="#3-编译器内部原理-Compiler-Internals-Cranelift" class="headerlink" title="3. 编译器内部原理 (Compiler Internals: Cranelift)"></a>3. 编译器内部原理 (Compiler Internals: Cranelift)</h2><p>崩溃的核心原因在于 Wasmtime 的代码生成器 —— <strong>Cranelift</strong>。当它试图处理 Kotlin 生成的“巨型函数”时，触发了内部设计限制。</p><h3 id="Cranelift"><a href="#Cranelift" class="headerlink" title="Cranelift"></a><strong>Cranelift</strong></h3><p>Wasmtime 默认的编译器后端，用 Rust 编写。它的设计目标是在编译速度和代码质量之间取得平衡。</p><h3 id="IR-Intermediate-Representation-x2F-CLIF"><a href="#IR-Intermediate-Representation-x2F-CLIF" class="headerlink" title="IR (Intermediate Representation) &#x2F; CLIF"></a><strong>IR (Intermediate Representation) &#x2F; CLIF</strong></h3><p><strong>中间表示</strong>。</p><ul><li><strong>解释</strong>：编译器既不直接处理 Wasm 字节码，也不直接生成汇编。它先将代码转换为一种内部格式，称为 <strong>CLIF</strong>。</li><li><strong>数据</strong>：Issue 中提到，故障函数生成了包含 <strong>488,081 个基本块 (Basic Blocks)</strong> 的 CLIF。这相当于在内存中构建了一个极其庞大的图结构。</li></ul><h3 id="CFG-Control-Flow-Graph"><a href="#CFG-Control-Flow-Graph" class="headerlink" title="CFG (Control Flow Graph)"></a><strong>CFG (Control Flow Graph)</strong></h3><p><strong>控制流图</strong>。</p><ul><li><strong>解释</strong>：描述程序执行路径的有向图。图中的每个节点是一个<strong>基本块（Basic Block）</strong>，即一段没有分支的线性代码序列。</li><li><strong>复杂度</strong>：近 50 万个节点的 CFG 意味着编译器在进行活跃度分析（Liveness Analysis）和寄存器分配时，算法的时间复杂度和空间复杂度呈指数级上升。</li></ul><h3 id="SSA-Static-Single-Assignment"><a href="#SSA-Static-Single-Assignment" class="headerlink" title="SSA (Static Single Assignment)"></a><strong>SSA (Static Single Assignment)</strong></h3><p><strong>静态单赋值形式</strong>。</p><ul><li><strong>解释</strong>：Cranelift IR 的核心属性。它要求每个变量在代码中只能被赋值一次。这种形式极大地简化了优化算法，但也意味着如果源代码逻辑复杂，会生成海量的临时变量。</li><li><strong>数据</strong>：故障函数生成了 <strong>4,005,519 (400万)</strong> 个 SSA 值。这意味着函数内部的数据流依赖关系极其复杂。</li></ul><h3 id="Virtual-Registers-VRegs"><a href="#Virtual-Registers-VRegs" class="headerlink" title="Virtual Registers (VRegs)"></a><strong>Virtual Registers (VRegs)</strong></h3><p><strong>虚拟寄存器</strong>。</p><ul><li><strong>解释</strong>：在生成最终机器码之前，编译器假定机器拥有无限数量的寄存器来存储 SSA 值。这些被称为虚拟寄存器。</li><li><strong>限制</strong>：为了优化内存布局和指令编码，Cranelift 使用位压缩（Bitpacking）技术来存储 VReg 的索引。这导致了一个物理上限：<strong>每个函数最多支持 2^21 (约 200 万) 个虚拟寄存器</strong>。</li><li><strong>结论</strong>：<strong>400 万 SSA 值 &gt; 200 万 VReg 上限</strong>。这就是报错 <code>Code for function is too large</code> 的根本原因。编译器没有足够的“槽位”来存放这些临时变量了。</li></ul><hr><h2 id="4-触发诱因：Wasm-GC-与内联策略-Triggers-amp-Heuristics"><a href="#4-触发诱因：Wasm-GC-与内联策略-Triggers-amp-Heuristics" class="headerlink" title="4. 触发诱因：Wasm GC 与内联策略 (Triggers &amp; Heuristics)"></a>4. 触发诱因：Wasm GC 与内联策略 (Triggers &amp; Heuristics)</h2><p>为什么一个 700KB 的文件会生成如此庞大的 IR？这归结于指令集特性与编译策略的相互作用。</p><h3 id="struct-new"><a href="#struct-new" class="headerlink" title="struct.new"></a><strong><code>struct.new</code></strong></h3><p>WebAssembly GC 提案中的指令，用于在堆上动态分配结构体。Kotlin&#x2F;Wasm 使用它来创建对象实例。</p><h3 id="Aggressive-Inlining-激进内联"><a href="#Aggressive-Inlining-激进内联" class="headerlink" title="Aggressive Inlining (激进内联)"></a><strong>Aggressive Inlining (激进内联)</strong></h3><ul><li><strong>策略</strong>：为了提高运行效率，Cranelift 不会将 <code>struct.new</code> 编译为一次慢速的函数调用（Function Call），而是选择<strong>内联（Inline）</strong>。</li><li><strong>Fast-path</strong>：内联意味着将对象分配的完整汇编逻辑（读取空闲指针、边界检查、移动指针、写入 GC Header、填充字段）直接展开到代码中。</li><li><strong>膨胀效应</strong>：故障函数包含 <strong>5,608 次</strong> <code>struct.new</code>。每次内联展开数十条 IR 指令，导致代码体积呈爆炸式增长。</li></ul><h3 id="Globals-全局变量访问"><a href="#Globals-全局变量访问" class="headerlink" title="Globals (全局变量访问)"></a><strong>Globals (全局变量访问)</strong></h3><p>Issue 提到该模块包含 <strong>22,000+ 个全局变量</strong>。</p><ul><li><strong>global.get &#x2F; global.set</strong>：大量的全局状态访问破坏了局部的优化潜力，迫使编译器生成更多的加载&#x2F;存储指令，进一步增加了 SSA 值的数量。</li></ul><hr><h2 id="5-潜在解决方案与未来方向-Mitigation-amp-Future"><a href="#5-潜在解决方案与未来方向-Mitigation-amp-Future" class="headerlink" title="5. 潜在解决方案与未来方向 (Mitigation &amp; Future)"></a>5. 潜在解决方案与未来方向 (Mitigation &amp; Future)</h2><p>Issue 讨论中还提及了两种底层的解决思路。</p><h3 id="Winch-Baseline-Compiler"><a href="#Winch-Baseline-Compiler" class="headerlink" title="Winch (Baseline Compiler)"></a><strong>Winch (Baseline Compiler)</strong></h3><ul><li><strong>解释</strong>：Wasmtime 正在开发的基线编译器。</li><li><strong>原理</strong>：Winch 不进行复杂的 IR 构建和 SSA 优化，而是直接将 Wasm 字节码一对一地翻译为机器码。</li><li><strong>优势</strong>：由于没有繁重的 IR 分析过程，它不会遇到 VReg 数量限制，编译速度极快，且内存占用极低。</li><li><strong>现状</strong>：目前 Winch 尚未完全支持 Wasm GC 和异常处理，因此暂时无法用于 Kotlin&#x2F;Wasm。</li></ul><h3 id="Fuel-Compilation-Fuel"><a href="#Fuel-Compilation-Fuel" class="headerlink" title="Fuel (Compilation Fuel)"></a><strong>Fuel (Compilation Fuel)</strong></h3><ul><li><strong>解释</strong>：一种编译预算机制。</li><li><strong>思路</strong>：给编译器设定“燃料”限制。如果一个函数内的内联操作（如 <code>struct.new</code> 展开）消耗了过多的燃料，编译器就停止内联，转而生成普通的函数调用（Out-of-line call）。这将以牺牲部分运行时性能为代价，换取编译成功率和更小的代码体积。</li></ul><hr><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Wasmtime Issue #12229 是一个教科书式的编译器资源耗尽案例。它揭示了在 <strong>Wasm GC</strong> 时代，高级语言（Kotlin）的编译模式（单体大函数、密集对象分配）与底层编译器（Cranelift）的优化假设（激进内联、位压缩限制）之间的冲突。对于从事 Wasm 运行时集成或编译器开发的工程师而言，理解 <strong>RSS&#x2F;VSS</strong>、<strong>Signal Traps</strong>、<strong>SSA</strong> 以及 <strong>VReg</strong> 限制，是排查此类“黑盒”错误的关键。</p>]]></content>
      
      
      <categories>
          
          <category> WebAssembly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> WebAssembly </tag>
            
            <tag> WASI </tag>
            
            <tag> Wasmtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>③ Hexo QuickDepoly.sh</title>
      <link href="/2025/12/18/HEXO/03Hexo%20QuickDepoly/"/>
      <url>/2025/12/18/HEXO/03Hexo%20QuickDepoly/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sh depoly.sh</span></span><br><span class="line">cd d:\\fish\\crowforkotlin.github.io</span><br><span class="line"></span><br><span class="line">git fetch</span><br><span class="line"></span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">echo &quot;wuya.click&quot; &gt;&gt; public/CNAME</span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line">COMMIT_TIME=$(date +&quot;%Y.%m.%d %H:%M:%S %a&quot;)</span><br><span class="line">COMMIT_MESSAGE=&quot;:tada: Deploy - $COMMIT_TIME&quot;</span><br><span class="line"></span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;$COMMIT_MESSAGE&quot;</span><br><span class="line">git pull origin main --rebase</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Bash + Zsh + Powerlevel10k 集成方案 (跨平台)</title>
      <link href="/2025/12/03/Git/Zsh/"/>
      <url>/2025/12/03/Git/Zsh/</url>
      
        <content type="html"><![CDATA[<h2 id="📌-概述"><a href="#📌-概述" class="headerlink" title="📌 概述"></a>📌 概述</h2><p>本文旨在 Windows 平台上基于 Git Bash 构建一套类 Unix 的高效终端环境。通过集成 <strong>Zsh</strong> (Z Shell)、<strong>Oh My Zsh</strong> 框架及 <strong>Powerlevel10k</strong> 主题，解决原生 Git Bash 功能单一、缺乏语法高亮与自动补全等痛点，并实现跨平台（Windows&#x2F;Linux&#x2F;Android）的配置统一。</p><hr><blockquote><p>如果目标平台是<strong>windows</strong>，则需要使用<strong>gitbash</strong>，<strong>不建议用msys2作为主要的bash</strong>！因为<strong>windwos</strong>上配置的环境变量在<strong>msys2</strong>没法使用需要重新配置，容易出现一些问题。但是<strong>gitbash</strong>本身不支持一些包命令操作和一些快捷的命令，所以需要提前安装好<strong>msys2</strong>，<strong>msys2</strong>自带了<strong>pacman</strong>包管理器，可通过<code>pacman -Sy tree</code>安装tree工具等…，至于如何在<strong>gitbash上使用msys2自带的pacman</strong>就很简单了，只需要在<strong>windows</strong>上配置<strong>msys2</strong>的环境变量，可以通过这个软件<code>rapid environment.exe</code>配置，例如<code>D:\msys2\mingw64\bin</code>以及<code>D:\msys2\usr\bin</code>路径。<strong>windwos gitbash</strong>在执行以下脚本前，建议先把上述环境准备好，然后参考这篇文章</p></blockquote><ul><li><a href="https://gist.github.com/glenkusuma/7d7df65a89e485ec2f4690fdc88fffd6">github –&gt; install-zsh-windows-git-bash.md</a></li></ul><h4 id="⚙️Widnows-Gitbash-环境配置简化流程"><a href="#⚙️Widnows-Gitbash-环境配置简化流程" class="headerlink" title="⚙️Widnows Gitbash 环境配置简化流程"></a>⚙️Widnows Gitbash 环境配置简化流程</h4><ul><li><p><a href="https://packages.msys2.org/package/zsh?repo=msys&variant=x86_64">下载zsh.pkg.tar.zst 打开后继续打开会看到有文件夹等文件，解压放置Gitbash根目录，例如<code>D:\Program Files\Git</code></a></p></li><li><p>系统用户根目录创建文件<code>C:/Users/&#123;你的用户名&#125;/.bashrc</code>，另外可以额外创建一份 <code>.bash_profile</code> 并输入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Launch Zsh</span></span><br><span class="line">if [ -t 1 ]; then</span><br><span class="line">exec zsh</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="🚀-方案一：自动化部署脚本-推荐"><a href="#🚀-方案一：自动化部署脚本-推荐" class="headerlink" title="🚀 方案一：自动化部署脚本 (推荐)"></a>🚀 方案一：自动化部署脚本 (推荐)</h2><blockquote><p><strong>为简化繁琐的依赖安装与环境配置，提供以下全平台通用 Shell 脚本。该脚本支持环境检测、包管理器自动识别、Oh My Zsh 及核心插件的一键安装。</strong></p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><blockquote><p>此脚本支持 Android Mac Linux Windows</p></blockquote><ol><li>保存下方代码为 <code>install_zsh.sh</code>。</li><li>在 Git Bash 或其他平台目终端中执行：<br><code>chmod +x install_zsh.sh &amp;&amp; ./install_zsh.sh</code> 或者 <code>sh install_zsh.sh</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义颜色</span></span><br><span class="line">GREEN=<span class="string">&#x27;\033[0;32m&#x27;</span></span><br><span class="line">RED=<span class="string">&#x27;\033[0;31m&#x27;</span></span><br><span class="line">YELLOW=<span class="string">&#x27;\033[1;33m&#x27;</span></span><br><span class="line">BLUE=<span class="string">&#x27;\033[0;34m&#x27;</span></span><br><span class="line">NC=<span class="string">&#x27;\033[0m&#x27;</span> <span class="comment"># No Color</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;YELLOW&#125;</span>========================================<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;YELLOW&#125;</span>   Zsh + OMZ + QuickShell 配置脚本    <span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;YELLOW&#125;</span>========================================<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line"><span class="comment"># 0. 环境与包管理器检测</span></span><br><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line">OS_TYPE=$(<span class="built_in">uname</span> -o 2&gt;/dev/null || <span class="built_in">uname</span> -s)</span><br><span class="line">INSTALL_CMD=<span class="string">&quot;&quot;</span></span><br><span class="line">UPDATE_CMD=<span class="string">&quot;&quot;</span></span><br><span class="line">SUDO=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">detect_pm_linux_mac</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;BLUE&#125;</span>检测到 Linux/Mac 环境，请选择包管理器：<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;1) pkg (Termux)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;2) apt (Debian/Ubuntu/Kali)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;3) choco (Linux?)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;4) pacman (Arch/Manjaro)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;5) brew (macOS/Linux)&quot;</span></span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">&quot;请输入选项 [1-5]: &quot;</span> pm_choice</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$pm_choice</span> <span class="keyword">in</span></span><br><span class="line">        1) INSTALL_CMD=<span class="string">&quot;pkg install -y&quot;</span>; UPDATE_CMD=<span class="string">&quot;pkg update -y&quot;</span>;;</span><br><span class="line">        2) INSTALL_CMD=<span class="string">&quot;apt install -y&quot;</span>; UPDATE_CMD=<span class="string">&quot;apt update -y&quot;</span>; SUDO=<span class="string">&quot;sudo&quot;</span>;;</span><br><span class="line">        3) INSTALL_CMD=<span class="string">&quot;choco install -y&quot;</span>; UPDATE_CMD=<span class="string">&quot;choco upgrade all -y&quot;</span>;;</span><br><span class="line">        4) INSTALL_CMD=<span class="string">&quot;pacman -S --noconfirm&quot;</span>; UPDATE_CMD=<span class="string">&quot;pacman -Sy&quot;</span>; SUDO=<span class="string">&quot;sudo&quot;</span>;;</span><br><span class="line">        5) INSTALL_CMD=<span class="string">&quot;brew install&quot;</span>; UPDATE_CMD=<span class="string">&quot;brew update&quot;</span>;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;无效，默认 apt&quot;</span>; INSTALL_CMD=<span class="string">&quot;apt install -y&quot;</span>; UPDATE_CMD=<span class="string">&quot;apt update -y&quot;</span>; SUDO=<span class="string">&quot;sudo&quot;</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">detect_pm_windows</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;BLUE&#125;</span>检测到 Windows 环境，请选择包管理器：<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;1) choco&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;2) pacman (MSYS2)&quot;</span></span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">&quot;请输入选项 [1-2]: &quot;</span> pm_choice</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$pm_choice</span> <span class="keyword">in</span></span><br><span class="line">        1) INSTALL_CMD=<span class="string">&quot;choco install -y&quot;</span>; UPDATE_CMD=<span class="string">&quot;choco upgrade all -y&quot;</span>;;</span><br><span class="line">        2) INSTALL_CMD=<span class="string">&quot;pacman -S --noconfirm&quot;</span>; UPDATE_CMD=<span class="string">&quot;pacman -Sy&quot;</span>;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;无效，默认 choco&quot;</span>; INSTALL_CMD=<span class="string">&quot;choco install -y&quot;</span>; UPDATE_CMD=<span class="string">&quot;choco upgrade all -y&quot;</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 开始 OS 检测 ---</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$OS_TYPE</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    *Android*)</span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>-&gt; 检测到 Android 系统 (Termux)<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line">        INSTALL_CMD=<span class="string">&quot;pkg install -y&quot;</span></span><br><span class="line">        UPDATE_CMD=<span class="string">&quot;pkg update -y&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    *Msys*|*Cygwin*|*Mingw*|*Windows*)</span><br><span class="line">        detect_pm_windows</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        detect_pm_linux_mac</span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line"><span class="comment"># 1. 安装基础软件</span></span><br><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>-&gt; 正在更新源并安装 zsh, git, curl, lsd, bat, fzf...<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行更新</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="variable">$SUDO</span> <span class="variable">$UPDATE_CMD</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;执行安装命令: <span class="variable">$SUDO</span> <span class="variable">$INSTALL_CMD</span> zsh curl git lsd bat fzf&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="variable">$SUDO</span> <span class="variable">$INSTALL_CMD</span> zsh curl git lsd bat fzf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 修复点 1: 刷新命令缓存 ---</span></span><br><span class="line"><span class="comment"># 防止刚安装完 zsh，shell 缓存里还认为没有 zsh</span></span><br><span class="line"><span class="built_in">hash</span> -r 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊处理：Ubuntu 下 bat 可能叫 batcat</span></span><br><span class="line"><span class="comment"># --- 修复点 2: 兼容性写法 ---</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">command</span> -v batcat &gt; /dev/null 2&gt;&amp;1 &amp;&amp; ! <span class="built_in">command</span> -v bat &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;检测到 batcat，创建 bat 别名目录...&quot;</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p ~/.local/bin</span><br><span class="line">    <span class="built_in">ln</span> -s $(<span class="built_in">which</span> batcat) ~/.local/bin/bat</span><br><span class="line">    <span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/.local/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 Zsh 是否安装成功</span></span><br><span class="line"><span class="comment"># --- 修复点 3: 使用 &gt; /dev/null 2&gt;&amp;1 替代 &amp;&gt;，兼容 dash ---</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">command</span> -v zsh &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;RED&#125;</span>错误：Zsh 安装失败！<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;调试信息: 尝试手动运行 &#x27;zsh --version&#x27; 查看是否安装。&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line"><span class="comment"># 2. 用户交互菜单 (安装模式)</span></span><br><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;请选择安装模式：&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>1)<span class="variable">$&#123;NC&#125;</span> <span class="variable">$&#123;RED&#125;</span>全新安装<span class="variable">$&#123;NC&#125;</span> (删除旧配置)&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>2)<span class="variable">$&#123;NC&#125;</span> <span class="variable">$&#123;BLUE&#125;</span>保留配置，仅更新<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>3)<span class="variable">$&#123;NC&#125;</span> <span class="variable">$&#123;YELLOW&#125;</span>保留配置，强制重装插件<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入选项 [1-3] (其他键退出): &quot;</span> choice</span><br><span class="line"></span><br><span class="line">CLEAN_INSTALL=<span class="literal">false</span></span><br><span class="line">FORCE_RECLONE=<span class="literal">false</span></span><br><span class="line">SKIP_ZSHRC=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$choice</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    1) CLEAN_INSTALL=<span class="literal">true</span> ;;</span><br><span class="line">    2) SKIP_ZSHRC=<span class="literal">true</span>; FORCE_RECLONE=<span class="literal">false</span> ;;</span><br><span class="line">    3) SKIP_ZSHRC=<span class="literal">true</span>; FORCE_RECLONE=<span class="literal">true</span> ;;</span><br><span class="line">    *) <span class="built_in">exit</span> 1 ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line"><span class="comment"># 3. 处理配置文件 (.zshrc)</span></span><br><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line"><span class="comment"># 定义 Quick Shell 目录，适配非 Android 环境</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$OS_TYPE</span>&quot;</span> == *<span class="string">&quot;Android&quot;</span>* ]]; <span class="keyword">then</span></span><br><span class="line">    TARGET_DIR=<span class="string">&quot;/sdcard/0.file/shell&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    TARGET_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/quick_shell&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$CLEAN_INSTALL</span>&quot;</span> = <span class="literal">true</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>-&gt; 清理旧配置...<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">rm</span> -rf ~/.zshrc ~/.oh-my-zsh</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>-&gt; 创建 Quick Shell 目录: <span class="variable">$&#123;TARGET_DIR&#125;</span>...<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$TARGET_DIR</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>-&gt; 生成 ~/.zshrc...<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">cat</span> &gt; ~/.zshrc &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">export ZSH=&quot;\$HOME/.oh-my-zsh&quot;</span></span><br><span class="line"><span class="string">ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</span></span><br><span class="line"><span class="string">plugins=(git zsh-syntax-highlighting zsh-autosuggestions z extract fzf)</span></span><br><span class="line"><span class="string">source \$ZSH/oh-my-zsh.sh</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 常用别名</span></span><br><span class="line"><span class="string">alias ls=lsd</span></span><br><span class="line"><span class="string">alias ll=&#x27;lsd -l&#x27;</span></span><br><span class="line"><span class="string">alias la=&#x27;lsd -a&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Quick Shell 自动加载</span></span><br><span class="line"><span class="string">QS_DIR=&quot;$&#123;TARGET_DIR&#125;&quot;</span></span><br><span class="line"><span class="string">if [ -d &quot;\$QS_DIR&quot; ]; then</span></span><br><span class="line"><span class="string">    for script in &quot;\$QS_DIR&quot;/*; do</span></span><br><span class="line"><span class="string">        if [ -f &quot;\$script&quot; ]; then</span></span><br><span class="line"><span class="string">            filename=\$(basename &quot;\$script&quot;)</span></span><br><span class="line"><span class="string">            alias_name=&quot;\$&#123;filename%.*&#125;&quot;</span></span><br><span class="line"><span class="string">            alias &quot;\$alias_name&quot;=&quot;bash &#x27;\$script&#x27;&quot;</span></span><br><span class="line"><span class="string">        fi</span></span><br><span class="line"><span class="string">    done</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;BLUE&#125;</span>-&gt; 跳过 .zshrc 生成。<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line"><span class="comment"># 4. 安装/更新 Oh My Zsh &amp; 插件</span></span><br><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>-&gt; 处理 Oh My Zsh...<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> RUNZSH=no</span><br><span class="line"><span class="built_in">export</span> KEEP_ZSHRC=<span class="built_in">yes</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">ZSH_CUSTOM=<span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_plugin</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> url=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> path=<span class="variable">$2</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$path</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$FORCE_RECLONE</span>&quot;</span> = <span class="literal">true</span> ] || [ <span class="string">&quot;<span class="variable">$CLEAN_INSTALL</span>&quot;</span> = <span class="literal">true</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$path</span>&quot;</span></span><br><span class="line">            git <span class="built_in">clone</span> --depth=1 <span class="string">&quot;<span class="variable">$url</span>&quot;</span> <span class="string">&quot;<span class="variable">$path</span>&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            git -C <span class="string">&quot;<span class="variable">$path</span>&quot;</span> pull || <span class="built_in">echo</span> <span class="string">&quot;更新失败&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        git <span class="built_in">clone</span> --depth=1 <span class="string">&quot;<span class="variable">$url</span>&quot;</span> <span class="string">&quot;<span class="variable">$path</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_plugin <span class="string">&quot;https://github.com/romkatv/powerlevel10k.git&quot;</span> <span class="string">&quot;<span class="variable">$&#123;ZSH_CUSTOM&#125;</span>/themes/powerlevel10k&quot;</span></span><br><span class="line">install_plugin <span class="string">&quot;https://github.com/zsh-users/zsh-syntax-highlighting&quot;</span> <span class="string">&quot;<span class="variable">$&#123;ZSH_CUSTOM&#125;</span>/plugins/zsh-syntax-highlighting&quot;</span></span><br><span class="line">install_plugin <span class="string">&quot;https://github.com/zsh-users/zsh-autosuggestions&quot;</span> <span class="string">&quot;<span class="variable">$&#123;ZSH_CUSTOM&#125;</span>/plugins/zsh-autosuggestions&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line"><span class="comment"># 5. 结尾</span></span><br><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>-&gt; 设置默认 Shell...<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$OS_TYPE</span>&quot;</span> == *<span class="string">&quot;Android&quot;</span>* ]]; <span class="keyword">then</span></span><br><span class="line">    chsh -s zsh</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># Linux 上尝试自动切换，如果失败提示手动</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">which</span> zsh &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        chsh -s $(<span class="built_in">which</span> zsh) || <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;YELLOW&#125;</span>提示：可能需要手动输入密码或运行: chsh -s <span class="subst">$(which zsh)</span><span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>安装完成！Quick Shell 目录: <span class="variable">$&#123;TARGET_DIR&#125;</span><span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">exec</span> zsh -l</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🛠️-方案二：手动分步部署-Windows-Git-Bash"><a href="#🛠️-方案二：手动分步部署-Windows-Git-Bash" class="headerlink" title="🛠️ 方案二：手动分步部署 (Windows Git Bash)"></a>🛠️ 方案二：手动分步部署 (Windows Git Bash)</h2><p>若需深入控制安装细节，可按以下步骤手动配置。</p><h3 id="1-前置环境准备"><a href="#1-前置环境准备" class="headerlink" title="1. 前置环境准备"></a>1. 前置环境准备</h3><table><thead><tr><th align="left">组件</th><th align="left">作用</th><th align="left">获取&#x2F;配置方式</th></tr></thead><tbody><tr><td align="left"><strong>Git Bash</strong></td><td align="left">提供基础 Bash 环境</td><td align="left"><a href="https://git-scm.com/download/win">Git for Windows 官网</a></td></tr><tr><td align="left"><strong>MSYS2</strong></td><td align="left">提供 Pacman 包管理</td><td align="left"><a href="https://www.msys2.org/">MSYS2 官网</a></td></tr><tr><td align="left"><strong>环境变量</strong></td><td align="left">联通 Git Bash 与 MSYS2</td><td align="left">将 MSYS2 的 <code>\usr\bin</code> 和 <code>\mingw64\bin</code> 加入 Windows PATH</td></tr></tbody></table><blockquote><p><strong>注意</strong>：配置环境变量后，Git Bash 才能直接识别 <code>pacman</code>、<code>zsh</code> 等命令。</p></blockquote><h3 id="2-核心组件安装"><a href="#2-核心组件安装" class="headerlink" title="2. 核心组件安装"></a>2. 核心组件安装</h3><p>在配置好 PATH 的 Git Bash 中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 更新包管理器源</span></span><br><span class="line">pacman -Syu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 安装 Zsh 及常用工具 (curl, git, fzf, bat)</span></span><br><span class="line">pacman -S zsh curl git fzf bat</span><br></pre></td></tr></table></figure><h3 id="3-部署-Oh-My-Zsh-框架"><a href="#3-部署-Oh-My-Zsh-框架" class="headerlink" title="3. 部署 Oh My Zsh 框架"></a>3. 部署 Oh My Zsh 框架</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 curl 安装</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-安装核心插件"><a href="#4-安装核心插件" class="headerlink" title="4. 安装核心插件"></a>4. 安装核心插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Powerlevel10k 主题</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://github.com/romkatv/powerlevel10k.git&quot;</span> <span class="string">&quot;<span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 语法高亮 (Syntax Highlighting)</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://github.com/zsh-users/zsh-syntax-highlighting&quot;</span> <span class="string">&quot;<span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 自动建议补全 (Autosuggestions)</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://github.com/zsh-users/zsh-autosuggestions&quot;</span> <span class="string">&quot;<span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="cc-配置文件详解"><a href="#cc-配置文件详解" class="headerlink" title="cc 配置文件详解"></a>cc 配置文件详解</h2><p>需要修改两个核心文件以完成环境集成。</p><h3 id="1-bash-profile-入口引导"><a href="#1-bash-profile-入口引导" class="headerlink" title="1. ~/.bash_profile (入口引导)"></a>1. <code>~/.bash_profile</code> (入口引导)</h3><p>此配置用于在打开 Git Bash 时自动切换至 Zsh 环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载 .bashrc (如果存在)</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若为交互式 Shell，则切换至 Zsh</span></span><br><span class="line"><span class="keyword">if</span> [ -t 1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> SHELL=/usr/bin/zsh</span><br><span class="line">    <span class="built_in">exec</span> /usr/bin/zsh</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="2-zshrc-核心配置"><a href="#2-zshrc-核心配置" class="headerlink" title="2. ~/.zshrc (核心配置)"></a>2. <code>~/.zshrc</code> (核心配置)</h3><p>集成环境修复、插件管理及网络代理功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- Powerlevel10k 瞬时提示符 (必须置顶) ---</span></span><br><span class="line"><span class="keyword">if</span> [[ -r <span class="string">&quot;<span class="variable">$&#123;XDG_CACHE_HOME:-<span class="variable">$HOME</span>/.cache&#125;</span>/p10k-instant-prompt-<span class="variable">$&#123;(%):-%n&#125;</span>.zsh&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">source</span> <span class="string">&quot;<span class="variable">$&#123;XDG_CACHE_HOME:-<span class="variable">$HOME</span>/.cache&#125;</span>/p10k-instant-prompt-<span class="variable">$&#123;(%):-%n&#125;</span>.zsh&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1. 环境路径修复 (Fix for MSYS2 &amp; Git Bash) ---</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/mingw64/bin:/usr/bin</span><br><span class="line"><span class="comment"># 解决 Java/Gradle 等输出乱码问题</span></span><br><span class="line"><span class="built_in">export</span> JAVA_TOOL_OPTIONS=<span class="string">&quot;-Duser.language=en -Duser.country=US&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 2. Zsh 核心设置 ---</span></span><br><span class="line"><span class="built_in">export</span> ZSH=<span class="string">&quot;<span class="variable">$HOME</span>/.oh-my-zsh&quot;</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 3. 插件加载 ---</span></span><br><span class="line">plugins=(</span><br><span class="line">git                 <span class="comment"># Git 缩写</span></span><br><span class="line">zsh-syntax-highlighting <span class="comment"># 语法高亮</span></span><br><span class="line">zsh-autosuggestions <span class="comment"># 自动建议</span></span><br><span class="line">z                   <span class="comment"># 目录跳转</span></span><br><span class="line">extract             <span class="comment"># 智能解压</span></span><br><span class="line">fzf                 <span class="comment"># 模糊搜索</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 4. 网络代理函数 ---</span></span><br><span class="line"><span class="comment"># 开启代理: setproxy | 关闭代理: unsetproxy</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">setproxy</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> PROXY_HOST=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    <span class="built_in">local</span> PROXY_PORT=<span class="string">&quot;7890&quot;</span> <span class="comment"># 按需修改端口</span></span><br><span class="line">    <span class="built_in">local</span> PROXY_URL=<span class="string">&quot;http://<span class="variable">$&#123;PROXY_HOST&#125;</span>:<span class="variable">$&#123;PROXY_PORT&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">export</span> http_proxy=<span class="string">&quot;<span class="variable">$&#123;PROXY_URL&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">export</span> https_proxy=<span class="string">&quot;<span class="variable">$&#123;PROXY_URL&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">export</span> all_proxy=<span class="string">&quot;socks5://<span class="variable">$&#123;PROXY_HOST&#125;</span>:<span class="variable">$&#123;PROXY_PORT&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 同步设置 Git 代理</span></span><br><span class="line">    git config --global http.proxy <span class="string">&quot;<span class="variable">$&#123;PROXY_URL&#125;</span>&quot;</span></span><br><span class="line">    git config --global https.proxy <span class="string">&quot;<span class="variable">$&#123;PROXY_URL&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;✅ Proxy Enabled: <span class="variable">$&#123;PROXY_URL&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">unsetproxy</span></span>() &#123;</span><br><span class="line">    <span class="built_in">unset</span> http_proxy https_proxy all_proxy</span><br><span class="line">    git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">    git config --global --<span class="built_in">unset</span> https.proxy</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;❌ Proxy Disabled&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 5. 个性化配置加载 ---</span></span><br><span class="line">[[ ! -f ~/.p10k.zsh ]] || <span class="built_in">source</span> ~/.p10k.zsh</span><br><span class="line">[ -f ~/.fzf.zsh ] &amp;&amp; <span class="built_in">source</span> ~/.fzf.zsh</span><br></pre></td></tr></table></figure><hr><h2 id="💻-开发环境集成"><a href="#💻-开发环境集成" class="headerlink" title="💻 开发环境集成"></a>💻 开发环境集成</h2><h3 id="IDE-集成-IntelliJ-IDEA-x2F-VSCode"><a href="#IDE-集成-IntelliJ-IDEA-x2F-VSCode" class="headerlink" title="IDE 集成 (IntelliJ IDEA &#x2F; VSCode)"></a>IDE 集成 (IntelliJ IDEA &#x2F; VSCode)</h3><p>为确保 IDE 内置终端正确加载 Zsh 配置，需修改 Shell 启动参数。</p><ul><li><strong>Shell path:</strong> <code>&quot;D:\Program Files\Git\bin\bash.exe&quot;</code> (根据实际安装路径调整)</li><li><strong>Arguments:</strong> <code>-l -c zsh</code><ul><li><code>-l</code> (login): 强制作为登录 Shell 启动，确保加载 Profile。</li><li><code>-c zsh</code>: 直接执行 zsh 命令。</li></ul></li></ul><h3 id="脚本集成-bat-启动"><a href="#脚本集成-bat-启动" class="headerlink" title="脚本集成 (.bat 启动)"></a>脚本集成 (.bat 启动)</h3><p>若需通过 Windows 批处理脚本调用 Zsh 环境执行任务（如启动服务脚本）：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> GIT_BASH_EXE=&quot;D:\Program Files\Git\bin\bash.exe&quot;</span><br><span class="line"><span class="built_in">set</span> START_SCRIPT=&quot;gitlab-<span class="built_in">start</span>.sh&quot;</span><br><span class="line"></span><br><span class="line">:: 启动 Bash -&gt; 切换 Zsh -&gt; 执行脚本 -&gt; 退出</span><br><span class="line"><span class="built_in">start</span> &quot;&quot; <span class="variable">%GIT_BASH_EXE%</span> -c &quot;/usr/bin/zsh -i -c &#x27;source <span class="variable">%START_SCRIPT%</span> &amp;&amp; <span class="keyword">exit</span>&#x27;&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="📱-附录：Android-Termux-配置"><a href="#📱-附录：Android-Termux-配置" class="headerlink" title="📱 附录：Android Termux 配置"></a>📱 附录：Android Termux 配置</h2><p>Termux 环境配置相对精简，主要差异在于路径与别名。</p><p><strong><code>~/.zshrc</code> (Termux 精简版):</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ZSH=<span class="string">&quot;<span class="variable">$HOME</span>/.oh-my-zsh&quot;</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span></span><br><span class="line"></span><br><span class="line">plugins=(git zsh-syntax-highlighting zsh-autosuggestions z extract fzf)</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐使用 lsd 替代 ls</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=lsd</span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;lsd -l&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li><a href="https://github.com/crowforkotlin/QuickShell">快速部署脚本仓库</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
          <category> Config </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Zsh </tag>
            
            <tag> Powerlevel10k </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android JNI 嵌入 Wasmtime：从 SIGILL 崩溃到稳定运行配置与日志重定向</title>
      <link href="/2025/11/27/Wasm/Android%E4%BD%BF%E7%94%A8JNI%E5%B5%8C%E5%85%A5Wasmtime/"/>
      <url>/2025/11/27/Wasm/Android%E4%BD%BF%E7%94%A8JNI%E5%B5%8C%E5%85%A5Wasmtime/</url>
      
        <content type="html"><![CDATA[<h3 id="第一部分：问题复盘与解决方案-From-Zero-to-Hero"><a href="#第一部分：问题复盘与解决方案-From-Zero-to-Hero" class="headerlink" title="第一部分：问题复盘与解决方案 (From Zero to Hero)"></a>第一部分：问题复盘与解决方案 (From Zero to Hero)</h3><p>我们按时间线梳理了遇到的 3 个核心问题：</p><h4 id="1-Libc-SIGILL-Fatal-signal-4-崩溃"><a href="#1-Libc-SIGILL-Fatal-signal-4-崩溃" class="headerlink" title="1. Libc SIGILL (Fatal signal 4) 崩溃"></a>1. <strong>Libc SIGILL (Fatal signal 4) 崩溃</strong></h4><ul><li><strong>现象</strong>：App 刚运行到函数调用就闪退，报错 <code>ILL_ILLOPC</code> (非法指令)。</li><li><strong>原因</strong>：<ul><li><strong>信号冲突</strong>：Wasmtime 默认使用系统信号 (SIGBUS&#x2F;SIGSEGV) 来处理内存越界，这与 Android 的 ART 虚拟机信号处理冲突。</li><li><strong>JIT 激进优化</strong>：默认生成的 ARM64 机器码可能包含你手机 CPU 不支持的指令（如 SIMD 或 BTI）。</li></ul></li><li><strong>解决方案</strong>：<ul><li><code>signals_based_traps = false</code>：<strong>关键修复</strong>，强制使用显式的 <code>if</code> 判断做边界检查，不依赖系统信号。</li><li><code>opt_level = NONE</code>：关闭优化，生成最保守的代码。</li><li><code>simd = false</code>：关闭向量指令，保证兼容性。</li></ul></li></ul><h4 id="2-Wasm-Trap-null-reference"><a href="#2-Wasm-Trap-null-reference" class="headerlink" title="2. Wasm Trap: null reference"></a>2. <strong>Wasm Trap: null reference</strong></h4><ul><li><strong>现象</strong>：不闪退了，但报错 <code>Trap</code>，提示空指针。</li><li><strong>原因</strong>：<strong>Kotlin 运行时未初始化</strong>。Wasm 模块只是加载了，但 Kotlin 的 GC 和内存分配器还没启动。CLI 会自动运行 <code>_start</code>，但嵌入式 API 需要手动调用。</li><li><strong>解决方案</strong>：<ul><li>在调用 <code>add</code> 之前，手动查找并调用 <code>_initialize</code> (Reactor模式) 或 <code>_start</code> (Command模式)。</li></ul></li></ul><h4 id="3-看不到-println-日志"><a href="#3-看不到-println-日志" class="headerlink" title="3. 看不到 println 日志"></a>3. <strong>看不到 <code>println</code> 日志</strong></h4><ul><li><strong>现象</strong>：运行成功返回 <code>3</code>，但 Logcat 空空如也。</li><li><strong>原因</strong>：WASI 的标准输出 (stdout) 默认指向 <code>/dev/null</code>。</li><li><strong>解决方案</strong>：<ul><li>使用 <code>wasi_config_set_stdout_custom</code> 注册回调函数，将 stdout 数据流“偷”出来，通过 <code>__android_log_print</code> 转发给 Logcat。</li></ul></li></ul><hr><h3 id="第二部分：配置影响分析-Trade-offs"><a href="#第二部分：配置影响分析-Trade-offs" class="headerlink" title="第二部分：配置影响分析 (Trade-offs)"></a>第二部分：配置影响分析 (Trade-offs)</h3><p>为了修复 <code>SIGILL</code> 和崩溃，我们使用了一些“保守”的配置。以下是这些修改带来的具体影响：</p><h4 id="1-关闭信号陷阱-signals-based-traps-false"><a href="#1-关闭信号陷阱-signals-based-traps-false" class="headerlink" title="1. 关闭信号陷阱 (signals_based_traps = false)"></a>1. 关闭信号陷阱 (<code>signals_based_traps = false</code>)</h4><ul><li><strong>影响</strong>：<strong>性能略微下降，但稳定性极大提升。</strong></li><li><strong>解释</strong>：<ul><li><em>默认模式</em>：Wasmtime 假定内存访问是安全的，不做检查。如果越界，依靠操作系统抛出信号 (Hardware Trap) 来捕获。这很快，但在 Android 这种对信号管控严格的环境极易崩溃。</li><li><em>当前模式</em>：Wasmtime 会在每一条涉及内存读写的指令前，插入一段汇编代码（类似 <code>if (addr &gt; max) throw error</code>）。这增加了 CPU 指令数量，但确保了<strong>绝对安全</strong>，不会导致 App 闪退，只会返回可捕获的 Trap 错误。</li></ul></li></ul><h4 id="2-关闭优化-opt-level-NONE"><a href="#2-关闭优化-opt-level-NONE" class="headerlink" title="2. 关闭优化 (opt_level = NONE)"></a>2. 关闭优化 (<code>opt_level = NONE</code>)</h4><ul><li><strong>影响</strong>：<strong>JIT 编译速度变快，但 Wasm 执行速度变慢。</strong></li><li><strong>解释</strong>：编译器不再花时间做循环展开、寄存器分配优化等高级操作。对于 <code>add</code> 这种简单函数没感觉，但如果是复杂的算法（如图像处理），性能可能会比开启优化慢 2-5 倍。</li><li><strong>未来优化</strong>：等环境稳定后，可以尝试改回 <code>WASMTIME_OPT_LEVEL_SPEED</code>，只要保留 <code>signals_based_traps = false</code>，或许能跑通的。</li></ul><h4 id="3-关闭-SIMD-simd-false"><a href="#3-关闭-SIMD-simd-false" class="headerlink" title="3. 关闭 SIMD (simd = false)"></a>3. 关闭 SIMD (<code>simd = false</code>)</h4><ul><li><strong>影响</strong>：<strong>无法利用硬件加速进行并行计算。</strong></li><li><strong>解释</strong>：如果你的 Wasm 模块（比如图像滤镜、加密库）大量使用了向量指令，关闭此选项会导致模块加载失败或回退到标量计算（变慢）。但对于业务逻辑（如 Kotlin UI、数据处理），几乎没有影响。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当前的配置是 <strong>“兼容性优先 (Stability First)”</strong> 的方案。它牺牲了一点点运行时性能，换取了在各种 Android 机型（无论新旧 CPU、无论系统信号机制如何）上都能<strong>不闪退、稳定运行</strong>的保障。对于初期集成和调试来说，这是最完美的起步点。</p><h3 id="第三部分：优化后的完整-C-代码"><a href="#第三部分：优化后的完整-C-代码" class="headerlink" title="第三部分：优化后的完整 C++ 代码"></a>第三部分：优化后的完整 C++ 代码</h3><p>我对代码进行了重构，特点如下：</p><ol><li><strong>增加配置开关</strong>：JNI 函数增加 <code>jboolean enableLogs</code> 参数，由 Kotlin 控制是否开启日志转发。</li><li><strong>结构清晰</strong>：将配置、初始化、调用分块注释。</li><li><strong>内存安全</strong>：确保所有 JNI 资源和 Wasm 对象都被正确释放。</li></ol><h4 id="1-修改-Kotlin-定义-MainActivity-kt"><a href="#1-修改-Kotlin-定义-MainActivity-kt" class="headerlink" title="1. 修改 Kotlin 定义 (MainActivity.kt)"></a>1. 修改 Kotlin 定义 (MainActivity.kt)</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加一个 boolean 参数控制日志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">runWasmAdd</span><span class="params">(wasmBytes: <span class="type">ByteArray</span>, enableLogs: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时</span></span><br><span class="line">runWasmAdd(wasmBytes, <span class="literal">true</span>) <span class="comment">// 开启日志</span></span><br></pre></td></tr></table></figure><h4 id="2-C-实现-wasm-host-cpp"><a href="#2-C-实现-wasm-host-cpp" class="headerlink" title="2. C++ 实现 (wasm_host.cpp)"></a>2. C++ 实现 (wasm_host.cpp)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wasmtime Headers</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wasm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wasi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wasmtime.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAG <span class="string">&quot;KotlinWasm&quot;</span></span></span><br><span class="line"><span class="comment">// 简化的日志宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="comment">// 工具函数：错误打印</span></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log_and_exit_error</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message, <span class="type">wasmtime_error_t</span> *error, <span class="type">wasm_trap_t</span> *trap)</span> </span>&#123;</span><br><span class="line">    <span class="type">wasm_byte_vec_t</span> error_message;</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">wasmtime_error_message</span>(error, &amp;error_message);</span><br><span class="line">        <span class="built_in">wasmtime_error_delete</span>(error);</span><br><span class="line">        <span class="built_in">LOGE</span>(<span class="string">&quot;ERROR: %s -&gt; %.*s&quot;</span>, message, (<span class="type">int</span>)error_message.size, error_message.data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (trap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">wasm_trap_message</span>(trap, &amp;error_message);</span><br><span class="line">        <span class="built_in">wasm_trap_delete</span>(trap);</span><br><span class="line">        <span class="built_in">LOGE</span>(<span class="string">&quot;TRAP: %s -&gt; %.*s&quot;</span>, message, (<span class="type">int</span>)error_message.size, error_message.data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOGE</span>(<span class="string">&quot;UNKNOWN ERROR: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error || trap) <span class="built_in">wasm_byte_vec_delete</span>(&amp;error_message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="comment">// 回调函数：WASI stdout -&gt; Android Logcat</span></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="function"><span class="type">ptrdiff_t</span> <span class="title">android_log_callback</span><span class="params">(<span class="type">void</span>* data, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* buffer, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 构造字符串并移除末尾换行符（Logcat 自带换行）</span></span><br><span class="line">    <span class="function">std::string <span class="title">msg</span><span class="params">((<span class="type">const</span> <span class="type">char</span>*)buffer, size)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!msg.<span class="built_in">empty</span>() &amp;&amp; (msg.<span class="built_in">back</span>() == <span class="string">&#x27;\n&#x27;</span> || msg.<span class="built_in">back</span>() == <span class="string">&#x27;\r&#x27;</span>)) &#123;</span><br><span class="line">        msg.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!msg.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        __android_log_print(ANDROID_LOG_INFO, TAG, <span class="string">&quot;[WasmOut] %s&quot;</span>, msg.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="comment">// JNI 主入口</span></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT jint JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_crow_wasmedge_wasmline_MainActivity_runWasmAdd</span><span class="params">(JNIEnv *env, jobject thiz, jbyteArray wasmBytes, jboolean enableLogs)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --- 1. 获取 Wasm 字节数据 ---</span></span><br><span class="line">    jsize len = env-&gt;<span class="built_in">GetArrayLength</span>(wasmBytes);</span><br><span class="line">    jbyte *bytes = env-&gt;<span class="built_in">GetByteArrayElements</span>(wasmBytes, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!bytes) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 2. 配置 Wasmtime (The Silver Bullet Config) ---</span></span><br><span class="line">    <span class="type">wasm_config_t</span> *config = <span class="built_in">wasm_config_new</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启 Kotlin 所需特性</span></span><br><span class="line">    <span class="built_in">wasmtime_config_wasm_gc_set</span>(config, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">wasmtime_config_wasm_function_references_set</span>(config, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">wasmtime_config_wasm_exceptions_set</span>(config, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决 Android SIGILL 崩溃的核心配置</span></span><br><span class="line">    <span class="built_in">wasmtime_config_cranelift_opt_level_set</span>(config, WASMTIME_OPT_LEVEL_NONE); <span class="comment">// 关闭优化</span></span><br><span class="line">    <span class="built_in">wasmtime_config_wasm_simd_set</span>(config, <span class="literal">false</span>);         <span class="comment">// 关闭 SIMD</span></span><br><span class="line">    <span class="built_in">wasmtime_config_wasm_relaxed_simd_set</span>(config, <span class="literal">false</span>); <span class="comment">// 关闭 Relaxed SIMD</span></span><br><span class="line">    <span class="built_in">wasmtime_config_signals_based_traps_set</span>(config, <span class="literal">false</span>); <span class="comment">// 关闭信号 Trap，改用显式检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 3. 创建 Engine &amp; Store ---</span></span><br><span class="line">    <span class="type">wasm_engine_t</span> *engine = <span class="built_in">wasm_engine_new_with_config</span>(config);</span><br><span class="line">    <span class="keyword">if</span> (!engine) &#123;</span><br><span class="line">        env-&gt;<span class="built_in">ReleaseByteArrayElements</span>(wasmBytes, bytes, JNI_ABORT);</span><br><span class="line">        <span class="built_in">LOGE</span>(<span class="string">&quot;Failed to create engine&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">wasmtime_store_t</span> *store = <span class="built_in">wasmtime_store_new</span>(engine, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">wasmtime_context_t</span> *context = <span class="built_in">wasmtime_store_context</span>(store);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 4. 配置 WASI (含日志重定向) ---</span></span><br><span class="line">    <span class="type">wasi_config_t</span> *wasi_config = <span class="built_in">wasi_config_new</span>();</span><br><span class="line">    <span class="built_in">wasi_config_inherit_argv</span>(wasi_config);</span><br><span class="line">    <span class="built_in">wasi_config_inherit_env</span>(wasi_config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableLogs) &#123;</span><br><span class="line">        <span class="comment">// 如果启用，挂载回调函数</span></span><br><span class="line">        <span class="built_in">wasi_config_set_stdout_custom</span>(wasi_config, android_log_callback, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">wasi_config_set_stderr_custom</span>(wasi_config, android_log_callback, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">wasmtime_error_t</span> *error = <span class="built_in">wasmtime_context_set_wasi</span>(context, wasi_config);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">log_and_exit_error</span>(<span class="string">&quot;WASI Config Error&quot;</span>, error, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 5. 编译与实例化 ---</span></span><br><span class="line">    <span class="type">wasmtime_linker_t</span> *linker = <span class="built_in">wasmtime_linker_new</span>(engine);</span><br><span class="line">    <span class="built_in">wasmtime_linker_define_wasi</span>(linker);</span><br><span class="line"></span><br><span class="line">    <span class="type">wasmtime_module_t</span> *<span class="keyword">module</span> = <span class="literal">nullptr</span>;</span><br><span class="line">    error = <span class="built_in">wasmtime_module_new</span>(engine, (<span class="type">uint8_t</span> *)bytes, len, &amp;<span class="keyword">module</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放 Java 数组，节省内存</span></span><br><span class="line">    env-&gt;<span class="built_in">ReleaseByteArrayElements</span>(wasmBytes, bytes, JNI_ABORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">log_and_exit_error</span>(<span class="string">&quot;Compile Error&quot;</span>, error, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">wasmtime_instance_t</span> instance;</span><br><span class="line">    <span class="type">wasm_trap_t</span> *trap = <span class="literal">nullptr</span>;</span><br><span class="line">    error = <span class="built_in">wasmtime_linker_instantiate</span>(linker, context, <span class="keyword">module</span>, &amp;instance, &amp;trap);</span><br><span class="line">    <span class="keyword">if</span> (error || trap) &#123;</span><br><span class="line">        <span class="built_in">log_and_exit_error</span>(<span class="string">&quot;Instantiate Error&quot;</span>, error, trap);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 6. 核心步骤：初始化 Kotlin 运行时 (_initialize / _start) ---</span></span><br><span class="line">    <span class="comment">// 这是解决 null reference 的关键</span></span><br><span class="line">    <span class="type">wasmtime_extern_t</span> init_extern;</span><br><span class="line">    <span class="type">wasmtime_func_t</span> init_func;</span><br><span class="line">    <span class="type">bool</span> needs_init = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">wasmtime_instance_export_get</span>(context, &amp;instance, <span class="string">&quot;_initialize&quot;</span>, <span class="number">11</span>, &amp;init_extern) &amp;&amp;</span><br><span class="line">        init_extern.kind == WASM_EXTERN_FUNC) &#123;</span><br><span class="line">        init_func = init_extern.of.func;</span><br><span class="line">        needs_init = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">wasmtime_instance_export_get</span>(context, &amp;instance, <span class="string">&quot;_start&quot;</span>, <span class="number">6</span>, &amp;init_extern) &amp;&amp;</span><br><span class="line">             init_extern.kind == WASM_EXTERN_FUNC) &#123;</span><br><span class="line">        init_func = init_extern.of.func;</span><br><span class="line">        needs_init = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needs_init) &#123;</span><br><span class="line">        error = <span class="built_in">wasmtime_func_call</span>(context, &amp;init_func, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, &amp;trap);</span><br><span class="line">        <span class="keyword">if</span> (error || trap) &#123;</span><br><span class="line">             <span class="comment">// _start 可能会因为 exit(0) 而 trap，这里简单处理，如果是严重错误才退出</span></span><br><span class="line">             <span class="comment">// 实际生产中可能需要检查 trap message 是否包含 &quot;exit&quot;</span></span><br><span class="line">            <span class="built_in">log_and_exit_error</span>(<span class="string">&quot;Runtime Init Error (Ignorable if exit code 0)&quot;</span>, error, trap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 7. 调用目标函数 (add) ---</span></span><br><span class="line">    <span class="type">int32_t</span> result_val = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">wasmtime_extern_t</span> run_extern;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">wasmtime_instance_export_get</span>(context, &amp;instance, <span class="string">&quot;add&quot;</span>, <span class="number">3</span>, &amp;run_extern) &amp;&amp;</span><br><span class="line">        run_extern.kind == WASM_EXTERN_FUNC) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">wasmtime_func_t</span> func_obj = run_extern.of.func;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 参数：1, 2</span></span><br><span class="line">        <span class="type">wasmtime_val_t</span> args[<span class="number">2</span>];</span><br><span class="line">        args[<span class="number">0</span>].kind = WASMTIME_I32; args[<span class="number">0</span>].of.i32 = <span class="number">1</span>;</span><br><span class="line">        args[<span class="number">1</span>].kind = WASMTIME_I32; args[<span class="number">1</span>].of.i32 = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">wasmtime_val_t</span> results[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        error = <span class="built_in">wasmtime_func_call</span>(context, &amp;func_obj, args, <span class="number">2</span>, results, <span class="number">1</span>, &amp;trap);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (error || trap) &#123;</span><br><span class="line">            <span class="built_in">log_and_exit_error</span>(<span class="string">&quot;Function Call Error&quot;</span>, error, trap);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (results[<span class="number">0</span>].kind == WASMTIME_I32) &#123;</span><br><span class="line">                result_val = results[<span class="number">0</span>].of.i32;</span><br><span class="line">                <span class="keyword">if</span> (enableLogs) <span class="built_in">LOGD</span>(<span class="string">&quot;Success! Result: %d&quot;</span>, result_val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOGE</span>(<span class="string">&quot;Export &#x27;add&#x27; not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 8. 清理资源 ---</span></span><br><span class="line">    <span class="built_in">wasmtime_module_delete</span>(<span class="keyword">module</span>);</span><br><span class="line">    <span class="built_in">wasmtime_linker_delete</span>(linker);</span><br><span class="line">    <span class="built_in">wasmtime_store_delete</span>(store);</span><br><span class="line">    <span class="built_in">wasm_engine_delete</span>(engine);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WebAssembly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> WebAssembly </tag>
            
            <tag> WASI </tag>
            
            <tag> Wasmtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wasm/WASI 的本质区别与宿主运行时生命周期认识</title>
      <link href="/2025/11/25/Wasm/Wasm%E5%92%8CWasi%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E5%BA%86/"/>
      <url>/2025/11/25/Wasm/Wasm%E5%92%8CWasi%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E5%BA%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>摘要</strong>：在构建基于 WebAssembly (Wasm) 的插件系统时，我们常被“编译一次，到处运行”的口号误导。实战证明，当我们将 <strong>Kotlin&#x2F;Wasm</strong> 编译的模块嵌入到 <strong>C 语言宿主 (WasmEdge)</strong> 时，会遭遇一系列从“链接失败”到“运行时崩溃”的挑战。</p><p>本文将从架构视角复盘这一调试路径，揭示 Wasm 生态中 <strong>指令集 (Instruction Set)</strong> 与 <strong>系统接口 (System Interface)</strong> 的本质区别，并总结宿主运行时必须承担的初始化责任。</p></blockquote><hr><h2 id="1-核心概念重构：大脑与神经的博弈"><a href="#1-核心概念重构：大脑与神经的博弈" class="headerlink" title="1. 核心概念重构：大脑与神经的博弈"></a>1. 核心概念重构：大脑与神经的博弈</h2><p>在解决具体报错之前，我们需要重构对 <strong>Wasm</strong> 和 <strong>WASI</strong> 的认知。这两者往往被混为一谈，却是导致集成失败的根源。</p><h3 id="1-1-Wasm：被切断感官的大脑-The-Brain"><a href="#1-1-Wasm：被切断感官的大脑-The-Brain" class="headerlink" title="1.1 Wasm：被切断感官的大脑 (The Brain)"></a>1.1 Wasm：被切断感官的大脑 (The Brain)</h3><p><strong>WebAssembly (Wasm)</strong> 定义的是一种<strong>计算标准</strong>。它规定了代码如何被翻译成二进制指令（堆栈操作、算术运算、内存读写）。</p><ul><li><strong>本质</strong>：一个纯粹的计算引擎。</li><li><strong>局限</strong>：它像一个被切断了感官的大脑，拥有极高的智商，但<strong>没有嘴巴（无法打印）</strong>，<strong>没有耳朵（无法读取输入）</strong>，也<strong>没有手（无法操作文件）</strong>。</li></ul><h3 id="1-2-WASI：标准化的神经接口-The-Interface"><a href="#1-2-WASI：标准化的神经接口-The-Interface" class="headerlink" title="1.2 WASI：标准化的神经接口 (The Interface)"></a>1.2 WASI：标准化的神经接口 (The Interface)</h3><p><strong>WASI (WebAssembly System Interface)</strong> 是一套标准化的<strong>神经接口协议</strong>。它填补了 Wasm 与外界交互的空白。</p><ul><li><strong>本质</strong>：操作系统能力的抽象层。</li><li><strong>功能</strong>：定义了如 <code>fd_write</code> (输出)、<code>clock_time_get</code> (时间)、<code>random_get</code> (随机数) 等标准接口。</li></ul><blockquote><p><strong>🗝️ 核心洞察</strong></p><ul><li><strong>Wasm</strong> 决定了<strong>怎么算</strong>（计算逻辑）。</li><li><strong>WASI</strong> 决定了<strong>怎么交互</strong>（I&#x2F;O 能力）。</li></ul></blockquote><hr><h2 id="2-第一关：编译目标的契约失配"><a href="#2-第一关：编译目标的契约失配" class="headerlink" title="2. 第一关：编译目标的契约失配"></a>2. 第一关：编译目标的契约失配</h2><h3 id="2-1-🚨-问题现象"><a href="#2-1-🚨-问题现象" class="headerlink" title="2.1 🚨 问题现象"></a>2.1 🚨 问题现象</h3><p>在使用 Kotlin 编写 Wasm 插件时，初次尝试选择了 <code>wasmJs</code> 编译目标，代码中仅包含简单的 <code>println</code>。C 语言宿主加载该 <code>.wasm</code> 文件时，报错如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[error] instantiation failed: unknown import, module: &quot;js_code&quot;, function: &quot;kotlin.captureStackTrace&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-🔍-深度分析：高级语言的“环境陷阱”"><a href="#2-2-🔍-深度分析：高级语言的“环境陷阱”" class="headerlink" title="2.2 🔍 深度分析：高级语言的“环境陷阱”"></a>2.2 🔍 深度分析：高级语言的“环境陷阱”</h3><p>这是典型的<strong>宿主与客体契约不匹配 (Contract Mismatch)<strong>。当通过高级语言（如 Kotlin, Go, Python）编写 Wasm 产物时，我们必须明确知晓</strong>该产物所依赖的上下文环境</strong>。</p><ul><li><strong>Guest (Kotlin <code>wasmJs</code>) 的假设</strong>：编译器默认宿主环境是 <strong>浏览器</strong> 或 <strong>Node.js</strong>。因此，它生成了对 <code>js_code</code> 模块的强依赖，试图调用 JavaScript 的对象（如 <code>console</code>, <code>Error.stack</code>）。</li><li><strong>Host (C&#x2F;WasmEdge) 的现实</strong>：宿主是一个 Native 程序，它只实现了标准的 <strong>WASI</strong> 接口，根本<strong>不存在</strong> JavaScript 虚拟机环境。</li></ul><p>这就是<strong>“环境依赖地狱”</strong>：高级语言为了方便开发者，往往默认绑定了 Web 环境。但这对于 Server-side Wasm 来说是致命的——宿主 Runtime 无法提供这些特定的 JS 绑定。</p><h3 id="2-3-✅-解决方案"><a href="#2-3-✅-解决方案" class="headerlink" title="2.3 ✅ 解决方案"></a>2.3 ✅ 解决方案</h3><p><strong>必须选择统一的标准：WASI。</strong></p><p>我们将 Kotlin 的编译目标切换为 <strong><code>wasmWasi</code><strong>。这不仅仅是改个参数，而是做出了一个架构决策：</strong>拒绝特定环境（JS）的依赖，拥抱通用标准</strong>。</p><ul><li><strong>错误路径</strong>：依赖 <code>wasmJs</code> -&gt; 宿主必须嵌入 V8 引擎或模拟 JS 接口 -&gt; 系统极其臃肿且难以维护。</li><li><strong>正确路径</strong>：依赖 <code>wasmWasi</code> -&gt; 宿主仅需实现 WASI 标准接口 -&gt; 系统轻量、解耦且跨平台。</li></ul><hr><h2 id="3-第二关：运行时生命周期的陷阱"><a href="#3-第二关：运行时生命周期的陷阱" class="headerlink" title="3. 第二关：运行时生命周期的陷阱"></a>3. 第二关：运行时生命周期的陷阱</h2><p>解决了导入依赖后，模块可以加载了。但在执行具体的 <code>add</code> 函数时，控制台抛出了更隐蔽的错误：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[error] execution failed: uncaught exception</span><br></pre></td></tr></table></figure><h3 id="3-1-🕳️-陷阱一：被忽略的-initialize-启动引导"><a href="#3-1-🕳️-陷阱一：被忽略的-initialize-启动引导" class="headerlink" title="3.1 🕳️ 陷阱一：被忽略的 _initialize (启动引导)"></a>3.1 🕳️ 陷阱一：被忽略的 <code>_initialize</code> (启动引导)</h3><p>Kotlin（以及 Go、Java 等托管语言）编译为 Wasm 后，不再是简单的函数集合。在运行任何业务逻辑之前，必须先初始化运行时环境。</p><ul><li><strong>原因</strong>：Wasm 内部需要分配堆内存、启动垃圾回收器（GC）、初始化全局变量。</li><li><strong>对策</strong>：在 <strong>Reactor 模式</strong>（即作为库被调用）下，宿主必须在调用业务函数前，<strong>显式调用</strong> Guest 导出的 <strong><code>_initialize</code></strong> 函数。</li></ul><blockquote><p>如果跳过这一步，就像试图在没有安装操作系统的电脑上运行 Word，直接导致空指针引用或内存错误。</p></blockquote><h3 id="3-2-🕳️-陷阱二：WASI-的-I-x2F-O-绑定-感官连接"><a href="#3-2-🕳️-陷阱二：WASI-的-I-x2F-O-绑定-感官连接" class="headerlink" title="3.2 🕳️ 陷阱二：WASI 的 I&#x2F;O 绑定 (感官连接)"></a>3.2 🕳️ 陷阱二：WASI 的 I&#x2F;O 绑定 (感官连接)</h3><p>最令人困惑的是：明明宿主代码中已经注册了 WASI 支持 (<code>WasmEdge_HostRegistration_Wasi</code>)，为什么调用 <code>println</code> 还会崩溃？</p><p><strong>原因在于：注册 (Registration) ≠ 初始化 (Initialization)。</strong></p><ul><li><strong>注册</strong>：只是告诉 VM “我有能力处理 WASI 请求”（我装了声卡驱动）。</li><li><strong>初始化</strong>：是将宿主的实际资源（如当前的 Stdout 文件描述符）绑定到 Wasm 实例的过程（把音响线插到了声卡上）。</li></ul><p><strong>对策</strong>：在 C 宿主代码中，必须显式调用 <code>WasmEdge_ModuleInstanceInitWASI</code>。如果省略此步，Wasm 内部的 <code>fd_write(1, ...)</code> 调用会因为找不到对应的输出通道而失败，Kotlin 运行时捕获到这个 I&#x2F;O 错误后，抛出了未捕获异常。</p><hr><h2 id="4-架构总结：Wasm-插件系统的“守恒定律”"><a href="#4-架构总结：Wasm-插件系统的“守恒定律”" class="headerlink" title="4. 架构总结：Wasm 插件系统的“守恒定律”"></a>4. 架构总结：Wasm 插件系统的“守恒定律”</h2><p>通过这次调试，我们可以总结出一套通用的 Wasm 插件系统设计原则。核心在于：<strong>Guest 的环境诉求必须由 Host 的能力集完全覆盖</strong>。</p><table><thead><tr><th align="left">层面</th><th align="left">关键要素</th><th align="left">职责描述</th></tr></thead><tbody><tr><td align="left"><strong>Guest (插件)</strong></td><td align="left"><strong>上下文感知</strong></td><td align="left">开发者必须明确产物的依赖环境：<br>❌ <strong>Kotlin&#x2F;Wasm (JS)<strong>：依赖 JS 胶水代码，</strong>不适合</strong>纯 Native 宿主。<br>✅ <strong>Kotlin&#x2F;Wasm (WASI)<strong>：仅依赖标准系统接口，</strong>完美适配</strong> WasmEdge&#x2F;WAMR 等宿主。<br>⚪ <strong>Freestanding</strong>：零依赖，仅适合纯算法逻辑。</td></tr><tr><td align="left"><strong>Host (宿主)</strong></td><td align="left"><strong>能力注入</strong></td><td align="left">Host 必须满足 Guest 列出的“需求清单 (Imports)”：<br>🔸 对应 <code>wasmWasi</code>，Host 必须<strong>注册并初始化</strong> WASI 模块。<br>🔸 对应 GC&#x2F;Exception 等高级特性，Host 必须开启 VM 的 Proposal 开关。</td></tr><tr><td align="left"><strong>Runtime (运行时)</strong></td><td align="left"><strong>生命周期</strong></td><td align="left">连接 Guest 与 Host 的桥梁：<br>🔄 <strong>引导</strong>：负责调用 <code>_initialize</code> 建立内存秩序。<br>🔌 <strong>连接</strong>：负责绑定 I&#x2F;O 管道，打通 Guest 与 Host 的感官。</td></tr></tbody></table><hr><h2 id="5-结语与参考资源"><a href="#5-结语与参考资源" class="headerlink" title="5. 结语与参考资源"></a>5. 结语与参考资源</h2><p>在 C&#x2F;C++ 环境下嵌入 Wasm，不仅仅是加载一个二进制文件那么简单。它实质上是在<strong>构建一个微型的操作系统</strong>。</p><p>作为宿主开发者，你需要：</p><ol><li><strong>审视依赖</strong>：确保 Wasm 产物没有引入宿主不支持的“环境噪音”（如 JS 绑定）。</li><li><strong>提供接口</strong>：为 Guest 准备标准的文件系统接口 (WASI)。</li><li><strong>管理生命周期</strong>：为 Guest 分配内存空间 (<code>_initialize</code>) 并正确绑定 IO。</li></ol><p>从 <code>wasmJs</code> 到 <code>wasmWasi</code> 的切换，不仅仅是编译参数的改变，更是从 <strong>“Web 前端依赖”</strong> 思维向 <strong>“云原生标准接口”</strong> 思维的根本转变。只有基于 WASI 这种统一标准，宿主 Runtime 才能在不感知上层语言（Kotlin&#x2F;Rust&#x2F;Go）差异的情况下，提供稳定的运行支撑。</p><h3 id="🔗-相关-Runtime-与工具参考"><a href="#🔗-相关-Runtime-与工具参考" class="headerlink" title="🔗 相关 Runtime 与工具参考"></a>🔗 相关 Runtime 与工具参考</h3><p>以下是一些主流的支持 WASI 标准的 Runtime 及相关工具，它们均可作为上述架构中的“宿主 Runtime”选型参考：</p><ul><li><strong>WasmEdge Runtime</strong>: 高性能、轻量级的 WebAssembly 运行时，对 WASI 及扩展提案支持完善。<ul><li><a href="https://github.com/WasmEdge/WasmEdge/">https://github.com/WasmEdge/WasmEdge/</a></li></ul></li><li><strong>WAMR (WebAssembly Micro Runtime)</strong>: 专为嵌入式和物联网设计的轻量级运行时（链接为 Windows 移植版参考）。<ul><li><a href="https://github.com/moecly/wasm-micro-runtime-main-windows">https://github.com/moecly/wasm-micro-runtime-main-windows</a></li></ul></li><li><strong>Wazero Bridge (JVM)</strong>: 如果宿主本身是 JVM 环境，wazero 是一个纯 Go 实现的 Runtime，这里的 bridge 项目展示了 Kotlin&#x2F;JVM 如何与 Wasm 交互。<ul><li><a href="https://github.com/crowforkotlin/wazero-bride-jvm">https://github.com/crowforkotlin/wazero-bride-jvm</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebAssembly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> WebAssembly </tag>
            
            <tag> WASI </tag>
            
            <tag> WasmEdge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zipline 架构深度解析 (二)：Guest 运行时与原生桥接机制</title>
      <link href="/2025/11/18/Library/Zipline%E6%A1%86%E6%9E%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/11/18/Library/Zipline%E6%A1%86%E6%9E%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Zipline-架构深度解析-二-：Guest-运行时与原生桥接机制"><a href="#Zipline-架构深度解析-二-：Guest-运行时与原生桥接机制" class="headerlink" title="Zipline 架构深度解析 (二)：Guest 运行时与原生桥接机制"></a>Zipline 架构深度解析 (二)：Guest 运行时与原生桥接机制</h1><p>在上一篇中，我们分析了 Zipline 的宏观分层架构。本篇将深入 <strong>Guest 端 (Kotlin&#x2F;JS)</strong> 的运行时环境，并结合底层的 <strong>C++ 源码</strong>，详细阐述 QuickJS 与 JVM 之间双向通信通道（Call Channel）的实现原理。</p><h2 id="🧬-1-Guest-端-Kotlin-x2F-JS-运行时架构"><a href="#🧬-1-Guest-端-Kotlin-x2F-JS-运行时架构" class="headerlink" title="🧬 1. Guest 端 (Kotlin&#x2F;JS) 运行时架构"></a>🧬 1. Guest 端 (Kotlin&#x2F;JS) 运行时架构</h2><p>运行在 QuickJS 引擎中的 Guest 端与 JVM Host 端在 API 设计上保持对称，但在底层实现策略上充分利用了 JavaScript 的动态特性和 Kotlin&#x2F;JS 的互操作能力。</p><h3 id="1-1-上下文管理与单例模式"><a href="#1-1-上下文管理与单例模式" class="headerlink" title="1.1 上下文管理与单例模式"></a>1.1 上下文管理与单例模式</h3><p>与 JVM 端可能存在多个 Zipline 实例不同，Guest 端运行在单线程的 QuickJS 上下文中，因此采用了全局单例模式来管理生命周期。</p><ul><li><strong><code>theOnlyZipline</code></strong>: 保存当前的 Zipline 实例。Host 初始化 JS 环境后，Guest 代码通过 <code>Zipline.get()</code> 获取上下文，无需 Host 显式传递引用。</li></ul><h3 id="1-2-GlobalBridge-全局通信入口与环境模拟"><a href="#1-2-GlobalBridge-全局通信入口与环境模拟" class="headerlink" title="1.2 GlobalBridge: 全局通信入口与环境模拟"></a>1.2 <code>GlobalBridge</code>: 全局通信入口与环境模拟</h3><p><code>GlobalBridge</code> 是 Kotlin&#x2F;JS 端的一个 <code>object</code>，它在架构中承担了 <strong>Inbound（入站）入口</strong> 和 <strong>环境 Polyfill</strong> 的双重职责。</p><h4 id="代码实现分析"><a href="#代码实现分析" class="headerlink" title="代码实现分析"></a>代码实现分析</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> GlobalBridge : GuestService, CallChannel &#123;</span><br><span class="line">  <span class="comment">// 获取 Zipline 框架内部处理入站请求的通道</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> inboundChannel: CallChannel</span><br><span class="line">    <span class="keyword">get</span>() = zipline.endpoint.inboundChannel</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="comment">// 利用 js() 函数直接操作 JS 全局作用域</span></span><br><span class="line">    js(</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      // 1. 将自身挂载到 globalThis，供 C++ 层查找并调用</span></span><br><span class="line"><span class="string">      globalThis.app_cash_zipline_inboundChannel = globalBridge;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      // 2. Polyfill: 将标准 JS API 转发回 Host 端执行</span></span><br><span class="line"><span class="string">      globalThis.setTimeout = function(handler, delay) &#123;</span></span><br><span class="line"><span class="string">        return globalBridge.setTimeout(handler, delay, arguments);</span></span><br><span class="line"><span class="string">      &#125;;</span></span><br><span class="line"><span class="string">      globalThis.console = &#123;</span></span><br><span class="line"><span class="string">        log: function() &#123; globalBridge.consoleMessage(&#x27;log&#x27;, arguments) &#125;,</span></span><br><span class="line"><span class="string">        // ... 其他 log 级别</span></span><br><span class="line"><span class="string">      &#125;;</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 C++ 层通过 globalThis.app_cash_zipline_inboundChannel.call() 调用时触发</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(callJson: <span class="type">String</span>)</span></span> = inboundChannel.call(callJson)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心机制：</strong></p><ol><li><strong>入口暴露</strong>：通过将 Kotlin 对象赋值给 <code>globalThis</code> 属性，使得底层的 C++ 代码可以通过字符串查找（<code>JS_GetPropertyStr</code>）获取到该对象的引用，从而实现 JVM -&gt; JS 的调用链路。</li><li><strong>环境模拟</strong>：QuickJS 是纯净的 JS 引擎，不包含宿主环境 API。<code>GlobalBridge</code> 拦截 <code>setTimeout</code> 和 <code>console</code> 调用，通过 RPC 转发给 Host 端执行，保证了标准 JS 库的兼容性。</li></ol><h3 id="1-3-性能优化：FastDynamicSerializer"><a href="#1-3-性能优化：FastDynamicSerializer" class="headerlink" title="1.3 性能优化：FastDynamicSerializer"></a>1.3 性能优化：<code>FastDynamicSerializer</code></h3><p>为了降低 JSON 序列化在 JS 端的开销，Zipline 引入了 <code>FastDynamicSerializer</code>。利用 JS 的动态类型特性，跳过 JSON 字符串的生成与解析，直接在 Kotlin 对象与 JS 对象树之间进行转换（<code>asDynamic()</code>），在高频交互场景下显著降低了 CPU 和内存消耗。</p><hr><h2 id="🔗-2-原生桥接层-Native-Bridge-Internals"><a href="#🔗-2-原生桥接层-Native-Bridge-Internals" class="headerlink" title="🔗 2. 原生桥接层 (Native Bridge Internals)"></a>🔗 2. 原生桥接层 (Native Bridge Internals)</h2><p>Zipline 的核心通信机制依赖于 C++ 层在 JVM (JNI) 和 QuickJS (C API) 之间建立的“双向代理”。这部分代码主要位于 <code>Context.cpp</code> 和 <code>OutboundCallChannel.cpp</code> 中。</p><h3 id="2-1-JS-→-JVM-通道：OutboundCallChannel-C"><a href="#2-1-JS-→-JVM-通道：OutboundCallChannel-C" class="headerlink" title="2.1 JS → JVM 通道：OutboundCallChannel (C++)"></a>2.1 JS → JVM 通道：<code>OutboundCallChannel</code> (C++)</h3><p>此通道负责处理 JS 端发起的调用请求。其核心难点在于：<strong>当 JS 函数被执行时，C++ 如何知道该回调对应 JVM 中的哪个对象？</strong></p><p>Zipline 采用了 <strong>Opaque Pointer (不透明指针)</strong> 技术来解决上下文绑定问题。</p><h4 id="核心实现逻辑"><a href="#核心实现逻辑" class="headerlink" title="核心实现逻辑"></a>核心实现逻辑</h4><ol><li><p><strong>构造与绑定 (Registration)sss</strong>：<br>在 <code>OutboundCallChannel</code> 的构造函数中，C++ 将 JVM 对象的引用绑定到 JS 对象上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OutboundCallChannel.cpp</span></span><br><span class="line">OutboundCallChannel::<span class="built_in">OutboundCallChannel</span>(Context* c, JNIEnv* env, <span class="type">const</span> <span class="type">char</span>* name, jobject object, JSValueConst jsOutboundCallChannel)</span><br><span class="line">    : <span class="built_in">context</span>(c),</span><br><span class="line">      <span class="comment">// 1. 创建 JNI 全局引用，防止 JVM 对象被 GC 回收</span></span><br><span class="line">      <span class="built_in">javaThis</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(object)),</span><br><span class="line">      <span class="comment">// 2. 预先缓存方法 ID，提升后续调用性能</span></span><br><span class="line">      <span class="built_in">callMethod</span>(env-&gt;<span class="built_in">GetMethodID</span>(callChannelClass, <span class="string">&quot;call&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 将 C++ 静态函数 OutboundCallChannel::call 映射为 JS 对象的 &quot;call&quot; 方法</span></span><br><span class="line">  functions.<span class="built_in">push_back</span>(<span class="built_in">JS_CFUNC_DEF</span>(<span class="string">&quot;call&quot;</span>, <span class="number">1</span>, OutboundCallChannel::call));</span><br><span class="line">  <span class="built_in">JS_SetPropertyFunctionList</span>(context-&gt;jsContext, jsOutboundCallChannel, functions.<span class="built_in">data</span>(), functions.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Context.cpp</code> 中，完成关键的指针绑定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context.cpp</span></span><br><span class="line"><span class="comment">// 将 OutboundCallChannel C++ 实例的指针，作为 Opaque Data 附加到 JS 对象内部</span></span><br><span class="line"><span class="built_in">JS_SetOpaque</span>(jsOutboundCallChannel, javaObject.<span class="built_in">release</span>());</span><br></pre></td></tr></table></figure></li><li><p>**执行与穿透 (Execution)**：<br>当 JS 执行 <code>.call()</code> 时，QuickJS 回调 C++ 静态函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OutboundCallChannel.cpp</span></span><br><span class="line"><span class="function">JSValue <span class="title">OutboundCallChannel::call</span><span class="params">(JSContext* ctx, JSValueConst this_val, <span class="type">int</span> argc, JSValueConst* argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 恢复上下文：从 JS 对象中取出 C++ 实例指针</span></span><br><span class="line">  <span class="keyword">auto</span> channel = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> OutboundCallChannel*&gt;(</span><br><span class="line">      <span class="built_in">JS_GetOpaque</span>(this_val, context-&gt;outboundCallChannelClassId)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 数据转换：JS String -&gt; Java String</span></span><br><span class="line">  jvalue args[<span class="number">1</span>];</span><br><span class="line">  args[<span class="number">0</span>].l = context-&gt;<span class="built_in">toJavaString</span>(env, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. JNI 反射调用：穿透边界，执行 JVM 代码</span></span><br><span class="line">  jstring javaResult = <span class="built_in">static_cast</span>&lt;jstring&gt;(env-&gt;<span class="built_in">CallObjectMethodA</span>(</span><br><span class="line">      channel-&gt;javaThis,   <span class="comment">// 使用之前保存的全局引用</span></span><br><span class="line">      channel-&gt;callMethod, <span class="comment">// 使用缓存的方法 ID</span></span><br><span class="line">      args</span><br><span class="line">  ));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 结果转换与异常处理 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-2-JVM-→-JS-通道：InboundCallChannel-C"><a href="#2-2-JVM-→-JS-通道：InboundCallChannel-C" class="headerlink" title="2.2 JVM → JS 通道：InboundCallChannel (C++)"></a>2.2 JVM → JS 通道：<code>InboundCallChannel</code> (C++)</h3><p>此通道负责处理 Host 端发起的调用请求。</p><h4 id="核心实现逻辑-1"><a href="#核心实现逻辑-1" class="headerlink" title="核心实现逻辑"></a>核心实现逻辑</h4><ol><li><p>**查找 (Lookup)**：<br>C++ 通过 <code>JS_GetGlobalObject</code> 和 <code>JS_GetPropertyStr</code> 在 JS 全局作用域中查找名为 <code>app_cash_zipline_inboundChannel</code> 的对象（即 Kotlin&#x2F;JS 端的 <code>GlobalBridge</code>）。</p></li><li><p>**持有与句柄 (Handle)**：<br>C++ 创建一个 <code>InboundCallChannel</code> 包装对象持有该 JS 引用，并将该 C++ 对象的内存地址 (<code>reinterpret_cast&lt;jlong&gt;</code>) 返回给 JVM。</p></li><li><p>**执行 (Invoke)**：<br>当 JVM 调用该 Handle 时，C++ 使用 <code>JS_Invoke</code> 指令 QuickJS 引擎执行目标 JS 对象的 <code>call</code> 方法。</p></li></ol><hr><h2 id="🔬-3-完整调用链路追踪"><a href="#🔬-3-完整调用链路追踪" class="headerlink" title="🔬 3. 完整调用链路追踪"></a>🔬 3. 完整调用链路追踪</h2><p>结合上述分析，一次从 <strong>Guest (JS)</strong> 调用 <strong>Host (JVM)</strong> 服务的完整生命周期如下：</p><table><thead><tr><th align="left">阶段</th><th align="left">执行环境</th><th align="left">组件</th><th align="left">动作描述</th></tr></thead><tbody><tr><td align="left"><strong>1. 代理调用</strong></td><td align="left"><strong>JS (Guest)</strong></td><td align="left">User Code</td><td align="left">用户调用 <code>proxy.log(&quot;msg&quot;)</code>。</td></tr><tr><td align="left"><strong>2. 拦截与序列化</strong></td><td align="left"><strong>JS (Guest)</strong></td><td align="left"><code>GeneratedOutboundService</code></td><td align="left">编译器生成的代理类拦截调用，将函数名和参数序列化为 JSON。</td></tr><tr><td align="left"><strong>3. 触发原生层</strong></td><td align="left"><strong>JS (Guest)</strong></td><td align="left"><code>globalThis</code></td><td align="left">调用 <code>globalThis.app_cash_zipline_outboundChannel.call(json)</code>。</td></tr><tr><td align="left"><strong>4. 原生拦截</strong></td><td align="left"><strong>QuickJS</strong></td><td align="left">Engine</td><td align="left">识别 Native 绑定，跳转至 C++ 静态函数 <code>OutboundCallChannel::call</code>。</td></tr><tr><td align="left"><strong>5. 上下文恢复</strong></td><td align="left"><strong>C++</strong></td><td align="left"><code>JS_GetOpaque</code></td><td align="left">从 JS <code>this</code> 指针中取出 C++ 实例指针，恢复 JNI 上下文。</td></tr><tr><td align="left"><strong>6. JNI 穿透</strong></td><td align="left"><strong>C++</strong></td><td align="left"><code>JNIEnv</code></td><td align="left">调用 <code>env-&gt;CallObjectMethod</code>，传入 JVM 对象的全局引用。</td></tr><tr><td align="left"><strong>7. 宿主接收</strong></td><td align="left"><strong>JVM (Host)</strong></td><td align="left"><code>OutboundChannel</code></td><td align="left">JVM 端的 <code>call</code> 方法被触发，接收到 JSON 字符串。</td></tr><tr><td align="left"><strong>8. 路由分发</strong></td><td align="left"><strong>JVM (Host)</strong></td><td align="left"><code>Endpoint</code></td><td align="left"><code>inboundChannel</code> 反序列化 JSON，在 <code>inboundServices</code> 注册表中找到目标服务实例。</td></tr><tr><td align="left"><strong>9. 业务执行</strong></td><td align="left"><strong>JVM (Host)</strong></td><td align="left">Implementation</td><td align="left">执行实际的业务逻辑（如 <code>RealLogger.log</code>）。</td></tr><tr><td align="left"><strong>10. 结果回传</strong></td><td align="left"><strong>All</strong></td><td align="left">Return Path</td><td align="left">执行结果沿原路返回：JVM -&gt; JNI -&gt; C++ -&gt; JS String -&gt; User Code。</td></tr></tbody></table><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><p>Zipline 的架构设计展示了跨语言互操作的高级工程实践：</p><ol><li><strong>对称的 Endpoint 设计</strong>：JS 和 JVM 端维护了逻辑一致的 <code>Endpoint/Service/Adapter</code> 结构，降低了系统复杂度。</li><li><strong>基于 Opaque Pointer 的上下文绑定</strong>：C++ 层利用 QuickJS 的 <code>Opaque Data</code> 机制，巧妙地将 C++ 实例状态绑定到 JS 对象上，实现了无状态静态函数与有状态对象之间的桥接。</li><li><strong>JNI 性能与安全</strong>：通过预缓存 Method ID 和使用 Global Reference，既保证了跨语言调用的高性能，又确保了 JVM 对象的内存安全（防止过早 GC）。</li><li>**控制反转 (IoC)**：上层代码（Kotlin）并不直接管理底层通信，而是通过注册回调的方式，由底层引擎（QuickJS&#x2F;JNI）在特定事件发生时驱动执行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Library </category>
          
          <category> 桥接 </category>
          
          <category> KMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JNI </tag>
            
            <tag> Zipline </tag>
            
            <tag> Kotlin/JS </tag>
            
            <tag> QuickJS </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zipline 架构深度解析 (一)</title>
      <link href="/2025/11/18/Library/Zipline%E6%A1%86%E6%9E%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/11/18/Library/Zipline%E6%A1%86%E6%9E%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Zipline-核心架构深度解析"><a href="#Zipline-核心架构深度解析" class="headerlink" title="Zipline 核心架构深度解析"></a>Zipline 核心架构深度解析</h1><p>Zipline 是一个为 Kotlin Multiplatform (KMP) 设计的高性能应用框架，其核心目标是在隔离的执行环境（通常是 Host&#x2F;JVM 与 Guest&#x2F;JS）之间，建立一个类型安全、双向、高效的 RPC (Remote Procedure Call) 通讯机制。为达成此目标，Zipline 采用了一种分层、高度解耦的架构，其实现横跨 Kotlin 编译器、序列化框架以及为不同平台（JVM&#x2F;Android, iOS&#x2F;Native）量身定制的原生桥接层。</p><h2 id="🏛️-1-宏观架构与核心原则"><a href="#🏛️-1-宏观架构与核心原则" class="headerlink" title="🏛️ 1. 宏观架构与核心原则"></a>🏛️ 1. 宏观架构与核心原则</h2><p>Zipline 的架构遵循以下几个核心原则，这些原则共同确保了其灵活性、性能和类型安全。</p><ul><li><p>**🧩 服务接口驱动 (Interface-Driven Services)**：所有跨平台通讯都通过继承 <code>ZiplineService</code> 的 Kotlin <code>interface</code> 来定义。这利用了 Kotlin 的类型系统，将 RPC 调用抽象为本地接口调用，从而在编译期即可保证类型安全。</p></li><li><p>**📜 序列化作为通用协议 (Serialization as the Universal Protocol)**：所有跨边界的方法调用（包括参数和返回值）都被 <code>kotlinx.serialization</code> 序列化为 <strong>JSON 字符串</strong>。JSON 作为一种通用的、与语言无关的数据格式，确保了通讯协议的稳定性和与底层实现的解耦。</p></li><li><p><strong>⚙️ 编译器驱动的代码生成 (Compiler-Driven Code Generation)<strong>：Zipline 的性能和类型安全严重依赖其 Kotlin IR (Intermediate Representation) 编译器插件。该插件在编译期自动生成 <code>Adapter</code> 类，</strong>完全避免了在运行时使用低效且不安全的反射机制</strong>。</p></li><li><p>**🌉 非对称原生桥接 (Asymmetrical Native Bridging)**：Zipline 认识到不同原生平台（JVM vs. Native）有其独特的与 C 语言交互的最佳实践。因此，它为不同平台提供了不同的原生桥接实现（JNI for JVM, Cinterop for Native），同时在上层提供统一的 API，将平台差异完全封装。</p></li></ul><h3 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h3><table><thead><tr><th align="left">层次</th><th align="left">角色</th><th align="left">技术栈</th><th align="left">核心职责</th></tr></thead><tbody><tr><td align="left"><strong>🧑‍💻 应用层 (Application Layer)</strong></td><td align="left">框架使用者</td><td align="left">Kotlin&#x2F;JVM, Kotlin&#x2F;JS</td><td align="left">定义 <code>ZiplineService</code> 接口；使用 <code>zipline.bind()</code> 和 <code>zipline.take()</code> 来注册和使用服务；编写平台无关的业务逻辑。</td></tr><tr><td align="left"><strong>🏗️ 框架层 (Framework Layer)</strong></td><td align="left">Zipline 核心</td><td align="left">Kotlin (stdlib, serialization, compiler)</td><td align="left"><strong>管理服务生命周期</strong>；<strong>序列化&#x2F;反序列化 RPC 调用</strong>；**透过编译器插件生成 <code>Adapter</code><strong>；</strong>创建动态代理 (Dynamic Proxies)**。</td></tr><tr><td align="left"><strong>🔗 原生桥接层 (Native Bridge Layer)</strong></td><td align="left">平台通讯基础</td><td align="left">C&#x2F;C++ (JNI &amp; a; KN Cinterop), QuickJS</td><td align="left"><strong>封装 QuickJS C API</strong>；<strong>建立和管理跨语言通讯通道</strong>；优化原生调用性能；处理原生资源管理。</td></tr></tbody></table><h2 id="🧩-2-核心组件深度说明"><a href="#🧩-2-核心组件深度说明" class="headerlink" title="🧩 2. 核心组件深度说明"></a>🧩 2. 核心组件深度说明</h2><h3 id="2-1-Endpoint-双向通讯的中央枢纽"><a href="#2-1-Endpoint-双向通讯的中央枢纽" class="headerlink" title="2.1. Endpoint: 双向通讯的中央枢纽"></a>2.1. <code>Endpoint</code>: 双向通讯的中央枢纽</h3><p><code>Endpoint</code> 是 Zipline 框架层的核心，是管理所有 RPC 呼叫的中央路由器。每个执行环境（Host 和 Guest）都有一个独立的 <code>Endpoint</code> 实例。</p><h4 id="功能与职责："><a href="#功能与职责：" class="headerlink" title="功能与职责："></a>功能与职责：</h4><ul><li><p><strong>服务注册与发现</strong>:</p><ul><li><code>bind&lt;T&gt;(name: String, instance: T)</code>: 此函数用于**发布一个本地服务 (Inbound Service)**。它将一个实现了 <code>ZiplineService</code> 接口的本地 Kotlin 对象 <code>instance</code> 注册到 <code>Endpoint</code> 的 <code>inboundServices</code> 映射中，使其可以通过 <code>name</code> 这个唯一的字符串标识符被远端调用。</li><li><code>take&lt;T&gt;(name: String)</code>: 此函数用于**订阅一个远端服务 (Outbound Service)<strong>。它并不返回远端服务的真实实例，而是创建一个实现了 <code>T</code> 接口的</strong>本地动态代理 (Local Dynamic Proxy)**。</li></ul></li><li><p><strong>双向调用通道 (<code>CallChannel</code>)</strong>:</p><ul><li><code>inboundChannel</code>: 负责接收和处理来自远端的 RPC 请求。当接收到一个序列化的 JSON 调用时，它会解码该调用，在 <code>inboundServices</code> 中查找目标服务，并委托 <code>Adapter</code> 来执行真实的方法。</li><li><code>outboundChannel</code>: 负责将本地对代理对象的调用发送到远端。它将方法调用序列化为 JSON，并通过此通道发送。</li></ul></li><li><p><strong>序列化上下文</strong>:<br><code>Endpoint</code> 持有一个 <code>kotlinx.serialization.json.Json</code> 实例，该实例配置了所有必要的上下文序列化器（如 <code>PassByReference</code>、<code>Flow</code> 等）和用户自定义的 <code>SerializersModule</code>，确保所有数据都能被正确地跨边界传输。</p></li></ul><h3 id="2-2-Host-与-Guest-Plugin-隔离的执行环境"><a href="#2-2-Host-与-Guest-Plugin-隔离的执行环境" class="headerlink" title="2.2. Host 与 Guest(Plugin): 隔离的执行环境"></a>2.2. Host 与 Guest(Plugin): 隔离的执行环境</h3><table><thead><tr><th align="left">角色</th><th align="left">环境</th><th align="left">核心职责</th></tr></thead><tbody><tr><td align="left"><strong>Host (宿主)</strong></td><td align="left">Kotlin&#x2F;JVM (Android), Kotlin&#x2F;Native (iOS)</td><td align="left">启动和管理 Zipline 实例；加载 Guest 代码；通过 <code>bind()</code> 提供平台原生能力（如文件IO、网络请求）。</td></tr><tr><td align="left"><strong>Guest (插件)</strong></td><td align="left">Kotlin&#x2F;JS (运行于 QuickJS)</td><td align="left">实现可热更新的业务逻辑；通过 <code>take()</code> 消费 Host 提供的原生能力；通过 <code>bind()</code> 向 Host 暴露自己的服务。</td></tr></tbody></table><p>这种双向的 <code>bind</code>&#x2F;<code>take</code> 机制是 Zipline 得以实现强大插件化架构的基础。</p><h3 id="2-3-Kotlin-IR-编译器插件-ZiplineIrGenerationExtension"><a href="#2-3-Kotlin-IR-编译器插件-ZiplineIrGenerationExtension" class="headerlink" title="2.3. Kotlin IR 编译器插件: ZiplineIrGenerationExtension"></a>2.3. Kotlin IR 编译器插件: <code>ZiplineIrGenerationExtension</code></h3><p>这是 Zipline 实现类型安全和高性能的<strong>决定性技术</strong>。</p><h4 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h4><ol><li><p><strong><code>Adapter</code> 类的自动生成</strong>:</p><ul><li>在编译期间，插件会扫描所有继承自 <code>ZiplineService</code> 的接口。</li><li>对于每个接口 <code>T</code>，它会自动生成一个 <code>T.Adapter</code> 类，该类实现了 <code>ZiplineServiceAdapter&lt;T&gt;</code>。</li><li>这个生成的 <code>Adapter</code> 包含了关于接口 <code>T</code> 的所有元信息：服务名称、所有函数的签名、参数及返回值的序列化器。</li></ul></li><li><p><strong>方法调用的静态绑定</strong>:</p><ul><li><code>Adapter</code> 内部会生成一个 <code>ziplineFunctions</code> 方法，它返回一个 <code>ZiplineFunction</code> 列表。每个 <code>ZiplineFunction</code> 对应接口中的一个方法。</li><li><code>ZiplineFunction</code> 的 <code>call</code> 方法是<strong>硬编码</strong>的，它直接、类型安全地调用接口 <code>T</code> 的具体方法，并处理参数的反序列化。这完全<strong>避免了在运行时进行方法名查找和反射调用</strong>。</li></ul></li><li><p><strong>改写 <code>take</code> 和 <code>bind</code> 调用</strong>:</p><ul><li>插件会找到所有 <code>zipline.take&lt;T&gt;(...)</code> 和 <code>zipline.bind&lt;T&gt;(...)</code> 的调用点。</li><li>它会自动将生成的 <code>T.Adapter</code> 实例作为最后一个参数<strong>注入</strong>到这些调用中，使得 Zipline 框架在运行时能够获取到关于服务 <code>T</code> 的所有静态元信息。</li></ul><p><strong>概念上的代码转换：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发者编写的代码</span></span><br><span class="line"><span class="keyword">val</span> myService = zipline.take&lt;MyService&gt;(<span class="string">&quot;my-service&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器插件改写后的代码</span></span><br><span class="line"><span class="keyword">val</span> myService = zipline.take&lt;MyService&gt;(<span class="string">&quot;my-service&quot;</span>, MyService.Adapter)</span><br></pre></td></tr></table></figure></li></ol><h2 id="🔗-3-原生桥接层-Native-Bridge-Layer"><a href="#🔗-3-原生桥接层-Native-Bridge-Layer" class="headerlink" title="🔗 3. 原生桥接层 (Native Bridge Layer)"></a>🔗 3. 原生桥接层 (Native Bridge Layer)</h2><p>这是连接高阶 Kotlin 框架与底层 QuickJS C API 的桥梁。</p><h3 id="3-1-C-Context-类-JVM-x2F-Android-平台"><a href="#3-1-C-Context-类-JVM-x2F-Android-平台" class="headerlink" title="3.1. C++ Context 类 (JVM&#x2F;Android 平台)"></a>3.1. <strong>C++ <code>Context</code> 类 (JVM&#x2F;Android 平台)</strong></h3><p>在 JVM 平台上，Kotlin 代码通过 JNI 与 C++ 代码交互，再由 C++ 代码调用 QuickJS 的 C API。<code>Context</code> 类是这个原生层的状态和资源管理中心。</p><table><thead><tr><th align="left"><code>Context.h</code> 成员类别</th><th align="left">职责</th><th align="left">实现细节</th></tr></thead><tbody><tr><td align="left"><strong>核心引擎指针</strong></td><td align="left">直接控制 QuickJS</td><td align="left"><code>JSRuntime*</code>, <code>JSContext*</code>。使用独立的 <code>jsContextForCompiling</code> 来隔离编译和执行，提升稳定性。</td></tr><tr><td align="left"><strong>JNI 性能缓存</strong></td><td align="left"><strong>避免 JNI 性能瓶颈</strong></td><td align="left">在构造函数中，<strong>一次性</strong>查找并缓存所有将频繁使用的 <code>jclass</code> 和 <code>jmethodID</code>。</td></tr><tr><td align="left"><strong>Zipline 桥接机制</strong></td><td align="left">定义和管理通讯代理</td><td align="left"><code>outboundCallChannelClassId</code> 定义了 C++ 控制的 JS 对象类型；预先缓存常用字符串的 <code>JSAtom</code> 以加速属性查找。</td></tr><tr><td align="left"><strong>生命周期管理</strong></td><td align="left"><strong>防止资源泄漏</strong></td><td align="left">使用 <code>std::vector</code> 和 <code>std::unordered_map</code> 追踪所有 JNI 全局引用和 C++ 对象，并在析构函数中确保它们被正确释放。</td></tr></tbody></table><h4 id="双向通讯通道的-C-实现"><a href="#双向通讯通道的-C-实现" class="headerlink" title="双向通讯通道的 C++ 实现"></a><strong>双向通讯通道的 C++ 实现</strong></h4><p>Zipline 的 JNI 层并不直接暴露函数回调，而是实现了一个精巧的、基于 C++ 代理对象的双向通道。</p><ul><li><p><strong><code>setOutboundCallChannel</code> (JS → JVM)</strong>:</p><ol><li>JVM 传递一个 <code>CallChannel</code> Kotlin 对象 (<code>jobject</code>) 给 C++。</li><li>C++ 使用 <code>JS_NewObjectClass</code> 创建一个新的 JS 代理对象。</li><li><strong>关键步骤</strong>：C++ 创建一个 <code>OutboundCallChannel</code> C++ 对象，该对象持有 JVM <code>CallChannel</code> 的<strong>JNI 全局引用</strong>。然后，使用 <code>JS_SetOpaque</code> 将这个 C++ 对象的指针<strong>附加</strong>到新创建的 JS 对象的内部。</li><li>当 JS 调用这个代理对象的 <code>.call()</code> 方法时，底层的 C 函数被触发，它通过 <code>JS_GetOpaque</code> 取回 C++ 对象指针，进而通过 JNI 全局引用<strong>安全地回调</strong>到 JVM 中的 <code>CallChannel</code> 实例。</li></ol></li><li><p><strong><code>getInboundCallChannel</code> (JVM → JS)</strong>:</p><ol><li>C++ 在 QuickJS 全局对象中查找 Zipline JS 框架定义的 <code>inboundChannel</code> 对象。</li><li>C++ 创建一个 <code>InboundCallChannel</code> C++ 包装器对象，该对象持有指向上述 JS 对象的引用。</li><li>它将这个 C++ <strong>包装器的内存地址</strong>（强制转换为 <code>jlong</code>）返回给 JVM 作为句柄。</li><li>当 JVM 通过这个句柄调用 <code>.call()</code> 时，JNI 会找到对应的 C++ 包装器，并由它来调用其持有的 JS 对象的方法。</li></ol></li></ul><h3 id="3-2-Kotlin-x2F-Native-Cinterop-iOS-平台"><a href="#3-2-Kotlin-x2F-Native-Cinterop-iOS-平台" class="headerlink" title="3.2. Kotlin&#x2F;Native Cinterop (iOS 平台)"></a>3.2. <strong>Kotlin&#x2F;Native Cinterop (iOS 平台)</strong></h3><p>在 iOS 等 Native 平台上，Zipline 的实现更为直接，<strong>无需 C++ 中介层</strong>。</p><table><thead><tr><th align="left">对比项</th><th align="left">JNI (JVM&#x2F;Android)</th><th align="left">Cinterop (Kotlin&#x2F;Native)</th></tr></thead><tbody><tr><td align="left"><strong>与 C 的交互</strong></td><td align="left">间接：Kotlin → JNI → C++ → C</td><td align="left"><strong>直接</strong>：Kotlin → C</td></tr><tr><td align="left"><strong>中介层</strong></td><td align="left">C++ <code>Context</code> 类</td><td align="left"><strong>无</strong>。<code>QuickJs.native.kt</code> 类直接扮演 <code>Context</code> 的角色。</td></tr><tr><td align="left"><strong>C 函数调用</strong></td><td align="left"><code>external fun</code> 映射到 JNI 函数</td><td align="left">直接调用由 Cinterop 从头文件生成的 Kotlin 函数。</td></tr><tr><td align="left"><strong>对象引用传递</strong></td><td align="left"><code>NewGlobalRef</code> (JNI)</td><td align="left"><strong><code>StableRef.create()</code></strong> (Kotlin&#x2F;Native)</td></tr><tr><td align="left"><strong>C 回调</strong></td><td align="left">复杂的 C++ 代理和 JNI 方法调用</td><td align="left">**<code>staticCFunction</code>**，直接创建一个可传递给 C 的 Kotlin 函数指针。</td></tr></tbody></table><h2 id="📈-4-完整调用流程示例-JS-Guest-→-JVM-Host"><a href="#📈-4-完整调用流程示例-JS-Guest-→-JVM-Host" class="headerlink" title="📈 4. 完整调用流程示例 (JS Guest → JVM Host)"></a>📈 4. 完整调用流程示例 (JS Guest → JVM Host)</h2><ol><li><strong><code>Host.bind()</code></strong>: <code>zipline.bind&lt;MyService&gt;(&quot;my-service&quot;, serviceImpl)</code>。<code>Endpoint</code> 将 <code>serviceImpl</code> 存入其 <code>inboundServices</code> 映射。</li><li><strong><code>Guest.take()</code></strong>: <code>zipline.take&lt;MyService&gt;(&quot;my-service&quot;)</code>。<code>Endpoint</code> 在 JS 端创建一个 <code>MyService</code> 的动态代理对象。</li><li><strong>Guest 调用</strong>: <code>proxy.myMethod(&quot;arg&quot;)</code>。</li><li><strong>序列化</strong>: JS 代理将此调用序列化为 JSON 字符串：<code>&#123;&quot;service&quot;:&quot;my-service&quot;, &quot;function&quot;:&quot;myMethod&quot;, &quot;args&quot;:[&quot;arg&quot;]&#125;</code>。</li><li><strong>JS → C++ → JNI</strong>: JS 代理调用 <code>globalThis.app_cash_zipline_outboundChannel.call(json)</code>。这触发了 C++ <code>OutboundCallChannel</code> 代理，后者通过 JNI 回调到 JVM。</li><li><strong>JVM 接收</strong>: JVM <code>Endpoint</code> 的 <code>inboundChannel</code> 的 <code>call</code> 方法被执行。</li><li><strong>解码与路由</strong>: <code>Endpoint</code> 解码 JSON，找到名为 <code>&quot;my-service&quot;</code> 的 <code>InboundService</code>。</li><li><strong>执行</strong>: <code>InboundService</code> 使用由**编译器插件生成的 <code>MyService.Adapter</code>**，高效地反序列化参数并调用 <code>serviceImpl.myMethod(&quot;arg&quot;)</code>。</li><li><strong>返回</strong>: 结果沿原路序列化并返回给 JS 调用端。</li></ol><hr><h2 id="✅-结论"><a href="#✅-结论" class="headerlink" title="✅ 结论"></a>✅ 结论</h2><p>Zipline 的核心是一个<strong>分层明确、高度抽象的 RPC 框架</strong>。它在<strong>应用层</strong>提供了极其简洁的 <code>take</code>&#x2F;<code>bind</code> API，在<strong>框架层</strong>利用<strong>序列化</strong>和<strong>编译器插件</strong>提供了类型安全与高性能，并在<strong>原生桥接层</strong>针对不同平台采用了<strong>精巧、健壮的实现</strong>。这个架构使得开发者可以完全忽略底层平台的复杂性，专注于实现平台无关的业务逻辑，是 Kotlin Multiplatform 插件化和代码共享的典范之作。</p>]]></content>
      
      
      <categories>
          
          <category> Library </category>
          
          <category> 桥接 </category>
          
          <category> KMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Librarry </tag>
            
            <tag> 原理 </tag>
            
            <tag> KMP </tag>
            
            <tag> Bridge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 2025 热修复、动态化方案研究报告</title>
      <link href="/2025/10/28/Android/Android%E7%83%AD%E4%BF%AE%E5%92%8C%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88/"/>
      <url>/2025/10/28/Android/Android%E7%83%AD%E4%BF%AE%E5%92%8C%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-2025-热修复与动态化方案研究报告"><a href="#Android-2025-热修复与动态化方案研究报告" class="headerlink" title="Android 2025 热修复与动态化方案研究报告"></a>Android 2025 热修复与动态化方案研究报告</h1><h2 id="一、热修复方案对比"><a href="#一、热修复方案对比" class="headerlink" title="一、热修复方案对比"></a>一、热修复方案对比</h2><p>热修复方案的核心在于对已发布应用的代码进行即时修复，无需重新发布版本。以下是几种主流方案的特性对比：</p><table><thead><tr><th align="left">特性</th><th align="left">Tinker (腾讯)</th><th align="left">QZone (腾讯)</th><th align="left">AndFix (阿里)</th><th align="left">Robust (美团)</th></tr></thead><tbody><tr><td align="left"><strong>类替换</strong></td><td align="left">✅ 支持</td><td align="left">✅ 支持</td><td align="left">❌ 不支持</td><td align="left">❌ 不支持</td></tr><tr><td align="left"><strong>So 替换</strong></td><td align="left">✅ 支持</td><td align="left">❌ 不支持</td><td align="left">❌ 不支持</td><td align="left">❌ 不支持</td></tr><tr><td align="left"><strong>资源替换</strong></td><td align="left">✅ 支持</td><td align="left">✅ 支持</td><td align="left">❌ 不支持</td><td align="left">❌ 不支持</td></tr><tr><td align="left"><strong>全平台支持</strong></td><td align="left">✅ 支持</td><td align="left">✅ 支持</td><td align="left">✅ 支持</td><td align="left">✅ 支持</td></tr><tr><td align="left"><strong>即时生效</strong></td><td align="left">❌ 需重启</td><td align="left">❌ 需重启</td><td align="left">✅ 支持</td><td align="left">✅ 支持</td></tr><tr><td align="left"><strong>性能损耗</strong></td><td align="left">较小</td><td align="left">较大</td><td align="left">较小</td><td align="left">较小</td></tr><tr><td align="left"><strong>补丁包大小</strong></td><td align="left">较小</td><td align="left">较大</td><td align="left">一般</td><td align="left">一般</td></tr><tr><td align="left"><strong>开发透明</strong></td><td align="left">✅ 是</td><td align="left">✅ 是</td><td align="left">❌ 否</td><td align="left">❌ 否</td></tr><tr><td align="left"><strong>复杂度</strong></td><td align="left">较低</td><td align="left">较低</td><td align="left">复杂</td><td align="left">复杂</td></tr><tr><td align="left"><strong>Gradle 支持</strong></td><td align="left">✅ 支持</td><td align="left">❌ 不支持</td><td align="left">❌ 不支持</td><td align="left">❌ 不支持</td></tr><tr><td align="left"><strong>Rom 体积</strong></td><td align="left">较大</td><td align="left">较小</td><td align="left">较小</td><td align="left">较小</td></tr><tr><td align="left"><strong>成功率</strong></td><td align="left">较高</td><td align="left">较高</td><td align="left">一般</td><td align="left"><strong>最高</strong></td></tr></tbody></table><p><strong>核心结论：</strong><br>目前，多数主流开源热修复框架（如 AndFix, Robust）已长期未维护。<strong>Tinker</strong> 是当前社区内依然活跃并推荐使用的方案。</p><h3 id="1-Tinker-方案的潜在问题-v1-9-15-2"><a href="#1-Tinker-方案的潜在问题-v1-9-15-2" class="headerlink" title="1. Tinker 方案的潜在问题 (v1.9.15.2)"></a>1. Tinker 方案的潜在问题 (v1.9.15.2)</h3><p>尽管 Tinker 是首选，但在集成到大型项目中时，仍需注意以下挑战：</p><ol><li><strong>Gradle 兼容性问题：</strong> 官方版本对 Gradle 7+ 的支持不佳，直接升级可能会引发编译异常。</li><li><strong>编译打包冲突：</strong><ul><li>当项目依赖了较高版本的 Material 组件 (如 v1.13.0+) 或其他复杂库时，R8 混淆过程极易出现 <code>XXX which is not in loader class</code> 的类丢失错误。</li><li>官方建议通过配置白名单解决，但实际操作中可能依然无法彻底解决问题，有时不得不降级依赖版本。</li></ul></li><li><strong>Application 改造：</strong><ul><li>官方要求 <code>Application</code> 类中不能包含业务逻辑，以避免补丁构建失败。</li><li>对于已有项目，这意味着需要进行大量重构，将相关逻辑封装并通过反射调用，适配成本较高。</li></ul></li></ol><h3 id="2-Shiply-基于-Tinker-的商业化方案"><a href="#2-Shiply-基于-Tinker-的商业化方案" class="headerlink" title="2. Shiply (基于 Tinker 的商业化方案)"></a>2. Shiply (基于 Tinker 的商业化方案)</h3><ul><li><strong>优点：</strong> 基于 Tinker 扩展，原生支持 Gradle 8+，并提供了 Web 控制台用于补丁管理，方案更加成熟。</li><li><strong>缺点：</strong> 依然继承了 Tinker 底层的核心问题，如编译冲突和 Application 改造的复杂性。</li></ul><blockquote><p><strong>参考资料:</strong> <a href="https://shiply.tds.qq.com/document/hotfix/faq/">Tinker&#x2F;Shiply 常见问题</a></p></blockquote><h3 id="3-热修复方案总结"><a href="#3-热修复方案总结" class="headerlink" title="3. 热修复方案总结"></a>3. 热修复方案总结</h3><ul><li><strong>优点：</strong><ul><li>能够动态修复线上代码，灵活性高。</li><li>补丁产物较小，对性能影响可控。</li></ul></li><li><strong>缺点：</strong><ul><li><strong>集成成本高：</strong> 引入现有大型项目时，解决编译打包问题、重构 Application 类等工作耗时耗力。</li><li><strong>兼容性风险：</strong> 容易与项目中的第三方依赖产生冲突，稳定性需要充分测试。</li></ul></li></ul><hr><h2 id="二、动态化方案"><a href="#二、动态化方案" class="headerlink" title="二、动态化方案"></a>二、动态化方案</h2><p>动态化与热修复不同，它更侧重于功能模块的动态下发和执行，而非仅仅是代码“打补丁”。</p><ul><li><strong>实现方式 1 (语言解释器)：</strong> 通过内置的语言解释器（如 JavaScript 引擎）执行插件代码，并桥接到原生平台 API。</li><li><strong>实现方式 2 (插件化框架)：</strong> 通过 Hook 原生实现，动态加载插件文件（如 APK）来执行逻辑，对宿主代码的修改能力有限。</li></ul><h3 id="1-Shadow-腾讯插件化方案"><a href="#1-Shadow-腾讯插件化方案" class="headerlink" title="1. Shadow (腾讯插件化方案)"></a>1. Shadow (腾讯插件化方案)</h3><ul><li><strong>核心特性：</strong> 零反射、全动态的 Android 插件框架，插件产物为 APK 压缩后的 ZIP 文件。</li><li><strong>优点：</strong> 性能接近原生，产物小，已支持原生四大组件等能力。</li><li><strong>商业版：</strong> <a href="https://shiply.tds.qq.com/document/android-plugin/overview/">Shiply 动态化</a> 基于 Shadow 实现，提供 Web 控制台管理，但部分高级能力需申请开放。</li></ul><h3 id="2-Zipline-Kotlin-Multiplatform-方案"><a href="#2-Zipline-Kotlin-Multiplatform-方案" class="headerlink" title="2. Zipline (Kotlin Multiplatform 方案)"></a>2. Zipline (Kotlin Multiplatform 方案)</h3><ul><li><strong>核心特性：</strong> 通过内置的 QuickJS 引擎解释并执行 JS 代码，桥接到原生平台（Android, iOS, Desktop）。插件文件是 JS 编译后的二进制 <code>.zipline</code> 文件。</li><li><strong>优点：</strong> 跨平台，项目结构清晰。</li><li><strong>缺点：</strong> 不直接支持原生能力，需要自行扩展桥接实现；产物较大，性能相比原生有一定损耗。</li></ul><h3 id="3-动态化方案总结"><a href="#3-动态化方案总结" class="headerlink" title="3. 动态化方案总结"></a>3. 动态化方案总结</h3><ul><li><strong>优点：</strong><ul><li>适配和兼容过程通常比热修复简单。</li><li>插件化使得模块分离，项目结构更清晰。</li></ul></li><li><strong>缺点：</strong><ul><li>部分框架的插件产物较大。</li><li>依赖解释器的方案性能略低于原生。</li><li>通常无法修复未预先扩展的宿主代码。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 热修复 </tag>
            
            <tag> 热加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin Compiler (1) FIR &amp; IR测试</title>
      <link href="/2025/10/22/Kotlin/Kotlin%20Compiler%20(1)%20FIR%20IR%E6%B5%8B%E8%AF%95/"/>
      <url>/2025/10/22/Kotlin/Kotlin%20Compiler%20(1)%20FIR%20IR%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="深入探索-Kotlin-编译器：FIR-与-IR-插件测试"><a href="#深入探索-Kotlin-编译器：FIR-与-IR-插件测试" class="headerlink" title="深入探索 Kotlin 编译器：FIR 与 IR 插件测试"></a>深入探索 Kotlin 编译器：FIR 与 IR 插件测试</h1><blockquote><p>本文深入探讨 Kotlin 编译器插件的测试机制，核心围绕两种测试类型：用于验证编译时错误的 “诊断测试 (Diagnostic Test)”，和用于验证运行时行为的 “黑盒代码生成测试 (Box Test)”。我们将以官方的 <a href="https://github.com/Kotlin/compiler-plugin-template">Kotlin&#x2F;compiler-plugin-template</a> 项目为例，揭示测试指令（Test Directives）如何驱动复杂的测试流程，并阐明测试类的继承关系如何决定测试的行为与验证逻辑。</p></blockquote><h2 id="核心测试类型"><a href="#核心测试类型" class="headerlink" title="核心测试类型"></a>核心测试类型</h2><p>在 Kotlin 编译器插件模板项目中，主要通过以下两种测试类型来确保插件的正确性：</p><ol><li><p><strong>诊断测试 (Diagnostic Test)</strong><br>此测试的核心目标是验证编译器在特定阶段能否正确报告预期的编译错误或警告。它通过分析源码，在编译流程的某个指定阶段（如 <code>FRONTEND</code>）停下来，检查编译器输出的诊断信息是否与预期完全一致。这种测试不关心代码能否最终运行，只关心编译过程的正确性。</p></li><li><p><strong>黑盒代码生成测试 (Box Test)</strong><br>黑盒测试关注的是“输入”与“最终输出”的对应关系，而不关心编译器的内部实现细节。测试流程会将一段合法的 Kotlin 源码作为输入，完整地执行编译、代码生成和运行，最后验证程序的运行时输出是否符合预期。这种测试用于确保编译器插件在修改代码后，其运行时行为仍然正确。</p></li></ol><h2 id="项目结构解析"><a href="#项目结构解析" class="headerlink" title="项目结构解析"></a>项目结构解析</h2><p>分析的源码基于官方的 <a href="https://github.com/Kotlin/compiler-plugin-template">Kotlin&#x2F;compiler-plugin-template</a>。该模板项目为开发编译器插件提供了标准的结构和测试框架。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">├───.github</span><br><span class="line">├───.gradle</span><br><span class="line">├───.idea</span><br><span class="line">├───.kotlin</span><br><span class="line">├───build</span><br><span class="line">├───compiler-plugin</span><br><span class="line">│   ├───src</span><br><span class="line">│   │   └───org/jetbrains/kotlin/compiler/plugin/template</span><br><span class="line">│   │       ├───fir</span><br><span class="line">│   │       └───ir</span><br><span class="line">│   ├───test-fixtures</span><br><span class="line">│   │   └───org/jetbrains/kotlin/compiler/plugin/template</span><br><span class="line">│   │       ├───runners</span><br><span class="line">│   │       └───services</span><br><span class="line">│   ├───test-gen</span><br><span class="line">│   │   └───org/jetbrains/kotlin/compiler/plugin/template</span><br><span class="line">│   │       └───runners</span><br><span class="line">│   └───testData</span><br><span class="line">│       ├───box</span><br><span class="line">│       └───diagnostics</span><br><span class="line">├───gradle</span><br><span class="line">├───gradle-plugin</span><br><span class="line">├───kotlin-js-store</span><br><span class="line">└───plugin-annotations</span><br><span class="line">    └───src</span><br></pre></td></tr></table></figure><p>其中与测试直接相关的关键目录如下：</p><ul><li><code>compiler-plugin/testData</code>: 存放测试用例源文件（<code>.kt</code>），按测试类型分为 <code>box</code> 和 <code>diagnostics</code>。</li><li><code>compiler-plugin/test-fixtures</code>: 包含测试辅助工具类，例如自定义的测试运行器基类和配置器。</li><li><code>compiler-plugin/test-gen</code>: 存放由测试框架根据 <code>testData</code> 自动生成的测试类代码。</li></ul><h2 id="黑盒代码生成测试-Box-Test-实现"><a href="#黑盒代码生成测试-Box-Test-实现" class="headerlink" title="黑盒代码生成测试 (Box Test) 实现"></a>黑盒代码生成测试 (Box Test) 实现</h2><p>黑盒测试验证从 FIR 到 IR 再到最终代码生成的完整流程。</p><h3 id="测试基类-AbstractJvmBoxTest"><a href="#测试基类-AbstractJvmBoxTest" class="headerlink" title="测试基类 AbstractJvmBoxTest"></a>测试基类 <code>AbstractJvmBoxTest</code></h3><p>所有 JVM 平台的黑盒测试都继承自 <code>AbstractJvmBoxTest</code>。此类负责配置测试环境、编译器指令和插件。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetbrains.kotlin.compiler.plugin.template.runners</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.compiler.plugin.template.services.ExtensionRegistrarConfigurator</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.compiler.plugin.template.services.PluginAnnotationsProvider</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.FirParser</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.builders.TestConfigurationBuilder</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.directives.CodegenTestDirectives</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.directives.FirDiagnosticsDirectives</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.directives.JvmEnvironmentConfigurationDirectives</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.runners.codegen.AbstractFirBlackBoxCodegenTestBase</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.services.EnvironmentBasedStandardLibrariesPathProvider</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.services.KotlinStandardLibrariesPathProvider</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">AbstractJvmBoxTest</span> : <span class="type">AbstractFirBlackBoxCodegenTestBase</span>(FirParser.LightTree) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createKotlinStandardLibrariesPathProvider</span><span class="params">()</span></span>: KotlinStandardLibrariesPathProvider &#123;</span><br><span class="line">        <span class="keyword">return</span> EnvironmentBasedStandardLibrariesPathProvider</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">configure</span><span class="params">(builder: <span class="type">TestConfigurationBuilder</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.configure(builder)</span><br><span class="line"></span><br><span class="line">        with(builder) &#123;</span><br><span class="line">            <span class="comment">// 设置所有测试默认开启的编译器指令</span></span><br><span class="line">            defaultDirectives &#123;</span><br><span class="line">                +CodegenTestDirectives.DUMP_IR       <span class="comment">// 输出生成的 IR</span></span><br><span class="line">                +FirDiagnosticsDirectives.FIR_DUMP   <span class="comment">// 输出 FIR 树</span></span><br><span class="line">                +JvmEnvironmentConfigurationDirectives.FULL_JDK</span><br><span class="line">                +CodegenTestDirectives.IGNORE_DEXING</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册插件服务</span></span><br><span class="line">            useConfigurators(</span><br><span class="line">                ::PluginAnnotationsProvider,</span><br><span class="line">                ::ExtensionRegistrarConfigurator</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动生成的测试类"><a href="#自动生成的测试类" class="headerlink" title="自动生成的测试类"></a>自动生成的测试类</h3><p><code>JvmBoxTestGenerated</code> 是一个由测试框架自动生成的类，它会扫描 <code>compiler-plugin/testData/box</code> 目录下的所有 <code>.kt</code> 文件，并为每个文件生成一个对应的 <code>@Test</code> 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetbrains.kotlin.compiler.plugin.template.runners;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intellij.testFramework.TestDataPath;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.util.KtTestUtil;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.TargetBackend;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.test.TestMetadata;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** This class is generated by &#123;<span class="doctag">@link</span> org.jetbrains.kotlin.compiler.plugin.template.GenerateTestsKt&#125;. DO NOT MODIFY MANUALLY */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(<span class="string">&quot;all&quot;</span>)</span></span><br><span class="line"><span class="meta">@TestMetadata(<span class="string">&quot;compiler-plugin/testData/box&quot;</span>)</span></span><br><span class="line"><span class="meta">@TestDataPath(<span class="string">&quot;<span class="variable">$PROJECT_ROOT</span>&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JvmBoxTestGenerated</span> <span class="title">extends</span> <span class="title">AbstractJvmBoxTest</span> &#123;</span><br><span class="line">  <span class="comment">// ... (方法为每个 testData/box 下的 .kt 文件自动生成)</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@TestMetadata(<span class="string">&quot;simple.kt&quot;</span>)</span></span><br><span class="line">  <span class="keyword">public</span> void testSimple() &#123;</span><br><span class="line">    runTest(<span class="string">&quot;compiler-plugin/testData/box/simple.kt&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="诊断测试-Diagnostic-Test-实现"><a href="#诊断测试-Diagnostic-Test-实现" class="headerlink" title="诊断测试 (Diagnostic Test) 实现"></a>诊断测试 (Diagnostic Test) 实现</h2><p>诊断测试仅关心编译器的某个特定阶段是否按预期工作，通过 <code>RUN_PIPELINE_TILL</code> 指令来控制编译流程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RUN_PIPELINE_TILL: FRONTEND</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该指令告诉测试框架，编译流程在 FRONTEND 阶段结束后就应停止并进行验证。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果测试用例中的代码在 FRONTEND 阶段之后才能发现问题（或没有问题），</span></span><br><span class="line"><span class="comment"> * 例如，移除下面的错误行 s.&lt;!UNRESOLVED_REFERENCE!&gt;inc&lt;!&gt;()，代码本身是合法的。</span></span><br><span class="line"><span class="comment"> * 此时测试框架会因编译成功通过了 FRONTEND 阶段而抛出异常：</span></span><br><span class="line"><span class="comment"> * &quot;Phase FRONTEND could be promoted to BACKEND&quot;，</span></span><br><span class="line"><span class="comment"> * 建议将指令调整到更靠后的阶段，如 FIR2IR 或 BACKEND。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> foo.bar</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.compiler.plugin.template.SomeAnnotation</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> s = MyClass().foo()</span><br><span class="line">    s.&lt;!UNRESOLVED_REFERENCE!&gt;inc&lt;!&gt;() <span class="comment">// 预期此处产生一个 &quot;UNRESOLVED_REFERENCE&quot; 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器各阶段的顺序定义在 <code>org.jetbrains.kotlin.test.services.TestPhase</code> 中：</p><ol><li><code>FRONTEND</code></li><li><code>FIR2IR</code></li><li><code>KLIB</code></li><li><code>BACKEND</code></li></ol><h2 id="FIR-与-IR-在插件开发中的应用"><a href="#FIR-与-IR-在插件开发中的应用" class="headerlink" title="FIR 与 IR 在插件开发中的应用"></a>FIR 与 IR 在插件开发中的应用</h2><p>对编译器插件开发者而言，理解 FIR 和 IR 的角色至关重要。</p><ul><li><strong>FIR (Frontend Intermediate Representation)</strong>: 是一个更接近 Kotlin 源码的中间表示。主要用于语法分析、语义分析和诊断。详细信息请参考 <a href="https://github.com/JetBrains/kotlin/blob/master/docs/fir/fir-basics.md">FIR 官方文档</a>。</li><li><strong>IR (Intermediate Representation)</strong>: 是一个更底层的、与具体平台无关的中间表示。它是连接前端和后端的桥梁，大多数代码生成和转换插件（如添加&#x2F;修改函数、类）都在 IR 阶段进行。详细信息请参考 <a href="https://github.com/JetBrains/kotlin/blob/master/docs/compiler-plugins/basics.md">Compiler Plugins 官方文档</a>。</li></ul><h3 id="实际案例：Zipline-IR-插件"><a href="#实际案例：Zipline-IR-插件" class="headerlink" title="实际案例：Zipline IR 插件"></a>实际案例：Zipline IR 插件</h3><p><a href="https://github.com/cashapp/zipline">Zipline</a> 项目通过 IR 插件实现了跨平台（Kotlin&#x2F;JS, Kotlin&#x2F;JVM）的 RPC 调用。其核心原理是在编译期动态修改实现了 <code>ZiplineService</code> 接口的代码。</p><p><strong>第一步：开发者编写的代码</strong><br>开发者仅需定义一个简单的服务接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EchoService.kt</span></span><br><span class="line"><span class="keyword">package</span> com.example</span><br><span class="line"><span class="keyword">import</span> app.cash.zipline.ZiplineService</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">EchoService</span> : <span class="type">ZiplineService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">echo</span><span class="params">(request: <span class="type">String</span>)</span></span>: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步：Zipline IR 插件在编译时的工作</strong><br>在编译器的 IR 阶段，<code>ZiplineIrGenerationExtension</code> 插件被激活。它扫描所有实现了 <code>ZiplineService</code> 的接口，并执行以下内存中的 IR 变换：</p><ol><li><strong>创建伴生对象</strong>：如果接口没有 <code>companion object</code>，则为其创建一个。</li><li><strong>生成 Adapter 类</strong>：在伴生对象内部，生成一个名为 <code>Adapter</code> 的嵌套类，该类实现了 <code>ZiplineServiceAdapter</code>，用于桥接 Zipline 的底层通信。</li><li><strong>生成代理类</strong>：在 <code>Adapter</code> 内部，再生成一个私有的代理类（如 <code>GeneratedOutboundService</code>），该类实现了原始的 <code>EchoService</code> 接口，并将所有方法调用转发给 Zipline 的 RPC <code>callHandler</code>。</li></ol><p><strong>第三步：编译器后端看到的最终 IR 结构</strong><br>插件处理完成后，编译器后端看到的 <code>EchoService</code> 的 IR 结构在逻辑上等同于以下代码。这份代码并未出现在源文件中，而是由插件在内存中动态构建，并直接用于生成最终的目标平台代码（如 JVM 字节码）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> app.cash.zipline.ZiplineService</span><br><span class="line"><span class="keyword">import</span> app.cash.zipline.<span class="keyword">internal</span>.bridge.ZiplineServiceAdapter</span><br><span class="line"><span class="keyword">import</span> kotlinx.serialization.KSerializer</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">EchoService</span> : <span class="type">ZiplineService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">echo</span><span class="params">(request: <span class="type">String</span>)</span></span>: String</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- START: CODE GENERATED BY ZIPLINE IR PLUGIN ---</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">Adapter</span>(...) : ZiplineServiceAdapter&lt;EchoService&gt;, KSerializer&lt;EchoService&gt; &#123;</span><br><span class="line">            <span class="comment">// ... 自动实现 ziplineFunctions()</span></span><br><span class="line">            <span class="comment">// ... 自动实现 outboundService()</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">GeneratedOutboundService</span>(</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">val</span> callHandler: OutboundCall.Handler</span><br><span class="line">            ) : EchoService &#123; <span class="comment">// 代理类实现了原始接口</span></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">echo</span><span class="params">(request: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">                    <span class="comment">// 将调用转发给 Zipline 底层通信机制</span></span><br><span class="line">                    <span class="keyword">return</span> callHandler.call(<span class="keyword">this</span>, <span class="number">0</span>, request) <span class="keyword">as</span> String</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ---  END: CODE GENERATED BY ZIPLINE IR PLUGIN  ---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过分析 Kotlin 编译器插件的测试框架，我们可以看到：</p><ul><li><strong>诊断测试</strong> 和 <strong>黑盒测试</strong> 是保障插件质量的两种核心手段，分别关注编译过程的正确性和最终代码的运行时行为。</li><li><strong>测试指令</strong>（如 <code>RUN_PIPELINE_TILL</code>）提供了精细控制编译流程的能力。</li><li><strong>IR 变换</strong> 是编译器插件实现功能强大的代码织入与修改的关键，Zipline 等项目充分展示了其在实际应用中的巨大潜力。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/Kotlin/compiler-plugin-template">Kotlin&#x2F;compiler-plugin-template on GitHub</a></li><li><a href="https://github.com/JetBrains/kotlin/blob/master/docs/fir/fir-basics.md">Kotlin FIR (Frontend IR) Documentation</a></li><li><a href="https://github.com/JetBrains/kotlin/blob/master/docs/compiler-plugins/basics.md">Kotlin Compiler Plugins Basics</a></li><li><a href="https://github.com/cashapp/zipline">Cash App&#x2F;zipline on GitHub</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Kotlin Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Emoji</title>
      <link href="/2025/10/17/Git/Git%20Emoji/"/>
      <url>/2025/10/17/Git/Git%20Emoji/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">标签</th><th align="center">代码</th><th align="left">含义 (中文)</th><th align="left">含义 (英文)</th></tr></thead><tbody><tr><td align="center">📦</td><td align="center"><code>:package:</code></td><td align="left">添加或更新编译后的文件或包。</td><td align="left">Add or update compiled files or packages.</td></tr><tr><td align="center">✨</td><td align="center"><code>:sparkles:</code></td><td align="left">引入新功能。</td><td align="left">Introduce new features.</td></tr><tr><td align="center">🐛</td><td align="center"><code>:bug:</code></td><td align="left">修复 Bug。</td><td align="left">Fix a bug.</td></tr><tr><td align="center">⚡️</td><td align="center"><code>:zap:</code></td><td align="left">提高性能。</td><td align="left">Improve performance.</td></tr><tr><td align="center">📝</td><td align="center"><code>:memo:</code></td><td align="left">添加或更新文档。</td><td align="left">Add or update documentation.</td></tr><tr><td align="center">🚀</td><td align="center"><code>:rocket:</code></td><td align="left">部署相关。</td><td align="left">Deploy stuff.</td></tr><tr><td align="center">💄</td><td align="center"><code>:lipstick:</code></td><td align="left">更新 UI 和样式文件。</td><td align="left">Add or update the UI and style files.</td></tr><tr><td align="center">🎉</td><td align="center"><code>:tada:</code></td><td align="left">开始项目 &#x2F; 初始提交。</td><td align="left">Initial commit.</td></tr><tr><td align="center">✅</td><td align="center"><code>:white_check_mark:</code></td><td align="left">添加、更新或通过测试。</td><td align="left">Add, update, or pass tests.</td></tr><tr><td align="center">🔒️</td><td align="center"><code>:lock:</code></td><td align="left">修复安全或隐私问题。</td><td align="left">Fix security or privacy issues.</td></tr><tr><td align="center">🍎</td><td align="center"><code>:apple:</code></td><td align="left">修复 macOS 相关的 Bug。</td><td align="left">Fix stuff on macOS.</td></tr><tr><td align="center">🐧</td><td align="center"><code>:penguin:</code></td><td align="left">修复 Linux 相关的 Bug。</td><td align="left">Fix stuff on Linux.</td></tr><tr><td align="center">🏁</td><td align="center"><code>:checkered_flag:</code></td><td align="left">修复 Windows 相关的 Bug。</td><td align="left">Fix stuff on Windows.</td></tr><tr><td align="center">🚑️</td><td align="center"><code>:ambulance:</code></td><td align="left">紧急热修复。</td><td align="left">Critical hotfix.</td></tr><tr><td align="center">🚧</td><td align="center"><code>:construction:</code></td><td align="left">进行中的工作。</td><td align="left">Work in progress.</td></tr><tr><td align="center">💚</td><td align="center"><code>:green_heart:</code></td><td align="left">修复 CI (持续集成) 构建。</td><td align="left">Fix CI build.</td></tr><tr><td align="center">⬇️</td><td align="center"><code>:arrow_down:</code></td><td align="left">降级依赖。</td><td align="left">Downgrade dependencies.</td></tr><tr><td align="center">⬆️</td><td align="center"><code>:arrow_up:</code></td><td align="left">升级依赖。</td><td align="left">Upgrade dependencies.</td></tr><tr><td align="center">📌</td><td align="center"><code>:pushpin:</code></td><td align="left">锁定依赖的版本。</td><td align="left">Pin dependencies to specific versions.</td></tr><tr><td align="center">👷</td><td align="center"><code>:construction_worker:</code></td><td align="left">添加或更新 CI 构建系统。</td><td align="left">Add or update CI build system.</td></tr><tr><td align="center">📈</td><td align="center"><code>:chart_with_upwards_trend:</code></td><td align="left">添加分析或跟踪代码。</td><td align="left">Add analytics or tracking code.</td></tr><tr><td align="center">♻️</td><td align="center"><code>:recycle:</code></td><td align="left">重构特定的代码逻辑。</td><td align="left">Refactor specific code logic.</td></tr><tr><td align="center">🎨</td><td align="center"><code>:art:</code></td><td align="left">改进代码结构或格式。</td><td align="left">Improve structure &#x2F; format of the code.</td></tr><tr><td align="center">🔨</td><td align="center"><code>:hammer:</code></td><td align="left">进行重构 &#x2F; 通用代码改进。</td><td align="left">Refactor code &#x2F; General update.</td></tr><tr><td align="center">🔥</td><td align="center"><code>:fire:</code></td><td align="left">移除代码或文件。</td><td align="left">Remove code or files.</td></tr><tr><td align="center">🗑️</td><td align="center"><code>:wastebasket:</code></td><td align="left">废弃代码或文件。</td><td align="left">Deprecate code or files.</td></tr><tr><td align="center">🌐</td><td align="center"><code>:globe_with_meridians:</code></td><td align="left">国际化和本地化。</td><td align="left">Internationalization and localization.</td></tr><tr><td align="center">🔧</td><td align="center"><code>:wrench:</code></td><td align="left">添加或更新配置文件。</td><td align="left">Add or update configuration files.</td></tr><tr><td align="center">🚨</td><td align="center"><code>:rotating_light:</code></td><td align="left">修复编译器&#x2F;Linter 警告。</td><td align="left">Fix compiler &#x2F; linter warnings.</td></tr><tr><td align="center">💡</td><td align="center"><code>:bulb:</code></td><td align="left">添加注释或文档字符串。</td><td align="left">Add or update comments in source code.</td></tr><tr><td align="center">👥</td><td align="center"><code>:busts_in_silhouette:</code></td><td align="left">添加贡献者或团队信息。</td><td align="left">Add contributor(s) or community.</td></tr><tr><td align="center">⏪</td><td align="center"><code>:rewind:</code></td><td align="left">撤销更改。</td><td align="left">Revert changes.</td></tr><tr><td align="center">🚚</td><td align="center"><code>:truck:</code></td><td align="left">移动或重命名文件、路径。</td><td align="left">Move or rename resources.</td></tr><tr><td align="center">💥</td><td align="center"><code>:boom:</code></td><td align="left">引入破坏性变更。</td><td align="left">Introduce breaking changes.</td></tr><tr><td align="center">🍻</td><td align="center"><code>:beers:</code></td><td align="left">醉酒写的代码 &#x2F; 测试性提交。</td><td align="left">Write bad code that needs to be improved. (Often humorous or test-related)</td></tr><tr><td align="center">💩</td><td align="center"><code>:poop:</code></td><td align="left">糟糕的代码，需要改进。</td><td align="left">Write bad code that needs to be improved.</td></tr><tr><td align="center">♿️</td><td align="center"><code>:wheelchair:</code></td><td align="left">改善可访问性。</td><td align="left">Improve accessibility.</td></tr><tr><td align="center">🐳</td><td align="center"><code>:whale:</code></td><td align="left">Docker 相关更改。</td><td align="left">Docker related changes.</td></tr><tr><td align="center">➕</td><td align="center"><code>:heavy_plus_sign:</code></td><td align="left">添加依赖项。</td><td align="left">Add a dependency.</td></tr><tr><td align="center">➖</td><td align="center"><code>:heavy_minus_sign:</code></td><td align="left">移除依赖项。</td><td align="left">Remove a dependency.</td></tr><tr><td align="center">🧪</td><td align="center"><code>:test_tube:</code></td><td align="left">添加一个失败的测试。</td><td align="left">Add a failing test.</td></tr><tr><td align="center">👔</td><td align="center"><code>:necktie:</code></td><td align="left">添加或更新业务逻辑。</td><td align="left">Add or update business logic.</td></tr><tr><td align="center">📱</td><td align="center"><code>:iphone:</code></td><td align="left">修复响应式设计或移动端问题。</td><td align="left">Work on responsive design or mobile views.</td></tr><tr><td align="center">💻</td><td align="center"><code>:computer:</code></td><td align="left">修复桌面端（非 Web）相关问题。</td><td align="left">Work on desktop application.</td></tr><tr><td align="center">⚙️</td><td align="center"><code>:gear:</code></td><td align="left">更新设置或配置。</td><td align="left">Update settings or configuration.</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neovim快速搭建 以及对于Kotlin LSP的总结</title>
      <link href="/2025/10/13/Vim/nvim%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/"/>
      <url>/2025/10/13/Vim/nvim%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<div class="note info simple"><p>本文介绍如何在不同平台快速搭建 Neovim，以及 Kotlin LSP 的使用体验和踩坑总结。</p></div><h2 id="🖥️-各平台安装"><a href="#🖥️-各平台安装" class="headerlink" title="🖥️ 各平台安装"></a>🖥️ 各平台安装</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">Windows</button><button type="button" class="tab">Linux</button><button type="button" class="tab">MacOS</button></div><div class="tab-contents"><div class="tab-item-content active"><p>Windows 环境需要先安装 Chocolatey 包管理器。</p><p><strong>安装 Chocolatey：</strong></p><p>PowerShell 方式：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Bypass <span class="literal">-Scope</span> <span class="keyword">Process</span> <span class="literal">-Force</span>; [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol <span class="operator">-bor</span> <span class="number">3072</span>; <span class="built_in">iex</span> ((<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">&#x27;https://community.chocolatey.org/install.ps1&#x27;</span>))</span><br></pre></td></tr></table></figure><p>CMD 方式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&quot;<span class="variable">%SystemRoot%</span>\System32\WindowsPowerShell\v1.<span class="number">0</span>\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;[System.<span class="built_in">Net</span>.ServicePointManager]::SecurityProtocol = <span class="number">3072</span>; iex ((New-Object System.<span class="built_in">Net</span>.WebClient).DownloadString(&#x27;https://community.chocolatey.org/install.ps1&#x27;))&quot; &amp;&amp; <span class="built_in">SET</span> &quot;<span class="built_in">PATH</span>=<span class="variable">%PATH%</span>;<span class="variable">%ALLUSERSPROFILE%</span>\chocolatey\bin&quot;</span><br></pre></td></tr></table></figure><p><strong>安装 Neovim：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install nvim</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p>Linux 系统（包括 WSL）可直接使用 apt 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install neovim</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p>macOS 使用 Homebrew 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install neovim</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="⚙️-配置文件"><a href="#⚙️-配置文件" class="headerlink" title="⚙️ 配置文件"></a>⚙️ 配置文件</h2><p>安装完成后输入 <code>nvim</code> 即可启动。配置文件需手动创建：</p><div class="note warning simple"><p><strong>配置文件路径：</strong></p><ul><li>Windows: <code>C:\Users\${你的用户名}\AppData\Local\nvim</code></li><li>Mac&#x2F;Linux: <code>~/.config/nvim/</code></li></ul></div><h3 id="全选复制操作"><a href="#全选复制操作" class="headerlink" title="全选复制操作"></a>全选复制操作</h3><p>在普通模式下（可用 <code>hjkl</code> 移动光标）：</p><ol><li>输入 <code>ggvG</code> 全选</li><li>输入 <code>:&quot;+y</code> 复制到系统剪贴板</li></ol><h3 id="推荐配置方案"><a href="#推荐配置方案" class="headerlink" title="推荐配置方案"></a>推荐配置方案</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">LazyVim 框架</button><button type="button" class="tab">Neovimdots 框架</button></div><div class="tab-contents"><div class="tab-item-content active"><p>LazyVim 简化了 Neovim 配置流程，推荐新手使用。</p><p><a href="https://github.com/crowforkotlin/nvim-config," title="https:&#x2F;&#x2F;github.githubassets.com&#x2F;favicons&#x2F;favicon.svg" target="">Neovim Config,</a></p></div><div class="tab-item-content"><p>功能更全面的配置框架，集成了大量插件。</p><p><a href="https://github.com/ayamir/nvimdots," title="https:&#x2F;&#x2F;github.githubassets.com&#x2F;favicons&#x2F;favicon.svg" target="">Neovimdots,</a></p><div class="note danger simple"><p><strong>Windows 安装要求：</strong></p><ul><li>PowerShell 7+</li><li>Chocolatey</li></ul></div><p><strong>常见问题：</strong></p><ul><li>安装过程一路回车即可</li><li>若报错，需提前手动安装 nvim 或删除旧配置</li><li>LSP 初始化失败时，需通过 npm 手动安装依赖</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🚀-快速开始"><a href="#🚀-快速开始" class="headerlink" title="🚀 快速开始"></a>🚀 快速开始</h2><p>配置部署后，Neovim 会自动通过 LSP 下载插件到：</p><ul><li>Windows: <code>~\AppData\Local\nvim-data\lazy</code></li><li>Mac&#x2F;Linux: <code>~\.config\nvim-data</code></li></ul><div class="note warning simple"><p><strong>插件下载失败？</strong><br>即使配置了代理，git clone 也可能失败。解决方法：退出 nvim 后重新打开，重复操作直到插件完全下载。</p></div><h3 id="LSP-与-Mason"><a href="#LSP-与-Mason" class="headerlink" title="LSP 与 Mason"></a>LSP 与 Mason</h3><p>查看我的 LSP 配置：</p><a href="https://github.com/crowforkotlin/nvim-config/blob/main/lua/plugins/lsp.lua" title="https:&#x2F;&#x2F;github.githubassets.com&#x2F;favicons&#x2F;favicon.svg" target="">LSP 配置文件,</a><div class="note info simple"><p><strong>核心组件：</strong></p><ul><li><strong>LSP</strong>: 提供代码解析、类型检查、格式化等 IDE 功能</li><li><strong>Mason</strong>: 自动管理语言服务器和工具的安装</li></ul></div><h2 id="💡-Kotlin-LSP-使用总结"><a href="#💡-Kotlin-LSP-使用总结" class="headerlink" title="💡 Kotlin LSP 使用总结"></a>💡 Kotlin LSP 使用总结</h2><div class="note danger simple"><p>Kotlin LSP 目前存在较多问题，不推荐在 Neovim&#x2F;VSCode 中使用，建议使用 IntelliJ IDEA 或 Android Studio。</p></div><p><strong>主要问题：</strong></p><ul><li>响应速度慢，大型项目频繁报错</li><li>泛型、内联等复杂语法支持不佳</li><li>Android 项目支持极差，补全提示缺失</li></ul><h3 id="第三方解决方案"><a href="#第三方解决方案" class="headerlink" title="第三方解决方案"></a>第三方解决方案</h3><p>尝试过以下工具，但体验仍不理想：</p><ul><li><a href="https://github.com/desugar-64/kotlin-lsp-workspace-generator," title="https:&#x2F;&#x2F;github.githubassets.com&#x2F;favicons&#x2F;favicon.svg" target="">kotlin-lsp-workspace-generator,</a></li><li><a href="https://github.com/yamsergey/yamsergey.adt," title="https:&#x2F;&#x2F;github.githubassets.com&#x2F;favicons&#x2F;favicon.svg" target="">yamsergey.adt,</a></li></ul><div class="note warning simple"><p>虽然解决了 Android 支持问题，但引入了新问题：大量爆红、编译缓慢。结论：Kotlin 开发还是用 IDEA&#x2F;AS 更高效。</p></div><h2 id="🔗-相关链接"><a href="#🔗-相关链接" class="headerlink" title="🔗 相关链接"></a>🔗 相关链接</h2><ul><li><a href="https://learn.microsoft.com/zh-tw/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.5">PowerShell 安装指南</a></li><li><a href="https://docs.chocolatey.org/en-us/choco/setup/">Chocolatey 文档</a></li><li><a href="https://github.com/ayamir/nvimdots">Neovimdots</a></li><li><a href="https://github.com/crowforkotlin/nvim-config">我的 Neovim 配置</a></li><li><a href="https://github.com/crowforkotlin/nvim-config/blob/main/lua/plugins/lsp.lua">LSP 配置详情</a></li><li><a href="https://github.com/desugar-64/kotlin-lsp-workspace-generator">Kotlin LSP Workspace Generator</a></li><li><a href="https://github.com/yamsergey/yamsergey.adt">Yamsergey ADT</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>adb shell &amp; wsl root 实现彩色命令提示符</title>
      <link href="/2025/08/08/Android/adb%20shell%20&amp;%20wsl%20root%E5%AE%9E%E7%8E%B0%E5%BD%A9%E8%89%B2%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6/"/>
      <url>/2025/08/08/Android/adb%20shell%20&amp;%20wsl%20root%E5%AE%9E%E7%8E%B0%E5%BD%A9%E8%89%B2%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="WSL-终端彩色提示符"><a href="#WSL-终端彩色提示符" class="headerlink" title="WSL 终端彩色提示符"></a>WSL 终端彩色提示符</h2><p><img src="https://gitlab.com/crowforkotlin/page-storage/-/raw/main/image/post/image03.png" alt="wsl-ubuntu-prompt"></p><div class="note info modern"><p>编辑 <code>./root/.bashrc</code>，取消以下注释并使其生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">force_color_prompt=<span class="built_in">yes</span></span><br><span class="line"><span class="built_in">source</span> ./root/.bashrc</span><br></pre></td></tr></table></figure></div><h2 id="Android-Shell-彩色提示符（需-Root）"><a href="#Android-Shell-彩色提示符（需-Root）" class="headerlink" title="Android Shell 彩色提示符（需 Root）"></a>Android Shell 彩色提示符（需 Root）</h2><p><img src="https://gitlab.com/crowforkotlin/page-storage/-/raw/main/image/post/image04.png" alt="android-shell-prompt"></p><blockquote><p>使用 termux 的 vim 编辑：<code>vim /system/etc/mkshrc</code>，追加以下内容：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PS4=<span class="string">&#x27;[$EPOCHREALTIME] &#x27;</span></span><br><span class="line">HISTSIZE=1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Colored Aliases ---</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">&#x27;grep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> fgrep=<span class="string">&#x27;fgrep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> egrep=<span class="string">&#x27;egrep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls -CF&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Colors ---</span></span><br><span class="line">C_GREEN=$<span class="string">&#x27;\033[0;32m&#x27;</span></span><br><span class="line">C_BLUE=$<span class="string">&#x27;\033[0;34m&#x27;</span></span><br><span class="line">C_RED=$<span class="string">&#x27;\033[0;31m&#x27;</span></span><br><span class="line">C_RESET=$<span class="string">&#x27;\033[0m&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Prompt ---</span></span><br><span class="line"><span class="keyword">if</span> (( USER_ID )); <span class="keyword">then</span></span><br><span class="line">  PROMPT_CHAR=<span class="string">&#x27;$&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  PROMPT_CHAR=<span class="string">&#x27;#&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">EXIT_CODE_PROMPT=<span class="string">&#x27;$&#123;|</span></span><br><span class="line"><span class="string">  local e=$?</span></span><br><span class="line"><span class="string">  (( e )) &amp;&amp; REPLY+=&quot;$&#123;C_RED&#125;$e$&#123;C_RESET&#125;|&quot;</span></span><br><span class="line"><span class="string">  return $e</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">PS1=<span class="string">&quot;$EXIT_CODE_PROMPT<span class="variable">$&#123;C_GREEN&#125;</span>\$HOSTNAME<span class="variable">$&#123;C_RESET&#125;</span>:<span class="variable">$&#123;C_BLUE&#125;</span>\$&#123;PWD:-?&#125;<span class="variable">$&#123;C_RESET&#125;</span> <span class="variable">$&#123;PROMPT_CHAR&#125;</span> &quot;</span></span><br></pre></td></tr></table></figure><div class="note info modern"><p>使配置生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /system/etc/mkshrc</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Adb </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Adb </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux/Ubuntu su后前缀用户丢失颜色</title>
      <link href="/2025/08/08/Unix/Linux%20su%E5%90%8E%E5%89%8D%E7%BC%80%E4%B8%A2%E5%A4%B1%E9%A2%9C%E8%89%B2/"/>
      <url>/2025/08/08/Unix/Linux%20su%E5%90%8E%E5%89%8D%E7%BC%80%E4%B8%A2%E5%A4%B1%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>sudo nvim &#x2F;root&#x2F;.bashrc -&gt; <code>force_color_prompt=yes</code> 取消注释这一行</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Unix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim全选复制</title>
      <link href="/2025/08/08/Vim/Vim%E5%85%A8%E9%80%89%E5%A4%8D%E5%88%B6/"/>
      <url>/2025/08/08/Vim/Vim%E5%85%A8%E9%80%89%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在普通模式下输入 :echo has(‘clipboard’)，然后按 Enter。 如果返回 1，说明你的 Vim 支持系统剪贴板。 如果返回 0，说明你的 Vim 不支持。</p></blockquote><blockquote><p>安装neovim，默认支持，输入ggvG”+y</p></blockquote><ul><li><p>“：告诉 Neovim 你要使用一个寄存器来操作。</p></li><li><p>+：指定使用系统剪贴板寄存器。这是 Neovim 与系统剪贴板通信的关键。</p></li><li><p>y：执行复制（yank）操作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin/Native Windows 本机库开发指南</title>
      <link href="/2025/07/24/Kotlin/Kotlin%20Native%20Library/"/>
      <url>/2025/07/24/Kotlin/Kotlin%20Native%20Library/</url>
      
        <content type="html"><![CDATA[<h2 id="Ⅰ-Kotlin-x2F-Native-简介"><a href="#Ⅰ-Kotlin-x2F-Native-简介" class="headerlink" title="Ⅰ. Kotlin&#x2F;Native 简介"></a>Ⅰ. Kotlin&#x2F;Native 简介</h2><p>Kotlin&#x2F;Native 是一项将 Kotlin 代码直接编译为本机二进制文件（无需 JVM）的技术。其核心优势在于：</p><ul><li><strong>高效执行</strong>：基于 LLVM 后端，生成针对特定平台优化的机器码。</li><li><strong>无缝互操作</strong>：可以轻松调用 C&#x2F;C++ 等系统原生库。</li><li><strong>跨平台支持</strong>：最初为 iOS 设计，现已扩展至 Windows, Linux, macOS, Android 等多个平台。</li></ul><hr><h2 id="Ⅱ-Windows-平台本机库概览"><a href="#Ⅱ-Windows-平台本机库概览" class="headerlink" title="Ⅱ. Windows 平台本机库概览"></a>Ⅱ. Windows 平台本机库概览</h2><p>在 Windows 系统中，代码库主要有以下几种形式，了解它们的区别对于开发至关重要。</p><table><thead><tr><th align="center">文件类型</th><th align="center">扩展名</th><th align="left">功能</th><th align="left">类比</th></tr></thead><tbody><tr><td align="center"><strong>动态链接库</strong></td><td align="center"><code>.dll</code></td><td align="left">在程序运行时按需加载，可被多个程序共享。</td><td align="left">Linux <code>.so</code></td></tr><tr><td align="center"><strong>静态链接库</strong></td><td align="center"><code>.lib</code></td><td align="left">在编译链接阶段，其代码被完整复制到最终的可执行文件中。</td><td align="left">Linux <code>.a</code></td></tr><tr><td align="center"><strong>导入库</strong></td><td align="center"><code>.lib</code></td><td align="left">同样是 <code>.lib</code> 文件，但它仅包含符号引用，用于告诉链接器去哪里找对应的 <code>.dll</code>。</td><td align="left">-</td></tr></tbody></table><blockquote><p>💡 <strong><code>.lib</code> 文件的“双重身份”</strong></p><p>Windows 下的 <code>.lib</code> 文件存在歧义：</p><ol><li>**静态库 (Static Library)**：包含完整的二进制代码（<code>.obj</code> 文件的集合），由 <code>cl.exe</code> (MSVC) 或 <code>ar</code> (MinGW) 生成，文件体积较大。</li><li>**导入库 (Import Library)**：仅包含一个指向 <code>.dll</code> 的符号列表和元数据，本身不含任何可执行代码。它在链接时使用，文件体积非常小 (通常只有几 KB)。</li></ol></blockquote><hr><h2 id="Ⅲ-实战：创建并使用-Kotlin-x2F-Native-动态库"><a href="#Ⅲ-实战：创建并使用-Kotlin-x2F-Native-动态库" class="headerlink" title="Ⅲ. 实战：创建并使用 Kotlin&#x2F;Native 动态库"></a>Ⅲ. 实战：创建并使用 Kotlin&#x2F;Native 动态库</h2><p>本节将完整演示如何使用 Kotlin&#x2F;Native 创建一个 <code>.dll</code> 动态库，并再创建一个 Kotlin&#x2F;Native 程序来调用它。</p><blockquote><p>📦 <strong>环境准备</strong></p><ul><li><strong>Gradle 项目</strong>: 建议使用官方提供的 KMP 模板项目 <code>git clone https://github.com/Kotlin/kmp-native-wizard.git</code></li><li><strong>Visual Studio Build Tools</strong>: 用于生成导入库 <code>.lib</code> 文件。它比完整的 Visual Studio 更轻量。<ul><li><a href="https://visualstudio.microsoft.com/downloads/">下载地址</a> (选择 Tools for Visual Studio -&gt; Build Tools for Visual Studio)。</li></ul></li></ul></blockquote><h3 id="第-1-阶段：创建-Kotlin-x2F-Native-动态库-dll"><a href="#第-1-阶段：创建-Kotlin-x2F-Native-动态库-dll" class="headerlink" title="第 1 阶段：创建 Kotlin&#x2F;Native 动态库 (.dll)"></a>第 1 阶段：创建 Kotlin&#x2F;Native 动态库 (<code>.dll</code>)</h3><h4 id="步骤-1-配置-Gradle-构建脚本"><a href="#步骤-1-配置-Gradle-构建脚本" class="headerlink" title="步骤 1: 配置 Gradle 构建脚本"></a>步骤 1: 配置 Gradle 构建脚本</h4><p>在 <code>build.gradle.kts</code> 文件中，声明我们的目标平台为 <code>mingwX64</code>，并配置生成一个动态库。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build.gradle.kts</span></span><br><span class="line">kotlin &#123;</span><br><span class="line">    <span class="comment">// 仅针对 Windows MinGW 64位平台</span></span><br><span class="line">    mingwX64(<span class="string">&quot;native&quot;</span>) &#123; <span class="comment">// &quot;native&quot; 是一个自定义的目标名称</span></span><br><span class="line">        binaries &#123;</span><br><span class="line">            <span class="comment">// 配置生成一个名为 &quot;mordecai&quot; 的动态库 (mordecai.dll)</span></span><br><span class="line">            sharedLib &#123;</span><br><span class="line">                baseName = <span class="string">&quot;mordecai&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤-2-编写要导出的-Kotlin-代码"><a href="#步骤-2-编写要导出的-Kotlin-代码" class="headerlink" title="步骤 2: 编写要导出的 Kotlin 代码"></a>步骤 2: 编写要导出的 Kotlin 代码</h4><p>创建一个 Kotlin 文件，并使用 <code>@CName</code> 注解来导出一个函数，使其能被 C&#x2F;C++ 调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/nativeMain/kotlin/Mordecai.kt</span></span><br><span class="line"><span class="keyword">import</span> kotlin.experimental.ExperimentalNativeApi</span><br><span class="line"></span><br><span class="line"><span class="comment">// @CName 将此函数导出为 C 语言符号 &quot;sayHelloFromKotlinNative&quot;</span></span><br><span class="line"><span class="meta">@CName(<span class="string">&quot;sayHelloFromKotlinNative&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello, this message is from Kotlin/Native!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤-3-编译生成动态库"><a href="#步骤-3-编译生成动态库" class="headerlink" title="步骤 3: 编译生成动态库"></a>步骤 3: 编译生成动态库</h4><p>执行 Gradle 任务来编译项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行此命令</span></span><br><span class="line">./gradlew linkNativeDebugShared   <span class="comment"># 或 linkNativeReleaseShared</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译成功后，产物会出现在以下目录：</span></span><br><span class="line"><span class="comment"># build/bin/native/debugShared/mordecai.dll</span></span><br><span class="line"><span class="comment"># build/bin/native/debugShared/mordecai.def</span></span><br><span class="line"><span class="comment"># build/bin/native/debugShared/mordecai_api.h</span></span><br></pre></td></tr></table></figure><p>产物说明：</p><ul><li><code>mordecai.dll</code>: 核心的动态库文件。</li><li><code>mordecai.def</code>: 模块定义文件，描述了 DLL 导出的函数。</li><li><code>mordecai_api.h</code>: C&#x2F;C++ 头文件，包含了导出函数的声明。</li></ul><h3 id="第-2-阶段：在-Kotlin-x2F-Native-程序中调用动态库"><a href="#第-2-阶段：在-Kotlin-x2F-Native-程序中调用动态库" class="headerlink" title="第 2 阶段：在 Kotlin&#x2F;Native 程序中调用动态库"></a>第 2 阶段：在 Kotlin&#x2F;Native 程序中调用动态库</h3><p>现在，我们将创建一个可执行文件 (<code>.exe</code>) 来调用刚刚生成的 <code>.dll</code>。</p><h4 id="步骤-4-生成导入库-lib"><a href="#步骤-4-生成导入库-lib" class="headerlink" title="步骤 4: 生成导入库 (.lib)"></a>步骤 4: 生成导入库 (<code>.lib</code>)</h4><p>为了让链接器能够识别 <code>.dll</code> 中的函数，我们需要从 <code>.def</code> 文件生成一个导入库 <code>.lib</code>。</p><ol><li><p>打开 <code>x64 Native Tools Command Prompt for VS 2022</code> (通过开始菜单搜索)。</p></li><li><p>进入 DLL 所在的目录。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> path\to\your\project\build\bin\native\debugShared</span><br></pre></td></tr></table></figure></li><li><p>执行 <code>lib.exe</code> 命令生成导入库。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /def: 指定定义文件</span></span><br><span class="line"><span class="comment"># /out: 指定输出的导入库文件名</span></span><br><span class="line"><span class="comment"># /machine:x64 必须指定目标平台为 x64，否则可能因架构不匹配而链接失败</span></span><br><span class="line">lib /def:mordecai.def /out:mordecai.lib /machine:x64</span><br></pre></td></tr></table></figure></li></ol><p>   执行完毕后，当前目录下会生成 <code>mordecai.lib</code> 文件。</p><h4 id="步骤-5-组织-C-互操作文件"><a href="#步骤-5-组织-C-互操作文件" class="headerlink" title="步骤 5: 组织 C 互操作文件"></a>步骤 5: 组织 C 互操作文件</h4><p>为了让 Kotlin&#x2F;Native 的 C 互操作工具 (<code>cinterop</code>) 能够找到库文件和头文件，我们需要将它们组织到项目中。</p><ol><li><p>在 <code>src/</code> 目录下创建以下结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">└── nativeInterop/</span><br><span class="line">    └── cinterop/</span><br><span class="line">        ├── include/      # 存放头文件</span><br><span class="line">        │   └── mordecai_api.h</span><br><span class="line">        └── libs/         # 存放库文件</span><br><span class="line">            ├── mordecai.dll</span><br><span class="line">            └── mordecai.lib</span><br></pre></td></tr></table></figure></li><li><p><strong>拷贝文件</strong>：</p><ul><li>将步骤 3 生成的 <code>mordecai_api.h</code> 拷贝到 <code>include/</code> 目录。</li><li>将步骤 3 生成的 <code>mordecai.dll</code> 和步骤 4 生成的 <code>mordecai.lib</code> 拷贝到 <code>libs/</code> 目录。</li></ul></li></ol><h4 id="步骤-6-配置-C-互操作-cinterop"><a href="#步骤-6-配置-C-互操作-cinterop" class="headerlink" title="步骤 6: 配置 C 互操作 (cinterop)"></a>步骤 6: 配置 C 互操作 (<code>cinterop</code>)</h4><p>回到 <code>build.gradle.kts</code>，添加 <code>cinterop</code> 配置，告诉 Kotlin 如何与我们的 C 库进行交互。同时，添加一个 <code>executable</code> 配置来生成 <code>.exe</code> 文件。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build.gradle.kts</span></span><br><span class="line">kotlin &#123;</span><br><span class="line">    mingwX64(<span class="string">&quot;native&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// ... sharedLib 配置保留 ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增 executable 配置，用于生成 .exe 文件</span></span><br><span class="line">        binaries &#123;</span><br><span class="line">            sharedLib &#123; baseName = <span class="string">&quot;mordecai&quot;</span> &#125; <span class="comment">// 可以保留</span></span><br><span class="line">            executable &#123;</span><br><span class="line">                <span class="comment">// entryPoint 的默认值就是 &quot;main&quot;，可以省略</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        compilations.getByName(<span class="string">&quot;main&quot;</span>) &#123;</span><br><span class="line">            cinterops &#123;</span><br><span class="line">                <span class="comment">// 创建一个名为 &quot;mordecai&quot; 的 cinterop 配置</span></span><br><span class="line">                <span class="keyword">val</span> mordecai <span class="keyword">by</span> creating &#123;</span><br><span class="line">                    <span class="comment">// 指定 .def 文件，cinterop 会据此生成 Kotlin 绑定</span></span><br><span class="line">                    defFile(project.file(<span class="string">&quot;src/nativeInterop/cinterop/mordecai.def&quot;</span>))</span><br><span class="line">                    <span class="comment">// 添加头文件搜索路径</span></span><br><span class="line">                    includeDirs(<span class="string">&quot;src/nativeInterop/cinterop/include&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，创建 <code>src/nativeInterop/cinterop/mordecai.def</code> 文件，用于指导 <code>cinterop</code> 工具。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># src/nativeInterop/cinterop/mordecai.def</span><br><span class="line"></span><br><span class="line"># 生成的 Kotlin 代码将位于此包下</span><br><span class="line">package = com.mordecai.kn.tools</span><br><span class="line"></span><br><span class="line"># 需要解析的头文件</span><br><span class="line">headers = mordecai_api.h</span><br><span class="line"></span><br><span class="line"># 链接器选项</span><br><span class="line"># -L: 指定库文件的搜索路径</span><br><span class="line"># -l: 指定要链接的库名 (mordecai.lib -&gt; -lmordecai)</span><br><span class="line">linkerOpts.mingw_x64 = -Lsrc/nativeInterop/cinterop/libs -lmordecai</span><br></pre></td></tr></table></figure><p>配置完成后，<strong>同步 Gradle 项目</strong> (Sync Project with Gradle Files)，<code>cinterop</code> 会自动运行并生成 Kotlin 绑定代码。</p><h4 id="步骤-7-编写主程序并运行"><a href="#步骤-7-编写主程序并运行" class="headerlink" title="步骤 7: 编写主程序并运行"></a>步骤 7: 编写主程序并运行</h4><p>现在可以编写 <code>main</code> 函数来调用库中的 <code>sayHelloFromKotlinNative</code> 函数了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/nativeMain/kotlin/Main.kt</span></span><br><span class="line"><span class="keyword">import</span> com.mordecai.kn.tools.sayHelloFromKotlinNative</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Calling the function from our DLL...&quot;</span>)</span><br><span class="line">    sayHelloFromKotlinNative()</span><br><span class="line">    println(<span class="string">&quot;Call finished.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 Gradle 任务来运行程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew runDebugExecutableMingwX64</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ <strong>运行时错误？</strong></p><p>第一次运行时，你可能会遇到一个错误，提示找不到 <code>mordecai.dll</code>。这是因为 <code>.exe</code> 在运行时需要在其所在目录或系统路径中找到它依赖的 <code>.dll</code> 文件。</p><p><strong>解决方案</strong>：将 <code>src/nativeInterop/cinterop/libs/mordecai.dll</code> 文件手动复制到可执行文件的输出目录 <code>build/bin/native/debugExecutable/</code> 下，然后再次运行命令即可成功。</p></blockquote><hr><h2 id="Ⅳ-简化流程：使用静态库"><a href="#Ⅳ-简化流程：使用静态库" class="headerlink" title="Ⅳ. 简化流程：使用静态库"></a>Ⅳ. 简化流程：使用静态库</h2><p>如果不想处理 <code>.dll</code> 运行时依赖的问题，可以选择静态链接。这会将库代码直接编译进最终的 <code>.exe</code> 文件中，使其成为一个独立的单文件程序，但会增加可执行文件的体积。</p><ol><li><p><strong>配置 Gradle 生成静态库</strong>：<br>在 <code>build.gradle.kts</code> 的 <code>binaries</code> 块中，添加 <code>staticLib</code> 配置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kotlin &#123;</span><br><span class="line">    mingwX64(<span class="string">&quot;native&quot;</span>) &#123;</span><br><span class="line">        binaries &#123;</span><br><span class="line">            <span class="comment">// 生成静态库 mordecai.a (MinGW 默认) 或 mordecai.lib (MSVC)</span></span><br><span class="line">            staticLib &#123; baseName = <span class="string">&quot;mordecai&quot;</span> &#125;</span><br><span class="line">            executable() <span class="comment">// 保持可执行文件配置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... cinterop 配置保持不变 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编译生成静态库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew linkNativeDebugStatic <span class="comment"># 或 linkNativeReleaseStatic</span></span><br></pre></td></tr></table></figure><p>这会在 <code>build/bin/native/debugStatic/</code> 目录下生成 <code>libmordecai.a</code> 文件。</p></li><li><p><strong>组织并链接</strong>：</p><ul><li>将 <code>libmordecai.a</code> 和 <code>mordecai_api.h</code> 拷贝到 <code>src/nativeInterop/cinterop/</code> 下对应的 <code>libs</code> 和 <code>include</code> 目录。</li><li><code>mordecai.def</code> 文件中的 <code>linkerOpts</code> 配置保持不变，链接器会自动识别并使用 <code>.a</code> 文件。</li><li>同步 Gradle 项目。</li></ul></li><li><p><strong>直接运行</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew runDebugExecutableMingwX64</span><br></pre></td></tr></table></figure><p>由于所有代码都已链接进 <code>.exe</code>，这次无需再手动拷贝任何文件，程序可以直接运行。</p></li></ol><hr><h2 id="Ⅴ-总结"><a href="#Ⅴ-总结" class="headerlink" title="Ⅴ. 总结"></a>Ⅴ. 总结</h2><p>本文详细介绍了在 Windows 平台上使用 Kotlin&#x2F;Native 创建和消费原生库的两种主要方式：</p><ul><li><strong>动态链接</strong>：通过 <code>.dll</code> 和导入库 <code>.lib</code> 实现。优点是代码共享、模块化更新；缺点是需要处理运行时依赖。</li><li><strong>静态链接</strong>：通过静态库 <code>.a</code> 或 <code>.lib</code> 实现。优点是部署简单、单文件分发；缺点是可执行文件体积较大。</li></ul><p>掌握这两种技术，可以让你无缝地将 Kotlin&#x2F;Native 集成到现有的 C&#x2F;C++ 项目中，或者为其他语言提供高性能的 Kotlin 库。</p><blockquote><p>⭐ <strong>参考源码与自动化插件</strong></p><p>本文所有流程的实现代码，以及一个可以自动拷贝依赖文件的 Gradle 插件，都可以在以下仓库找到：<br><a href="https://github.com/crowforkotlin/mordecai-kn-mingw-example">https://github.com/crowforkotlin/mordecai-kn-mingw-example</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Kotlin Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用mklink节省磁盘空间</title>
      <link href="/2025/07/21/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/%E5%88%A9%E7%94%A8mklink%E8%8A%82%E7%9C%81%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4/"/>
      <url>/2025/07/21/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/%E5%88%A9%E7%94%A8mklink%E8%8A%82%E7%9C%81%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>he <code>mklink</code> command in Windows is used to create symbolic links (also known as symlinks), hard links, or directory junctions. These links act as pointers to other files or directories, allowing you to access them from a different location as if they were there.</p><p>Windows 中的 mklink 命令用于创建符号链接 (也称为 symlink)、硬链接或目录连接。这些链接充当指向其他文件或目录的指针，允许您从其他位置访问它们，就好像它们就在那里一样。</p></blockquote><blockquote><p>In your specific command, <code>mklink /D &quot;C:\Users\CrowF\.vscode&quot; &quot;D:\software\cache\&quot;</code>, you are using the <code>/D</code> switch. This switch indicates that you are creating a directory symbolic link.</p><p>在您的具体命令 mklink &#x2F;D “C:\Users\CrowF.vscode” “D:\software\cache&quot; 中 ，您使用了 &#x2F;D 开关。此开关表示您正在创建目录符号链接 。</p></blockquote><p>Here’s a breakdown of what your command does:</p><ul><li><p><strong><code>mklink</code></strong>: The command to create a link.<br>mklink ：创建链接的命令。</p></li><li><p><strong><code>/D</code></strong>: Specifies that the link being created is for a directory.<br>&#x2F;D ：指定正在创建的链接用于目录。</p></li><li><p><strong><code>&quot;C:\Users\CrowF\.vscode&quot;</code></strong>: This is the <em>link name</em> or the path where the symbolic link will be created. In this case, it’s creating a link in your <code>.vscode</code> folder.<br>“C:\Users\CrowF.vscode” ：这是链接名称或将创建符号链接的路径。在本例中，它将在 .vscode 文件夹中创建一个链接。</p></li><li><p><strong><code>&quot;D:\software\cache\&quot;</code></strong>: This is the <em>target</em> path. The symbolic link at <code>C:\Users\CrowF\.vscode</code> will point to this directory.<br>“D:\software\cache&quot; ：这是目标路径。C :\Users\CrowF.vscode 的符号链接将指向此目录。</p></li></ul><p><strong>Essentially, this command makes your <code>.vscode</code> folder on the C: drive act as a shortcut to the <code>D:\software\cache\</code> directory.</strong> This is often used to save space on the C: drive or to redirect application data to a larger storage location.<br>本质上，此命令使 C: 盘上的 .vscode 文件夹充当 D:\software\cache\ 目录的快捷方式。 这通常用于节省 C: 盘空间或将应用程序数据重定向到更大的存储位置。</p>]]></content>
      
      
      <categories>
          
          <category> Command </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adb Shell 分配伪终端解决方案</title>
      <link href="/2025/07/02/Android/Adb%20shell%20%E5%88%86%E9%85%8D%E4%BC%AA%E7%BB%88%E7%AB%AF/"/>
      <url>/2025/07/02/Android/Adb%20shell%20%E5%88%86%E9%85%8D%E4%BC%AA%E7%BB%88%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="🔧-问题描述"><a href="#🔧-问题描述" class="headerlink" title="🔧 问题描述"></a>🔧 问题描述</h2><div class="note warning modern"><p>在通过 <code>adb shell</code> 执行 shell 脚本时，遇到了权限拒绝的问题。即使分配了 root 权限，在 shell 外部执行脚本仍然会失败。</p></div><h2 id="💡-解决方案"><a href="#💡-解决方案" class="headerlink" title="💡 解决方案"></a>💡 解决方案</h2><h3 id="方法一：使用-t-参数"><a href="#方法一：使用-t-参数" class="headerlink" title="方法一：使用 -t 参数"></a>方法一：使用 -t 参数</h3><div class="note info modern"><p>通过搜索发现需要为 adb shell 分配伪终端，使用 <code>-t</code> 参数：</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell -t <span class="string">&quot;/sdcard/&lt;your_shell&gt;.sh&quot;</span></span><br></pre></td></tr></table></figure><h3 id="方法二：在构建脚本中使用"><a href="#方法二：在构建脚本中使用" class="headerlink" title="方法二：在构建脚本中使用"></a>方法二：在构建脚本中使用</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">Gradle</button><button type="button" class="tab">Java ProcessBuilder</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec &#123;</span><br><span class="line">    commandLine(<span class="string">&quot;adb&quot;</span>, <span class="string">&quot;shell&quot;</span>, <span class="string">&quot;-t&quot;</span>, <span class="string">&quot;/sdcard/&lt;your_shell&gt;.sh&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProcessBuilder(<span class="string">&quot;powershell&quot;</span>, <span class="string">&quot;-c&quot;</span>,<span class="string">&quot;\&quot;adb shell -t \&quot;sh /sdcard/1.sh\&quot;\&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="⚠️-常见错误"><a href="#⚠️-常见错误" class="headerlink" title="⚠️ 常见错误"></a>⚠️ 常见错误</h2><div class="note danger modern"><p><strong>错误信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remote PTY will not be allocated because stdin is not a terminal.</span><br></pre></td></tr></table></figure></div><h2 id="✅-最终解决方案"><a href="#✅-最终解决方案" class="headerlink" title="✅ 最终解决方案"></a>✅ 最终解决方案</h2><div class="note success modern"><p><strong>使用 <code>-tt</code> 参数</strong><br>在 <code>-t</code> 后面再加一个 <code>t</code>，即使用 <code>-tt</code> 参数来强制分配伪终端。</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell -tt <span class="string">&quot;/sdcard/&lt;your_shell&gt;.sh&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Adb </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 离屏渲染详解</title>
      <link href="/2025/07/02/Android/Android%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"/>
      <url>/2025/07/02/Android/Android%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>📚 <strong>本文导读</strong><br>本文将从基础概念出发，详细讲解Android中的离屏渲染技术，包括其工作原理、应用场景以及性能优化策略。通过代码示例和对比分析，帮助开发者深入理解这一重要的图形渲染技术。</p></div><h2 id="📖-什么是离屏渲染？"><a href="#📖-什么是离屏渲染？" class="headerlink" title="📖 什么是离屏渲染？"></a>📖 什么是离屏渲染？</h2><div class="note primary modern"><p><strong>离屏渲染（Off-Screen Rendering）</strong><br>离屏渲染是指将图形内容渲染到一个不直接显示在屏幕上的缓冲区中，而不是直接渲染到屏幕上的帧缓冲区。这个过程创建了一个中间的渲染目标，可以在后续的渲染过程中被重复使用或进行额外的处理。</p></div><h2 id="🎨-效果对比演示"><a href="#🎨-效果对比演示" class="headerlink" title="🎨 效果对比演示"></a>🎨 效果对比演示</h2><h3 id="📱-普通绘制效果"><a href="#📱-普通绘制效果" class="headerlink" title="📱 普通绘制效果"></a>📱 普通绘制效果</h3><div class="note info modern"><p><strong>未使用离屏渲染的原始效果</strong><br>下图展示了直接在画布上绘制红色方块、文本和绿色方块的效果，没有应用任何合成模式。</p></div><p><img src="https://gitlab.com/crowforkotlin/page-storage/-/raw/main/image/post/img02.png" alt="普通绘制效果"></p><h3 id="🎯-离屏渲染效果"><a href="#🎯-离屏渲染效果" class="headerlink" title="🎯 离屏渲染效果"></a>🎯 离屏渲染效果</h3><div class="note success modern"><p><strong>绘制顺序分析</strong></p><ol><li>🔴 红色方块 → 📝 文本 → 🟢 绿色方块</li></ol><p>下图展示了使用离屏渲染后的效果，绿色方块覆盖在文本上，并设置合成模式为 <code>SRC_IN</code>。</p></div><p><img src="https://gitlab.com/crowforkotlin/page-storage/-/raw/main/image/post/img01.png" alt="离屏渲染效果图"></p><h3 id="🔍-合成模式详解"><a href="#🔍-合成模式详解" class="headerlink" title="🔍 合成模式详解"></a>🔍 合成模式详解</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">SRC_IN模式</button><button type="button" class="tab">为什么不是红色方块</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="note warning modern"><p><strong>SRC_IN 模式含义</strong><br>保持覆盖目标像素的源像素，丢弃剩余的源和目标像素。</p><ul><li><strong>目标像素</strong>：绿色方块</li><li><strong>源像素</strong>：文本</li></ul></div></div><div class="tab-item-content"><div class="note blue modern"><p><strong>图层分离机制</strong><br>在绘制完红色方块后，通过 <code>canvas.saveLayer()</code> 创建了一个离屏渲染层。这个图层会在绘制完文本后，才会被合成到屏幕上。就是在一个新的Canvas上作画，这个图层只包含了文本和绿色方块。</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="⚡-saveLayer-vs-save-对比"><a href="#⚡-saveLayer-vs-save-对比" class="headerlink" title="⚡ saveLayer vs save 对比"></a>⚡ saveLayer vs save 对比</h3><div class="note orange modern"><p><strong>关键区别</strong></p><ul><li><code>save()</code>：只保存变换矩阵、裁剪区域等状态</li><li><code>saveLayer()</code>：创建新的图层，合成模式仅影响该图层</li></ul></div><blockquote><p>上面效果所示，绿色方块覆盖在文本上。此时设置合成模式为SRC_IN，意思就是“保持覆盖目标像素的源像素，丢弃剩余的源和目标像素。这里目标像素是绿色方块，源像素是文本。这里说明一下为什么不是红色方块，因为在绘制完红色方块后，这里通过canvas.saveLayer()创建了一个离屏渲染的，这个图层会在绘制完文本后，才会被合成到屏幕上。就是在一个新的Canvas上作画，这个图层只包含了文本和绿色方块。如果这里不选择使用saveLayer而是save()这种操作的话只会保存变换矩阵、裁剪区域等状态。合成模式还是会针对这个主画布进行影响，而saveLayer恰好解决了这个问题</p></blockquote><h2 id="⚠️-性能注意事项"><a href="#⚠️-性能注意事项" class="headerlink" title="⚠️ 性能注意事项"></a>⚠️ 性能注意事项</h2><div class="note danger modern"><p><strong>性能警告</strong><br>官方说明 <code>saveLayer</code> API 需要谨慎使用，性能、内存消耗过大，只有复杂视图才需要这种实现效果。</p></div><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">内存分配</button><button type="button" class="tab">绘制开销</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="note red modern"><p><strong>内存占用计算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存占用 = width × height × 4字节(RGBA) × 采样倍数（例如抗锯齿）</span><br></pre></td></tr></table></figure></div></div><div class="tab-item-content"><div class="note red modern"><p><strong>双重绘制</strong></p><ol><li>在新的画布绘制一次</li><li>合成到主画布上绘制一次</li></ol></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="💻-代码实现"><a href="#💻-代码实现" class="headerlink" title="💻 代码实现"></a>💻 代码实现</h2><h3 id="🎯-方法一：使用-saveLayer"><a href="#🎯-方法一：使用-saveLayer" class="headerlink" title="🎯 方法一：使用 saveLayer"></a>🎯 方法一：使用 saveLayer</h3><details class="toggle" ><summary class="toggle-button" style="">查看 saveLayer 实现代码</summary><div class="toggle-content"><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LayerView</span> : <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context) : <span class="keyword">super</span>(context)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet) : <span class="keyword">super</span>(context, attrs)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet, style: <span class="built_in">Int</span>) : <span class="keyword">super</span>(context, attrs, style)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制背景红色方块</span></span><br><span class="line">        canvas.withSave &#123; </span><br><span class="line">            canvas.drawRect(<span class="number">200f</span>, <span class="number">200f</span>, <span class="number">600f</span>, <span class="number">600f</span>, Paint().apply &#123; </span><br><span class="line">                color = Color.RED </span><br><span class="line">            &#125;) </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建离屏渲染图层</span></span><br><span class="line">        <span class="keyword">val</span> layerPointer = canvas.saveLayer(<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在图层上绘制文本</span></span><br><span class="line">        canvas.drawText(<span class="string">&quot;文本A&quot;</span>, <span class="number">300f</span>, <span class="number">300f</span>, Paint().apply &#123;</span><br><span class="line">            color = Color.WHITE</span><br><span class="line">            textSize = <span class="number">50f</span></span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在图层上绘制绿色方块（使用SRC_IN合成模式）</span></span><br><span class="line">        canvas.drawRect(<span class="number">300f</span>, <span class="number">280f</span>, <span class="number">500f</span>, <span class="number">500f</span>, Paint().apply &#123;</span><br><span class="line">            xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)</span><br><span class="line">            color = Color.GREEN</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 恢复图层</span></span><br><span class="line">        canvas.restoreToCount(layerPointer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><h3 id="🎯-方法二：使用-Bitmap-离屏渲染实现类似savelayer方式"><a href="#🎯-方法二：使用-Bitmap-离屏渲染实现类似savelayer方式" class="headerlink" title="🎯 方法二：使用 Bitmap 离屏渲染实现类似savelayer方式"></a>🎯 方法二：使用 Bitmap 离屏渲染实现类似savelayer方式</h3><div class="note info modern"><p><strong>替代方案</strong><br>通过手动创建 Bitmap 和 Canvas 来实现离屏渲染，可以更精确地控制内存和性能。</p></div><details class="toggle" ><summary class="toggle-button" style="">查看 Bitmap 实现代码</summary><div class="toggle-content"><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LayerView</span> : <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context) : <span class="keyword">super</span>(context)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet) : <span class="keyword">super</span>(context, attrs)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet, style: <span class="built_in">Int</span>) : <span class="keyword">super</span>(context, attrs, style)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> offscreenCanvas = Canvas()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> offscreenBitmap: Bitmap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        MainScope().launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            invalidate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSizeChanged</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>, oldw: <span class="type">Int</span>, oldh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">        </span><br><span class="line">        CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class="line">            <span class="keyword">val</span> createTime = measureTimeMillis &#123;</span><br><span class="line">                <span class="comment">// 创建离屏Bitmap</span></span><br><span class="line">                offscreenBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)</span><br><span class="line">                offscreenCanvas = Canvas(offscreenBitmap)</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(<span class="string">&quot;LayerView&quot;</span>, <span class="string">&quot;创建bitmap及canvas耗时: <span class="subst">$&#123;createTime&#125;</span>ms&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在离屏画布上绘制大量元素</span></span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                offscreenCanvas.drawText(</span><br><span class="line">                    <span class="string">&quot;数值A&quot;</span>, </span><br><span class="line">                    (<span class="number">0.</span><span class="number">.300</span>).random().toFloat(), </span><br><span class="line">                    (<span class="number">0.</span><span class="number">.400</span>).random().toFloat(), </span><br><span class="line">                    Paint().apply &#123;</span><br><span class="line">                        color = Color.WHITE</span><br><span class="line">                        textSize = <span class="number">50f</span></span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">                </span><br><span class="line">                offscreenCanvas.drawRect(<span class="number">300f</span>, <span class="number">290f</span>, <span class="number">500f</span>, <span class="number">500f</span>, Paint().apply &#123;</span><br><span class="line">                    color = Color.GREEN</span><br><span class="line">                    xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制背景红色方块</span></span><br><span class="line">        canvas.withSave &#123; </span><br><span class="line">            canvas.drawRect(<span class="number">200f</span>, <span class="number">200f</span>, <span class="number">600f</span>, <span class="number">600f</span>, Paint().apply &#123; </span><br><span class="line">                color = Color.RED </span><br><span class="line">            &#125;) </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将离屏渲染的结果绘制到主画布</span></span><br><span class="line">        <span class="keyword">if</span> (::offscreenBitmap.isInitialized) &#123;</span><br><span class="line">            <span class="keyword">val</span> drawTime = measureNanoTime &#123; </span><br><span class="line">                canvas.drawBitmap(offscreenBitmap, <span class="number">0f</span>, <span class="number">0f</span>, Paint()) </span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(<span class="string">&quot;LayerView&quot;</span>, <span class="string">&quot;绘制bitmap耗时: <span class="subst">$&#123;drawTime&#125;</span>ns&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><h2 id="📊-性能对比分析"><a href="#📊-性能对比分析" class="headerlink" title="📊 性能对比分析"></a>📊 性能对比分析</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">saveLayer方式</button><button type="button" class="tab">Bitmap方式</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="note warning modern"><p><strong>saveLayer 特点</strong></p><ul><li>✅ 使用简单，API直接支持</li><li>❌ 内存占用大，系统自动管理</li><li>❌ 性能开销较大</li><li>⚠️ 适合简单的合成效果</li></ul></div></div><div class="tab-item-content"><div class="note success modern"><p><strong>Bitmap 特点</strong></p><ul><li>✅ 内存可控，可手动回收</li><li>✅ 性能上可控，特别是重复使用时</li><li>✅ 可在子线程处理</li><li>✅ 灵活性更高</li><li>❌ 需要手动管理生命周期</li></ul></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🎯-最佳实践建议"><a href="#🎯-最佳实践建议" class="headerlink" title="🎯 最佳实践建议"></a>🎯 最佳实践建议</h2><div class="note primary modern"><p><strong>选择建议</strong></p><ol><li><strong>简单合成效果</strong>：使用 <code>saveLayer</code></li><li><strong>复杂图形处理</strong>：使用 Bitmap 离屏渲染</li><li><strong>频繁重绘场景</strong>：优先考虑 Bitmap 方式</li><li><strong>内存敏感应用</strong>：谨慎使用离屏渲染</li></ol></div><div class="note success modern"><p><strong>优化技巧</strong></p><ul><li>🔧 合理控制离屏画布尺寸</li><li>🔧 及时回收 Bitmap 资源</li><li>🔧 避免在 onDraw 中创建 Bitmap</li><li>🔧 考虑使用硬件加速</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BlurMaskFilter 内存泄露</title>
      <link href="/2025/07/02/Android/BlurMaskFilter%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
      <url>/2025/07/02/Android/BlurMaskFilter%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如标题，参考源码和效果</p></blockquote><blockquote><p><a href="https://github.com/crowforkotlin/android-canvas-drawline-blur-leak">https://github.com/crowforkotlin/android-canvas-drawline-blur-leak</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> 内存泄露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>① Hexo搭建并使用Butterfly主题</title>
      <link href="/2025/06/28/HEXO/01Hexo%E6%90%AD%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8Butterfly%E4%B8%BB%E9%A2%98/"/>
      <url>/2025/06/28/HEXO/01Hexo%E6%90%AD%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8Butterfly%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="🚀-环境准备"><a href="#🚀-环境准备" class="headerlink" title="🚀 环境准备"></a>🚀 环境准备</h2><div class="note info modern"><p><strong>前置要求</strong><br>在开始之前，请确保你的系统已经安装了以下环境：</p><ul><li>Node.js (建议使用最新LTS版本)</li><li>Git</li><li>一个代码编辑器 (推荐 VS Code)</li></ul></div><h3 id="1-安装-Node-js"><a href="#1-安装-Node-js" class="headerlink" title="1. 安装 Node.js"></a>1. 安装 Node.js</h3><div class="note warning no-icon flat"><p>需要提前安装 Node.js，并自行配置环境变量。如果使用 PowerShell 可能需要输入 <code>npm.cmd</code>，本教程采用的是 bash 环境。</p></div><h3 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h3><p>使用以下命令全局安装 Hexo CLI：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><a class="btn-beautify outline blue" href="https://hexo.io/zh-cn/docs/" title="Hexo官方文档"><i class="fas fa-external-link-alt"></i><span>Hexo官方文档</span></a><h2 id="📁-项目初始化"><a href="#📁-项目初始化" class="headerlink" title="📁 项目初始化"></a>📁 项目初始化</h2><h3 id="3-创建项目目录"><a href="#3-创建项目目录" class="headerlink" title="3. 创建项目目录"></a>3. 创建项目目录</h3><div class="note primary modern"><p>创建一个<strong>英文名称</strong>的文件夹，并在其中打开终端（PowerShell、CMD、Bash 任选其一）</p></div><h3 id="4-初始化-Hexo-项目"><a href="#4-初始化-Hexo-项目" class="headerlink" title="4. 初始化 Hexo 项目"></a>4. 初始化 Hexo 项目</h3><p>在项目根目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><h2 id="🎨-安装-Butterfly-主题"><a href="#🎨-安装-Butterfly-主题" class="headerlink" title="🎨 安装 Butterfly 主题"></a>🎨 安装 Butterfly 主题</h2><h3 id="5-下载主题源码"><a href="#5-下载主题源码" class="headerlink" title="5. 下载主题源码"></a>5. 下载主题源码</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">稳定版 (推荐)</button><button type="button" class="tab">开发版</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>开发版可能包含未测试的新功能，建议新手使用稳定版</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><a class="btn-beautify block center larger" href="https://github.com/jerryc127/hexo-theme-butterfly" title="Butterfly主题源码"><i class="fab fa-github"></i><span>Butterfly主题源码</span></a><h3 id="6-安装主题依赖"><a href="#6-安装主题依赖" class="headerlink" title="6. 安装主题依赖"></a>6. 安装主题依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-theme-butterfly</span><br></pre></td></tr></table></figure><h2 id="⚙️-配置主题"><a href="#⚙️-配置主题" class="headerlink" title="⚙️ 配置主题"></a>⚙️ 配置主题</h2><h3 id="7-配置文件设置"><a href="#7-配置文件设置" class="headerlink" title="7. 配置文件设置"></a>7. 配置文件设置</h3><div class="note success modern"><p><strong>重要步骤</strong></p><ol><li>将 <code>themes/butterfly/_config.yml</code> 复制到根目录</li><li>重命名为 <code>_config.butterfly.yml</code></li><li>修改根目录的 <code>_config.yml</code> 文件中的 <code>theme</code> 字段为 <code>butterfly</code></li></ol></div><h3 id="8-修改主题配置"><a href="#8-修改主题配置" class="headerlink" title="8. 修改主题配置"></a>8. 修改主题配置</h3><p>在根目录的 <code>_config.yml</code> 文件中找到 <code>theme</code> 字段，修改为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><h2 id="🎯-启动博客"><a href="#🎯-启动博客" class="headerlink" title="🎯 启动博客"></a>🎯 启动博客</h2><h3 id="9-清理并生成"><a href="#9-清理并生成" class="headerlink" title="9. 清理并生成"></a>9. 清理并生成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure><h3 id="10-启动本地服务器"><a href="#10-启动本地服务器" class="headerlink" title="10. 启动本地服务器"></a>10. 启动本地服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><div class="note success flat"><p><strong>🎉 恭喜！</strong><br>你的 Hexo 博客已经搭建完成！在浏览器中访问控制台提供的链接（通常是 <code>http://localhost:4000</code>），Ctrl + 鼠标左键点击即可访问你的博客。</p></div><h2 id="📋-命令总结"><a href="#📋-命令总结" class="headerlink" title="📋 命令总结"></a>📋 命令总结</h2><div class="btn-center"><a class="btn-beautify outline red" href="#" title="清理缓存"><i class="fas fa-broom"></i><span>清理缓存</span></a><a class="btn-beautify outline blue" href="#" title="生成静态文件"><i class="fas fa-cogs"></i><span>生成静态文件</span></a><a class="btn-beautify outline green" href="#" title="部署到服务器"><i class="fas fa-upload"></i><span>部署到服务器</span></a><a class="btn-beautify outline purple" href="#" title="启动本地服务"><i class="fas fa-server"></i><span>启动本地服务</span></a></div><details class="toggle" ><summary class="toggle-button" style="">完整命令列表</summary><div class="toggle-content"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理缓存和已生成的文件</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态文件</span></span><br><span class="line">hexo generate</span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动本地服务器</span></span><br><span class="line">hexo server</span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到远程服务器</span></span><br><span class="line">hexo deploy</span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成并部署</span></span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></div></details><hr>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>② Hexo 部署到GitLab Pages - 本地Runner自动化脚本</title>
      <link href="/2025/06/28/HEXO/02Hexo%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC%E5%8F%91%E5%B8%83%E6%9B%B4%E6%96%B0%E5%92%8C%E8%B0%83%E8%AF%95/"/>
      <url>/2025/06/28/HEXO/02Hexo%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC%E5%8F%91%E5%B8%83%E6%9B%B4%E6%96%B0%E5%92%8C%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>在第一篇教程中，我们已经详细介绍了如何搭建Hexo博客。接下来我们将学习如何将博客部署到GitLab Pages，并利用自定义脚本实现快捷运行和同步。</p><h2 id="🌐-什么是GitLab-Pages？"><a href="#🌐-什么是GitLab-Pages？" class="headerlink" title="🌐 什么是GitLab Pages？"></a>🌐 什么是GitLab Pages？</h2><div class="note info modern"><p><strong>GitLab Pages 简介</strong><br>GitLab Pages 是 GitLab 提供的静态网站托管服务。通过将网站文件推送到 GitLab 仓库，GitLab 会自动构建并部署网站，用户可以通过 GitLab 提供的域名访问自己的网站。</p></div><h3 id="📝-仓库命名规则"><a href="#📝-仓库命名规则" class="headerlink" title="📝 仓库命名规则"></a>📝 仓库命名规则</h3><div class="note warning flat"><p><strong>重要提醒</strong><br>假设你的用户名是 <code>crowforkotlin</code>，那么仓库名称必须是 <code>crowforkotlin.gitlab.io</code><br>这个命名规则是<strong>固定的</strong>，不能随意更改！</p></div><h3 id="⚙️-配置站点URL"><a href="#⚙️-配置站点URL" class="headerlink" title="⚙️ 配置站点URL"></a>⚙️ 配置站点URL</h3><p>在推送代码到GitLab之前，需要修改根目录的 <code>_config.yml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set your site url here</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://crowforkotlin.gitlab.io/</span></span><br></pre></td></tr></table></figure><h2 id="🏃‍♂️-什么是GitLab-Runner？"><a href="#🏃‍♂️-什么是GitLab-Runner？" class="headerlink" title="🏃‍♂️ 什么是GitLab Runner？"></a>🏃‍♂️ 什么是GitLab Runner？</h2><div class="note primary modern"><p><strong>GitLab Runner 介绍</strong><br>GitLab Runner 是一个开源项目，用于 GitLab CI&#x2F;CD 的执行环境。它可以在多种环境中运行，包括本地机器、虚拟机和云实例。GitLab Runner 负责接收来自 GitLab 的构建请求，并在指定的环境中执行相应的构建任务。</p></div><h2 id="📄-配置CI-x2F-CD文件"><a href="#📄-配置CI-x2F-CD文件" class="headerlink" title="📄 配置CI&#x2F;CD文件"></a>📄 配置CI&#x2F;CD文件</h2><p>当你把代码推送到GitLab后，此时GitLab Pages并不会生效，因为还需要一个 <code>.gitlab-ci.yml</code> 文件。这个文件是GitLab Runner的配置文件，GitLab Runner会根据这个文件来执行相应的脚本。</p><div class="note success modern"><p><strong>创建配置文件</strong><br>在项目根目录创建 <code>.gitlab-ci.yml</code> 文件</p></div><h3 id="CI-x2F-CD-配置示例"><a href="#CI-x2F-CD-配置示例" class="headerlink" title="CI&#x2F;CD 配置示例"></a>CI&#x2F;CD 配置示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">node:16.16.0</span>  <span class="comment"># 选用 Node.js 16.16.0 版本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pages:</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Home</span> <span class="comment"># 自定义标签，后续会用到</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_COMMIT_BRANCH</span> <span class="string">==</span> <span class="string">$CI_DEFAULT_BRANCH</span></span><br></pre></td></tr></table></figure><h2 id="🔧-安装和配置GitLab-Runner"><a href="#🔧-安装和配置GitLab-Runner" class="headerlink" title="🔧 安装和配置GitLab Runner"></a>🔧 安装和配置GitLab Runner</h2><div class="note info flat"><p><strong>为什么选择本地Runner？</strong><br>使用本地GitLab Runner可以：</p><ul><li>省去云端成本开销</li><li>减少云端启动容器时间</li><li>更好的控制构建环境</li><li>避免公共Runner的排队等待</li></ul></div><h3 id="步骤1-下载GitLab-Runner"><a href="#步骤1-下载GitLab-Runner" class="headerlink" title="步骤1: 下载GitLab Runner"></a>步骤1: 下载GitLab Runner</h3><a class="btn-beautify outline blue" href="https://docs.gitlab.com/runner/install/" title="GitLab Runner 官方下载"><i class="fas fa-download"></i><span>GitLab Runner 官方下载</span></a><a class="btn-beautify outline green" href="https://docs.gitlab.com/runner/register/?tab=Windows" title="Windows 注册指南"><i class="fas fa-book"></i><span>Windows 注册指南</span></a><h3 id="步骤2-注册Runner"><a href="#步骤2-注册Runner" class="headerlink" title="步骤2: 注册Runner"></a>步骤2: 注册Runner</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">获取注册令牌</button><button type="button" class="tab">执行注册命令</button></div><div class="tab-contents"><div class="tab-item-content active"><ol><li>打开你的GitLab Pages仓库</li><li>进入 <strong>Settings</strong> → <strong>CI&#x2F;CD</strong> → <strong>Runners</strong></li><li>点击 <strong>Create project runner</strong></li><li>输入你在 <code>.gitlab-ci.yml</code> 中设置的tags（如：<code>Home</code>）</li><li>点击 <strong>Create Runner</strong></li></ol></div><div class="tab-item-content"><p>复制页面显示的注册命令到命令行执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-runner register --url https://gitlab.com --token glrt-xxxxxxxxxx</span><br></pre></td></tr></table></figure><div class="note warning no-icon flat"><p>由于Windows下可能双击无反应，需要使用Git Bash、CMD或PowerShell等命令行工具执行</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="步骤3-配置Runner"><a href="#步骤3-配置Runner" class="headerlink" title="步骤3: 配置Runner"></a>步骤3: 配置Runner</h3><p>找到配置文件 <code>C:\Program Files\Git\config.toml</code>，可能需要手动修改shell为powershell：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[runners]]</span></span><br><span class="line">  <span class="attr">name</span> = <span class="string">&quot;Home&quot;</span></span><br><span class="line">  <span class="attr">url</span> = <span class="string">&quot;https://gitlab.com&quot;</span></span><br><span class="line">  <span class="attr">pre_clone_script</span> = <span class="string">&quot;git config --global --add safe.directory $&#123;CI_PROJECT_DIR&#125;&quot;</span></span><br><span class="line">  <span class="attr">id</span> = <span class="number">47770241</span></span><br><span class="line">  <span class="attr">token</span> = <span class="string">&quot;glrt-xxxxxxxxxx&quot;</span></span><br><span class="line">  <span class="attr">token_obtained_at</span> = <span class="number">2025</span>-<span class="number">06</span>-<span class="number">10</span>T07:<span class="number">33</span>:<span class="number">07</span>Z</span><br><span class="line">  <span class="attr">token_expires_at</span> = <span class="number">0001</span>-<span class="number">01</span>-<span class="number">01</span>T00:<span class="number">00</span>:<span class="number">00</span>Z</span><br><span class="line">  <span class="attr">executor</span> = <span class="string">&quot;shell&quot;</span></span><br><span class="line">  <span class="attr">shell</span> = <span class="string">&quot;powershell&quot;</span>  <span class="comment"># 重要：设置为powershell</span></span><br><span class="line">  <span class="section">[runners.cache]</span></span><br><span class="line">    <span class="attr">MaxUploadedArchiveSize</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="步骤4-启动Runner"><a href="#步骤4-启动Runner" class="headerlink" title="步骤4: 启动Runner"></a>步骤4: 启动Runner</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">gitlab-runner stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务  </span></span><br><span class="line">gitlab-runner start</span><br></pre></td></tr></table></figure><h2 id="🚀-部署流程"><a href="#🚀-部署流程" class="headerlink" title="🚀 部署流程"></a>🚀 部署流程</h2><ol><li><strong>推送代码到GitLab</strong></li><li><strong>启动本地Runner服务</strong></li><li><strong>查看构建过程</strong></li><li><strong>访问你的网站</strong>：<code>https://your-username.gitlab.io/</code></li></ol><div class="note success flat"><p><strong>🎉 部署成功！</strong><br>现在你可以通过GitLab提供的域名访问你的博客了</p></div><h2 id="🛠️-自动化脚本集合"><a href="#🛠️-自动化脚本集合" class="headerlink" title="🛠️ 自动化脚本集合"></a>🛠️ 自动化脚本集合</h2><div class="note green icon-padding modern"><i class="note-icon fas fa-magic"></i><p><strong>提升效率</strong><br>每次手动执行一大串流程确实繁琐，我编写了一套自动化脚本来快速完成日常操作。</p></div><h3 id="📦-脚本下载"><a href="#📦-脚本下载" class="headerlink" title="📦 脚本下载"></a>📦 脚本下载</h3><a class="btn-beautify block center larger" href="https://gitlab.com/crowforkotlin/page-storage-hexo-script" title="获取完整脚本"><i class="fab fa-gitlab"></i><span>获取完整脚本</span></a><h3 id="🔧-使用方法"><a href="#🔧-使用方法" class="headerlink" title="🔧 使用方法"></a>🔧 使用方法</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">下载和配置</button><button type="button" class="tab">路径配置示例</button><button type="button" class="tab">权限设置</button></div><div class="tab-contents"><div class="tab-item-content active"><ol><li><p><strong>克隆脚本仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitlab.com/crowforkotlin/page-storage-hexo-script.git</span><br></pre></td></tr></table></figure></li><li><p><strong>修改脚本配置</strong></p><ul><li>编辑脚本中的 <code>BLOG_PATH</code> 变量</li><li>根据你的项目路径进行调整</li></ul></li><li><p><strong>配置环境变量</strong></p><ul><li>将脚本目录添加到系统 PATH</li><li>或者直接在脚本目录下使用</li></ul></li><li><p><strong>运行环境</strong></p><ul><li>Git Bash（推荐）</li><li>CMD</li><li>PowerShell</li></ul></li></ol></div><div class="tab-item-content"><p>在每个脚本中找到并修改以下路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改为你的博客项目路径</span></span><br><span class="line">BLOG_PATH=<span class="string">&quot;/d/fish/your-username.gitlab.io&quot;</span></span><br></pre></td></tr></table></figure><p><strong>常见路径格式</strong>：</p><ul><li>Windows: <code>/d/fish/crowforkotlin.gitlab.io</code></li><li>Linux&#x2F;Mac: <code>/home/user/crowforkotlin.gitlab.io</code></li></ul><div class="note warning no-icon flat"><p><strong>注意</strong>：路径中不要包含中文字符，建议使用英文路径</p></div></div><div class="tab-item-content"><p><strong>Linux&#x2F;Mac 用户</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给脚本添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x *.sh</span><br></pre></td></tr></table></figure><p><strong>Windows 用户</strong>：</p><ul><li>确保已安装 Git Bash</li><li>可能需要以管理员身份运行某些脚本</li><li>部分脚本会自动请求管理员权限</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">🚀 启动Runner</button><button type="button" class="tab">📤 推送到GitLab</button><button type="button" class="tab">🖥️ 本地调试</button><button type="button" class="tab">⚡ 一键部署</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>功能</strong>：自动检测权限并启动GitLab Runner服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查管理员权限</span></span><br><span class="line">net session &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 已经是管理员</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Running with administrator privileges...&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Restarting GitLab Runner service...&quot;</span></span><br><span class="line">  </span><br><span class="line">  gitlab-runner stop</span><br><span class="line">  gitlab-runner start</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Service restart command issued.&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># 需要提权</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Administrator privileges required. Attempting to re-launch with elevation...&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 使用PowerShell提权重新运行</span></span><br><span class="line">  powershell.exe -Command <span class="string">&quot;Start-Process -FilePath &#x27;bash&#x27; -ArgumentList &#x27;-c \&quot;<span class="subst">$(readlink -f <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>\&quot;&#x27; -Verb RunAs&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p><strong>功能</strong>：一键提交并推送代码到GitLab仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义博客项目路径</span></span><br><span class="line">BLOG_PATH=<span class="string">&quot;/d/fish/crowforkotlin.gitlab.io&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;===================================&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;push blog to git&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;===================================&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Working directory: <span class="variable">$BLOG_PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到博客项目目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$BLOG_PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;:label: update&quot;</span></span><br><span class="line">git push origin main -f</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p><strong>功能</strong>：清理、生成并启动本地预览服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义博客项目路径</span></span><br><span class="line">BLOG_PATH=<span class="string">&quot;/d/fish/crowforkotlin.gitlab.io&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;===================================&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; Hexo Blog Workflow Started&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;===================================&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Working directory: <span class="variable">$BLOG_PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到博客项目目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$BLOG_PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[1/3] Cleaning old files...&quot;</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[2/3] Generating new static files...&quot;</span></span><br><span class="line">hexo g -f</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[3/3] Starting local server for preview...&quot;</span></span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;===================================&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; All tasks completed.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; Local server is running at http://localhost:4000&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;===================================&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让窗口保持打开</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Press Enter to exit...&quot;</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p><strong>功能</strong>：组合脚本，一键完成启动Runner和推送代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🚀 Starting automated deployment...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动GitLab Runner</span></span><br><span class="line">./gitlab-start.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;⏳ Waiting for runner to start...&quot;</span></span><br><span class="line"><span class="built_in">sleep</span> 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送代码到GitLab</span></span><br><span class="line">./gitlab-update.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;✅ Deployment process completed!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🌐 Check your GitLab Pages site for updates&quot;</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="📚-参考资源"><a href="#📚-参考资源" class="headerlink" title="📚 参考资源"></a>📚 参考资源</h2><div class="btn-center"><a class="btn-beautify larger" href="https://gitlab.com/crowforkotlin/page-storage-hexo-script" title="自动化脚本仓库"><i class="fab fa-gitlab"></i><span>自动化脚本仓库</span></a><a class="btn-beautify blue larger" href="https://docs.gitlab.com/runner/register/?tab=Windows" title="Runner注册指南"><i class="fas fa-book"></i><span>Runner注册指南</span></a><a class="btn-beautify green larger" href="https://docs.gitlab.com/ee/user/project/pages/" title="GitLab Pages文档"><i class="fas fa-file-alt"></i><span>GitLab Pages文档</span></a></div><h2 id="🎯-快捷方式配置与使用"><a href="#🎯-快捷方式配置与使用" class="headerlink" title="🎯 快捷方式配置与使用"></a>🎯 快捷方式配置与使用</h2><div class="note green icon-padding modern"><i class="note-icon fas fa-rocket"></i><p><strong>极简操作</strong><br>通过快捷脚本，参考我已经开源的script仓库，只需要输入 <code>launch</code> 即可自动推送并运行runner，当然你也可以根据需求自定义脚本功能。</p></div><h3 id="🚀-一键部署-launch-命令"><a href="#🚀-一键部署-launch-命令" class="headerlink" title="🚀 一键部署 - launch 命令"></a>🚀 一键部署 - launch 命令</h3><p>使用开源的脚本仓库，你可以实现：</p><ul><li><strong>一键启动</strong>：自动运行GitLab Runner</li><li><strong>自动推送</strong>：提交并推送代码到GitLab</li></ul><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">创建系统快捷方式</button><button type="button" class="tab">uTools启动器配置</button><button type="button" class="tab">自定义脚本</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>方法一：Windows快捷方式</strong></p><p>在创建快捷方式时，输入对象的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;C:\Program Files\Git\git-bash.exe&quot;</span> -c <span class="string">&quot;launch&quot;</span></span><br></pre></td></tr></table></figure><p><strong>配置步骤</strong>：</p><ol><li>右键桌面 → 新建 → 快捷方式</li><li>输入上述命令路径</li><li>命名为 “Hexo Deploy” 或其他你喜欢的名称</li><li>完成创建</li></ol><div class="note warning no-icon flat"><p><strong>提醒</strong>：需要先将脚本目录添加到系统环境变量PATH中</p></div></div><div class="tab-item-content"><p><strong>方法二：uTools工具（推荐）</strong></p><div class="note primary flat"><p><strong>为什么选择uTools？</strong></p><ul><li>全局快速启动</li><li>无需记忆复杂路径</li><li>支持关键词搜索</li><li>界面美观易用</li></ul></div><p><strong>配置步骤</strong>：</p><ol><li>下载并安装 <a href="https://u.tools/">uTools</a></li><li>打开uTools设置</li><li>进入 <strong>设置</strong> → <strong>文件启动选项</strong></li><li>将launch脚本快捷方式拖入启动选项</li><li>设置关键词（如：<code>launch</code>、<code>hexo</code>、<code>deploy</code>）</li></ol><p><strong>使用方法</strong>：</p><ul><li>按下 <code>Alt + Space</code> 唤起uTools</li><li>输入 <code>launch</code> 或设置的关键词</li><li>回车执行，完成一键部署</li></ul><div class="note success no-icon flat"><p><strong>效果</strong>：更新整个Hexo博客并推送更新到GitLab Pages，只需要输入一个关键词！</p></div></div><div class="tab-item-content"><p><strong>方法三：自定义launch脚本</strong></p><p>你可以根据需求修改launch脚本的功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># launch.sh - 自定义一键部署脚本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🚀 Starting Hexo deployment workflow...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：添加预处理步骤</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;📝 Checking for new posts...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动GitLab Runner</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🔧 Starting GitLab Runner...&quot;</span></span><br><span class="line">./gitlab-start.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待Runner启动</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;⏳ Waiting for runner to initialize...&quot;</span></span><br><span class="line"><span class="built_in">sleep</span> 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送代码</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;📤 Pushing to GitLab...&quot;</span></span><br><span class="line">./gitlab-update.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：打开浏览器预览</span></span><br><span class="line"><span class="comment"># echo &quot;🌐 Opening browser preview...&quot;</span></span><br><span class="line"><span class="comment"># start https://your-username.gitlab.io</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;✅ Deployment completed successfully!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🎉 Your blog is now updated!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保持窗口打开以查看结果</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Press Enter to exit...&quot;</span></span><br></pre></td></tr></table></figure><p><strong>自定义选项</strong>：</p><ul><li>添加构建前检查</li><li>集成图片压缩</li><li>自动打开浏览器预览</li><li>发送部署完成通知</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="🛠️-环境变量配置"><a href="#🛠️-环境变量配置" class="headerlink" title="🛠️ 环境变量配置"></a>🛠️ 环境变量配置</h3><div class="note info modern"><p><strong>环境变量设置</strong><br>为了在任意位置使用脚本命令，需要配置系统环境变量</p></div><p><strong>Windows 配置步骤</strong>：</p><ol><li>右键 “此电脑” → 属性</li><li>高级系统设置 → 环境变量</li><li>在系统变量中找到 “Path”</li><li>添加脚本所在目录路径</li><li>确定保存</li></ol><p><strong>验证配置</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在任意目录打开命令行，输入：</span></span><br><span class="line">launch</span><br><span class="line"><span class="comment"># 如果能正常执行，说明配置成功</span></span><br></pre></td></tr></table></figure><h2 id="📋-常用命令速查"><a href="#📋-常用命令速查" class="headerlink" title="📋 常用命令速查"></a>📋 常用命令速查</h2><div class="btn-center"><a class="btn-beautify outline green" href="#" title="启动Runner"><i class="fas fa-play"></i><span>启动Runner</span></a><a class="btn-beautify outline red" href="#" title="停止Runner"><i class="fas fa-stop"></i><span>停止Runner</span></a><a class="btn-beautify outline blue" href="#" title="推送代码"><i class="fas fa-upload"></i><span>推送代码</span></a><a class="btn-beautify outline purple" href="#" title="本地预览"><i class="fas fa-eye"></i><span>本地预览</span></a></div><details class="toggle" ><summary class="toggle-button" style="">完整命令列表</summary><div class="toggle-content"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GitLab Runner 管理</span></span><br><span class="line">gitlab-runner start    <span class="comment"># 启动服务</span></span><br><span class="line">gitlab-runner stop     <span class="comment"># 停止服务</span></span><br><span class="line">gitlab-runner status   <span class="comment"># 查看状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Git 操作</span></span><br><span class="line">git add -A                    <span class="comment"># 添加所有文件</span></span><br><span class="line">git commit -m <span class="string">&quot;message&quot;</span>       <span class="comment"># 提交变更</span></span><br><span class="line">git push origin main -f       <span class="comment"># 强制推送到主分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hexo 操作</span></span><br><span class="line">hexo clean      <span class="comment"># 清理缓存</span></span><br><span class="line">hexo generate   <span class="comment"># 生成静态文件</span></span><br><span class="line">hexo server     <span class="comment"># 启动本地服务器</span></span><br><span class="line">hexo deploy     <span class="comment"># 部署到远程</span></span><br></pre></td></tr></table></figure></div></details><hr><h2 id="💡-故障排除"><a href="#💡-故障排除" class="headerlink" title="💡 故障排除"></a>💡 故障排除</h2><div class="note danger modern"><p><strong>常见问题解决方案</strong></p></div><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">Runner无法启动</button><button type="button" class="tab">构建失败</button><button type="button" class="tab">脚本权限问题</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>问题现象</strong>：Runner服务无法正常启动</p><p><strong>解决方案</strong>：</p><ol><li>检查管理员权限</li><li>确认Runner已正确注册</li><li>检查配置文件路径</li><li>重新安装Runner服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新安装服务</span></span><br><span class="line">gitlab-runner uninstall</span><br><span class="line">gitlab-runner install</span><br><span class="line">gitlab-runner start</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p><strong>问题现象</strong>：CI&#x2F;CD流水线构建失败</p><p><strong>解决方案</strong>：</p><ol><li>检查 <code>.gitlab-ci.yml</code> 语法</li><li>确认Node.js版本兼容性</li><li>检查依赖包安装</li><li>查看详细构建日志</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地测试构建过程</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p><strong>问题现象</strong>：脚本无法执行或权限不足</p><p><strong>解决方案</strong>：</p><ol><li>以管理员身份运行</li><li>修改脚本执行权限</li><li>检查路径配置</li><li>确认Git Bash环境</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux/Mac 添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x script-name.sh</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🎉-部署成功检查"><a href="#🎉-部署成功检查" class="headerlink" title="🎉 部署成功检查"></a>🎉 部署成功检查</h2><div class="note success icon-padding modern"><i class="note-icon fas fa-check-circle"></i><p><strong>部署完成后的验证步骤</strong></p><ol><li>✅ GitLab Pages构建成功</li><li>✅ 网站可正常访问</li><li>✅ 样式和资源加载正常</li><li>✅ 文章内容显示正确</li></ol></div><div class="note success icon-padding modern"><i class="note-icon fas fa-lightbulb"></i><p><strong>进阶小贴士</strong></p><ul><li>脚本路径需要根据实际情况修改</li><li>建议将常用脚本添加到系统环境变量中</li><li>可以根据需求自定义脚本功能</li><li>记得定期检查GitLab Runner的运行状态</li><li>建议定期备份重要的配置文件</li><li>可以设置定时任务自动执行部署脚本</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📱 Android虚拟机Root教程</title>
      <link href="/2025/06/11/Android/Avd%20Root/"/>
      <url>/2025/06/11/Android/Avd%20Root/</url>
      
        <content type="html"><![CDATA[<h2 id="🛠️-工具介绍"><a href="#🛠️-工具介绍" class="headerlink" title="🛠️ 工具介绍"></a>🛠️ 工具介绍</h2><div class="note blue icon-padding modern"><i class="note-icon fab fa-github"></i><p><strong>开源工具：RootAVD</strong></p><ul><li>项目地址：<a href="https://github.com/crowforkotlin/rootAVD">RootAVD - GitHub</a></li><li>专门用于Android虚拟机Root的自动化工具</li><li>支持多种Android API版本</li></ul></div><h2 id="🚀-操作流程"><a href="#🚀-操作流程" class="headerlink" title="🚀 操作流程"></a>🚀 操作流程</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">虚拟机创建</button><button type="button" class="tab">Root安装</button><button type="button" class="tab">Magisk配置</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="📱-选择虚拟机配置"><a href="#📱-选择虚拟机配置" class="headerlink" title="📱 选择虚拟机配置"></a>📱 选择虚拟机配置</h3><div class="note warning icon-padding modern"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>推荐配置：</strong></p><ul><li>Android API 25 (Android 7.1)</li><li>架构：64位</li><li>类型：Google APIs</li></ul></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建虚拟机后建议重新命名</span></span><br><span class="line"><span class="comment"># 例如：RootAvd25、RootAvdXX</span></span><br></pre></td></tr></table></figure><div class="note info icon-padding modern"><i class="note-icon fas fa-info-circle"></i><p><strong>版本选择说明：</strong><br>经测试API 35、34版本可能遇到问题，API 25稳定性较好</p></div></div><div class="tab-item-content"><h3 id="🔧-执行Root操作"><a href="#🔧-执行Root操作" class="headerlink" title="🔧 执行Root操作"></a>🔧 执行Root操作</h3><div class="note success icon-padding modern"><i class="note-icon fas fa-magic"></i><p><strong>自动Root流程：</strong></p><ol><li>运行RootAVD脚本选择对应镜像</li><li>工具会自动安装Magisk</li><li>打开Magisk统一权限，等待5秒自动重启</li></ol></div><h3 id="⚙️-重要配置"><a href="#⚙️-重要配置" class="headerlink" title="⚙️ 重要配置"></a>⚙️ 重要配置</h3><div class="note primary icon-padding modern"><i class="note-icon fas fa-cogs"></i><p><strong>参考配置说明：</strong><br>详见 <a href="https://github.com/crowforkotlin/rootAVD?tab=readme-ov-file#automotive-notes">RootAVD Notes</a></p></div></div><div class="tab-item-content"><h3 id="🎯-Magisk设置"><a href="#🎯-Magisk设置" class="headerlink" title="🎯 Magisk设置"></a>🎯 Magisk设置</h3><div class="note purple icon-padding modern"><i class="note-icon fas fa-android"></i><p><strong>Magisk配置步骤：</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 勾选启用Magisk</span></span><br><span class="line"><span class="comment"># 2. Magisk App -&gt; Settings -&gt; Multiuser Mode -&gt; User-Independent</span></span><br><span class="line"><span class="comment"># 3. 重启AVD</span></span><br><span class="line"><span class="comment"># 4. 在Magisk中选择reboot</span></span><br></pre></td></tr></table></figure><h3 id="🔓-系统写入权限"><a href="#🔓-系统写入权限" class="headerlink" title="🔓 系统写入权限"></a>🔓 系统写入权限</h3><div class="note orange icon-padding modern"><i class="note-icon fas fa-terminal"></i><p><strong>启用系统写入权限：</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以可写系统模式运行AVD</span></span><br><span class="line">emulator -writable-system -avd Avd71</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后续可通过mount、remount挂载操作</span></span><br><span class="line"><span class="comment"># 实现系统文件的增删改功能</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🔗-相关链接"><a href="#🔗-相关链接" class="headerlink" title="🔗 相关链接"></a>🔗 相关链接</h2><div class="btn-center"><a class="btn-beautify blue larger" href="https://github.com/crowforkotlin/rootAVD" title="RootAVD工具"><i class="fab fa-github"></i><span>RootAVD工具</span></a><a class="btn-beautify green larger" href="https://github.com/topjohnwu/Magisk" title="Magisk项目"><i class="fab fa-github"></i><span>Magisk项目</span></a></div>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Root </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Avd </tag>
            
            <tag> Magisk </tag>
            
            <tag> Root </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python环境快速搭建指南</title>
      <link href="/2025/06/11/Python/Python%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
      <url>/2025/06/11/Python/Python%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<div class="note modern"><p>🎯 <strong>学习目标</strong>：掌握Python开发环境的搭建和虚拟环境管理，为Python项目开发打下坚实基础</p></div><h2 id="📥-Python安装"><a href="#📥-Python安装" class="headerlink" title="📥 Python安装"></a>📥 Python安装</h2><h3 id="🌐-下载与安装"><a href="#🌐-下载与安装" class="headerlink" title="🌐 下载与安装"></a>🌐 下载与安装</h3><div class="note info icon-padding flat"><i class="note-icon fas fa-download"></i><p><strong>官方下载地址</strong>：<a href="https://www.python.org/downloads/">Python官方网站</a><br><strong>推荐版本</strong>：Python 3.11+ (具备更好的性能和特性)</p></div><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">🪟 Windows 安装</button><button type="button" class="tab">🐧 Linux 安装</button><button type="button" class="tab">🍎 macOS 安装</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="Windows-安装步骤"><a href="#Windows-安装步骤" class="headerlink" title="Windows 安装步骤"></a>Windows 安装步骤</h3><ol><li><p><strong>下载安装包</strong></p><ul><li>访问Python官网下载最新版本</li><li>选择适合系统架构的安装包（32位&#x2F;64位）</li></ul></li><li><p><strong>安装配置</strong></p><div class="note warning icon-padding flat"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>重要</strong>：安装时务必勾选以下选项</p></div><ul><li>✅ <strong>Add Python to PATH</strong> (添加到环境变量)</li><li>✅ <strong>Install pip</strong> (安装包管理器)</li><li>🔧 选择自定义安装路径（可选）</li></ul></li><li><p><strong>环境变量验证</strong></p><p>确认以下路径已添加到系统环境变量 <code>Path</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\program\Python311\</span><br><span class="line">D:\program\Python311\Scripts\</span><br></pre></td></tr></table></figure></li></ol><div class="note success icon-padding flat"><i class="note-icon fas fa-check-circle"></i><p><strong>验证安装</strong>：打开命令行输入 <code>python --version</code> 检查安装是否成功</p></div></div><div class="tab-item-content"><h3 id="Ubuntu-x2F-Debian-系统"><a href="#Ubuntu-x2F-Debian-系统" class="headerlink" title="Ubuntu&#x2F;Debian 系统"></a>Ubuntu&#x2F;Debian 系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新包管理器</span></span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Python</span></span><br><span class="line">sudo apt install python3 python3-pip python3-venv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">python3 --version</span><br><span class="line">pip3 --version</span><br></pre></td></tr></table></figure><h3 id="CentOS-x2F-RHEL-系统"><a href="#CentOS-x2F-RHEL-系统" class="headerlink" title="CentOS&#x2F;RHEL 系统"></a>CentOS&#x2F;RHEL 系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Python</span></span><br><span class="line">sudo yum install python3 python3-pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用dnf (较新版本)</span></span><br><span class="line">sudo dnf install python3 python3-pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">python3 --version</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h3 id="使用-Homebrew（推荐）"><a href="#使用-Homebrew（推荐）" class="headerlink" title="使用 Homebrew（推荐）"></a>使用 Homebrew（推荐）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Homebrew (如果未安装)</span></span><br><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Python</span></span><br><span class="line">brew install python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">python3 --version</span><br><span class="line">pip3 --version</span><br></pre></td></tr></table></figure><h3 id="使用官方安装包"><a href="#使用官方安装包" class="headerlink" title="使用官方安装包"></a>使用官方安装包</h3><ul><li>下载 macOS 专用的 <code>.pkg</code> 安装包</li><li>双击安装并按提示操作</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🚀-虚拟环境管理"><a href="#🚀-虚拟环境管理" class="headerlink" title="🚀 虚拟环境管理"></a>🚀 虚拟环境管理</h2><div class="note blue icon-padding modern"><i class="note-icon fas fa-info-circle"></i><p><strong>为什么需要虚拟环境？</strong><br>虚拟环境为每个项目创建独立的Python运行环境，避免依赖冲突，便于项目管理和部署。</p></div><h3 id="📁-项目初始化"><a href="#📁-项目初始化" class="headerlink" title="📁 项目初始化"></a>📁 项目初始化</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">📂 创建项目</button><button type="button" class="tab">🌍 创建虚拟环境</button><button type="button" class="tab">⚡ 激活环境</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>创建项目目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><div class="note green icon-padding flat"><i class="note-icon fas fa-folder"></i><p><strong>建议</strong>：使用有意义的项目名称，如 <code>my-python-project</code></p></div></div><div class="tab-item-content"><p><strong>创建虚拟环境</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m venv venv</span><br></pre></td></tr></table></figure><div class="note purple icon-padding flat"><i class="note-icon fas fa-magic"></i><p><strong>命令解析</strong>：<code>venv</code> 是Python内置的虚拟环境模块，第二个 <code>venv</code> 是环境目录名</p></div></div><div class="tab-item-content"><p><strong>激活虚拟环境</strong></p><p><strong>Windows 系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">venv\Scripts\activate</span><br></pre></td></tr></table></figure><p><strong>Linux&#x2F;macOS 系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br></pre></td></tr></table></figure><div class="note success icon-padding flat"><i class="note-icon fas fa-check"></i><p><strong>成功标志</strong>：激活后命令行前会显示 <code>(venv)</code> 标识</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="🔧-环境配置"><a href="#🔧-环境配置" class="headerlink" title="🔧 环境配置"></a>🔧 环境配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新pip到最新版本</span></span><br><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure><div class="note warning icon-padding flat"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>注意</strong>：建议每次创建新环境后都更新pip，确保使用最新功能</p></div><h2 id="📦-依赖包管理"><a href="#📦-依赖包管理" class="headerlink" title="📦 依赖包管理"></a>📦 依赖包管理</h2><h3 id="🔽-安装依赖包"><a href="#🔽-安装依赖包" class="headerlink" title="🔽 安装依赖包"></a>🔽 安装依赖包</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">📥 单个安装</button><button type="button" class="tab">📄 批量管理</button><button type="button" class="tab">🔍 查看与卸载</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>安装单个包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install package_name</span><br></pre></td></tr></table></figure><p><strong>常用包安装示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HTTP请求库</span></span><br><span class="line">pip install requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据分析库</span></span><br><span class="line">pip install numpy pandas</span><br><span class="line"></span><br><span class="line"><span class="comment"># Web框架</span></span><br><span class="line">pip install flask django</span><br><span class="line"></span><br><span class="line"><span class="comment"># 机器学习</span></span><br><span class="line">pip install scikit-learn tensorflow</span><br></pre></td></tr></table></figure><div class="note blue icon-padding flat"><i class="note-icon fas fa-lightbulb"></i><p><strong>提示</strong>：可以指定版本 <code>pip install package_name==1.2.3</code></p></div></div><div class="tab-item-content"><p><strong>生成依赖文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><p><strong>安装依赖文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><div class="note green icon-padding flat"><i class="note-icon fas fa-file-alt"></i><p><strong>最佳实践</strong>：每次修改依赖后都要更新 <code>requirements.txt</code></p></div></div><div class="tab-item-content"><p><strong>查看已安装的包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure><p><strong>查看包详细信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show package_name</span><br></pre></td></tr></table></figure><p><strong>卸载包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall package_name</span><br></pre></td></tr></table></figure><div class="note red icon-padding flat"><i class="note-icon fas fa-trash"></i><p><strong>注意</strong>：卸载包时会询问确认，使用 <code>-y</code> 参数可跳过确认</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🔄-环境切换与管理"><a href="#🔄-环境切换与管理" class="headerlink" title="🔄 环境切换与管理"></a>🔄 环境切换与管理</h2><h3 id="❌-退出虚拟环境"><a href="#❌-退出虚拟环境" class="headerlink" title="❌ 退出虚拟环境"></a>❌ 退出虚拟环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><div class="note info icon-padding flat"><i class="note-icon fas fa-sign-out-alt"></i><p>退出后回到全局Python环境，命令行前的 <code>(venv)</code> 标识会消失</p></div><h3 id="🗑️-删除虚拟环境"><a href="#🗑️-删除虚拟环境" class="headerlink" title="🗑️ 删除虚拟环境"></a>🗑️ 删除虚拟环境</h3><p><strong>Windows 系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> /s venv</span><br></pre></td></tr></table></figure><p><strong>Linux&#x2F;macOS 系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf venv</span><br></pre></td></tr></table></figure><div class="note danger icon-padding flat"><i class="note-icon fas fa-exclamation-circle"></i><p><strong>警告</strong>：删除虚拟环境会丢失所有已安装的包，请确保已备份 <code>requirements.txt</code></p></div><h2 id="�-快速参考"><a href="#�-快速参考" class="headerlink" title="� 快速参考"></a>� 快速参考</h2><h3 id="🔧-常用命令速查表"><a href="#🔧-常用命令速查表" class="headerlink" title="🔧 常用命令速查表"></a>🔧 常用命令速查表</h3><table><thead><tr><th>命令</th><th>功能描述</th></tr></thead><tbody><tr><td><code>python -m venv venv</code></td><td>🆕 创建虚拟环境</td></tr><tr><td><code>venv\Scripts\activate</code></td><td>▶️ 激活环境(Windows)</td></tr><tr><td><code>source venv/bin/activate</code></td><td>▶️ 激活环境(Linux&#x2F;Mac)</td></tr><tr><td><code>deactivate</code></td><td>⏹️ 退出虚拟环境</td></tr><tr><td><code>pip install package</code></td><td>📥 安装包</td></tr><tr><td><code>pip freeze &gt; requirements.txt</code></td><td>📄 导出依赖列表</td></tr><tr><td><code>pip install -r requirements.txt</code></td><td>📦 安装依赖列表</td></tr><tr><td><code>pip list</code></td><td>📋 查看已安装包</td></tr><tr><td><code>pip uninstall package</code></td><td>🗑️ 卸载包</td></tr></tbody></table><h3 id="🎯-最佳实践建议"><a href="#🎯-最佳实践建议" class="headerlink" title="🎯 最佳实践建议"></a>🎯 最佳实践建议</h3><div class="note green icon-padding modern"><i class="note-icon fas fa-lightbulb"></i><p><strong>项目隔离</strong>：每个项目使用独立虚拟环境，避免依赖冲突</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-sync"></i><p><strong>及时更新</strong>：新增依赖后及时更新 <code>requirements.txt</code>，保持团队环境同步</p></div><div class="note purple icon-padding modern"><i class="note-icon fas fa-code-branch"></i><p><strong>版本控制</strong>：将 <code>requirements.txt</code> 纳入Git管理，但排除 <code>venv/</code> 目录</p></div><h3 id="📝-gitignore-配置"><a href="#📝-gitignore-配置" class="headerlink" title="📝 .gitignore 配置"></a>📝 .gitignore 配置</h3><div class="note orange icon-padding flat"><i class="note-icon fab fa-git-alt"></i><p><strong>推荐配置</strong>：在项目根目录创建 <code>.gitignore</code> 文件</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Python 虚拟环境</span><br><span class="line">venv/</span><br><span class="line">env/</span><br><span class="line"></span><br><span class="line"># Python 缓存文件</span><br><span class="line">__pycache__/</span><br><span class="line">*.pyc</span><br><span class="line">*.pyo</span><br><span class="line">*.pyd</span><br><span class="line"></span><br><span class="line"># IDE 配置文件</span><br><span class="line">.vscode/</span><br><span class="line">.idea/</span><br><span class="line"></span><br><span class="line"># 系统文件</span><br><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br></pre></td></tr></table></figure><h2 id="🔧-故障排除"><a href="#🔧-故障排除" class="headerlink" title="🔧 故障排除"></a>🔧 故障排除</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">❗ 常见问题</button><button type="button" class="tab">✅ 安装验证</button><button type="button" class="tab">� 性能优化</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="note danger icon-padding flat"><i class="note-icon fas fa-bug"></i><p><strong>问题1</strong>: <code>python</code> 命令不识别<br><strong>解决方案</strong>: 检查环境变量Path配置，确保Python安装路径已添加</p></div><div class="note danger icon-padding flat"><i class="note-icon fas fa-bug"></i><p><strong>问题2</strong>: <code>pip</code> 命令不识别<br><strong>解决方案</strong>: 重新安装Python，确保勾选了”Install pip”选项</p></div><div class="note danger icon-padding flat"><i class="note-icon fas fa-bug"></i><p><strong>问题3</strong>: 虚拟环境激活失败<br><strong>解决方案</strong>: 检查路径分隔符，Windows使用反斜杠 <code>\</code>，Linux&#x2F;Mac使用正斜杠 <code>/</code></p></div><div class="note danger icon-padding flat"><i class="note-icon fas fa-bug"></i><p><strong>问题4</strong>: 包安装速度慢<br><strong>解决方案</strong>: 使用国内镜像源加速下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple package_name</span><br></pre></td></tr></table></figure></div></div><div class="tab-item-content"><p><strong>验证Python安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">python -V</span><br></pre></td></tr></table></figure><p><strong>验证pip安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip --version</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">pip -V</span><br></pre></td></tr></table></figure><p><strong>测试虚拟环境</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在虚拟环境中</span></span><br><span class="line">python -c <span class="string">&quot;import sys; print(sys.executable)&quot;</span></span><br></pre></td></tr></table></figure><div class="note success icon-padding flat"><i class="note-icon fas fa-check-circle"></i><p>正确配置后应显示虚拟环境中的Python路径</p></div></div><div class="tab-item-content"><p><strong>配置pip镜像源（永久）</strong></p><p>创建pip配置文件：</p><p><strong>Windows</strong>: <code>%APPDATA%\pip\pip.ini</code><br><strong>Linux&#x2F;Mac</strong>: <code>~/.pip/pip.conf</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">index-url</span> = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="attr">trusted-host</span> = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p><strong>常用国内镜像源</strong></p><ul><li>清华大学：<code>https://pypi.tuna.tsinghua.edu.cn/simple</code></li><li>阿里云：<code>https://mirrors.aliyun.com/pypi/simple</code></li><li>豆瓣：<code>https://pypi.douban.com/simple</code></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🎉-总结"><a href="#🎉-总结" class="headerlink" title="🎉 总结"></a>🎉 总结</h2><div class="note success icon-padding modern"><i class="note-icon fas fa-graduation-cap"></i><p><strong>恭喜！</strong> 你已经掌握了Python环境搭建的核心技能</p></div><h3 id="�💡-学习路径建议"><a href="#�💡-学习路径建议" class="headerlink" title="�💡 学习路径建议"></a>�💡 学习路径建议</h3><div class="note blue icon-padding flat"><i class="note-icon fas fa-route"></i><p><strong>初学者路径</strong>：基础语法 → 标准库 → 第三方库 → 实战项目</p></div><div class="note purple icon-padding flat"><i class="note-icon fas fa-rocket"></i><p><strong>进阶路径</strong>：Web开发 &#x2F; 数据分析 &#x2F; 机器学习 &#x2F; 自动化运维</p></div><hr><div class="note pink icon-padding modern"><i class="note-icon fas fa-heart"></i><p><strong>小贴士</strong>：虚拟环境是Python开发的最佳实践，熟练掌握后将大大提升开发效率！</p></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📡 TCP原始数据包抓取详解</title>
      <link href="/2025/06/11/%E6%8A%93%E5%8C%85/TCP%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE/"/>
      <url>/2025/06/11/%E6%8A%93%E5%8C%85/TCP%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="🚀-抓包流程"><a href="#🚀-抓包流程" class="headerlink" title="🚀 抓包流程"></a>🚀 抓包流程</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">环境检查</button><button type="button" class="tab">执行抓包</button><button type="button" class="tab">数据分析</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="🔍-网络接口查看"><a href="#🔍-网络接口查看" class="headerlink" title="🔍 网络接口查看"></a>🔍 网络接口查看</h3><div class="note blue icon-padding modern"><i class="note-icon fas fa-network-wired"></i><p><strong>查看可用的网络接口</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络接口信息</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用ip命令</span></span><br><span class="line">ip addr show</span><br></pre></td></tr></table></figure><div class="note info icon-padding modern"><i class="note-icon fas fa-info-circle"></i><p><strong>常见网络接口：</strong></p><ul><li><code>wlan0</code> - WiFi接口</li><li><code>rmnet0</code> - 移动数据接口  </li><li><code>eth0</code> - 以太网接口</li><li><code>lo</code> - 回环接口</li></ul></div></div><div class="tab-item-content"><h3 id="🎯-tcpdump命令详解"><a href="#🎯-tcpdump命令详解" class="headerlink" title="🎯 tcpdump命令详解"></a>🎯 tcpdump命令详解</h3><div class="note purple icon-padding modern"><i class="note-icon fas fa-terminal"></i><p><strong>核心抓包命令</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本抓包命令</span></span><br><span class="line">tcpdump -i &lt;interface_name&gt; -s 0 -w /sdcard/capture.pcap</span><br></pre></td></tr></table></figure><div class="note success icon-padding modern"><i class="note-icon fas fa-cogs"></i><p><strong>参数说明：</strong></p><ul><li><code>-i &lt;interface_name&gt;</code> - 指定网络接口（如wlan0）</li><li><code>-s 0</code> - 捕获完整数据包（不截断）</li><li><code>-w filename</code> - 将数据写入文件</li><li><code>/sdcard/capture.pcap</code> - 输出文件路径</li></ul></div><h3 id="📝-实际操作示例"><a href="#📝-实际操作示例" class="headerlink" title="📝 实际操作示例"></a>📝 实际操作示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例1：抓取WiFi接口的所有数据包</span></span><br><span class="line">tcpdump -i wlan0 -s 0 -w /sdcard/wifi_capture.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：抓取特定端口的数据包</span></span><br><span class="line">tcpdump -i wlan0 -s 0 port 80 -w /sdcard/http_capture.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3：抓取特定主机的数据包</span></span><br><span class="line">tcpdump -i wlan0 -s 0 host 192.168.1.1 -w /sdcard/host_capture.pcap</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h3 id="📤-文件传输"><a href="#📤-文件传输" class="headerlink" title="📤 文件传输"></a>📤 文件传输</h3><div class="note green icon-padding modern"><i class="note-icon fas fa-download"></i><p><strong>第三步：传输pcap文件到电脑</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用adb pull命令传输文件</span></span><br><span class="line">adb pull /sdcard/capture.pcap ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者指定具体路径</span></span><br><span class="line">adb pull /sdcard/capture.pcap C:\captures\</span><br></pre></td></tr></table></figure><h3 id="🔬-Wireshark分析"><a href="#🔬-Wireshark分析" class="headerlink" title="🔬 Wireshark分析"></a>🔬 Wireshark分析</h3><div class="note blue icon-padding modern"><i class="note-icon fas fa-search"></i><p><strong>第四步：使用Wireshark打开pcap文件进行分析</strong></p></div><div class="note info icon-padding modern"><i class="note-icon fas fa-lightbulb"></i><p><strong>Wireshark分析要点：</strong></p><ul><li>使用过滤器筛选特定协议：<code>tcp</code>, <code>http</code>, <code>dns</code></li><li>查看数据包详细信息和十六进制数据</li><li>分析网络流量模式和异常行为</li><li>导出特定会话或对象</li></ul></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🔧-高级技巧"><a href="#🔧-高级技巧" class="headerlink" title="🔧 高级技巧"></a>🔧 高级技巧</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">过滤选项</button><button type="button" class="tab">实时监控</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="🎛️-tcpdump过滤器"><a href="#🎛️-tcpdump过滤器" class="headerlink" title="🎛️ tcpdump过滤器"></a>🎛️ tcpdump过滤器</h3><div class="note primary icon-padding modern"><i class="note-icon fas fa-filter"></i><p><strong>常用过滤条件</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只抓取TCP协议</span></span><br><span class="line">tcpdump -i wlan0 tcp -w tcp_only.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取特定端口范围</span></span><br><span class="line">tcpdump -i wlan0 portrange 80-443 -w web_traffic.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取来自/到特定IP的数据包</span></span><br><span class="line">tcpdump -i wlan0 src 192.168.1.100 -w from_host.pcap</span><br><span class="line">tcpdump -i wlan0 dst 192.168.1.100 -w to_host.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合条件（HTTP和HTTPS流量）</span></span><br><span class="line">tcpdump -i wlan0 <span class="string">&#x27;port 80 or port 443&#x27;</span> -w web_all.pcap</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h3 id="📊-实时数据包监控"><a href="#📊-实时数据包监控" class="headerlink" title="📊 实时数据包监控"></a>📊 实时数据包监控</h3><div class="note orange icon-padding modern"><i class="note-icon fas fa-eye"></i><p><strong>实时查看数据包（不保存文件）</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时显示数据包摘要</span></span><br><span class="line">tcpdump -i wlan0 -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示详细的数据包内容</span></span><br><span class="line">tcpdump -i wlan0 -A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示十六进制和ASCII内容</span></span><br><span class="line">tcpdump -i wlan0 -X</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制显示的数据包数量</span></span><br><span class="line">tcpdump -i wlan0 -c 100</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🐛-常见问题排查"><a href="#🐛-常见问题排查" class="headerlink" title="🐛 常见问题排查"></a>🐛 常见问题排查</h2><h3 id="🔴-权限问题"><a href="#🔴-权限问题" class="headerlink" title="🔴 权限问题"></a>🔴 权限问题</h3><div class="note red icon-padding modern"><i class="note-icon fas fa-times-circle"></i><p><strong>问题：Permission denied</strong></p></div><div class="note green icon-padding modern"><i class="note-icon fas fa-lightbulb"></i><p><strong>解决方案：</strong></p><ol><li>确保设备已获得Root权限</li><li>使用<code>su</code>命令切换到超级用户</li><li>检查tcpdump工具是否正确安装</li></ol></div><h3 id="🟡-接口不存在"><a href="#🟡-接口不存在" class="headerlink" title="🟡 接口不存在"></a>🟡 接口不存在</h3><div class="note warning icon-padding modern"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>问题：指定的网络接口不存在</strong></p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-tools"></i><p><strong>解决方案：</strong><br>使用<code>ifconfig</code>或<code>ip addr</code>命令查看实际可用的网络接口名称</p></div><h2 id="🔗-相关工具"><a href="#🔗-相关工具" class="headerlink" title="🔗 相关工具"></a>🔗 相关工具</h2><div class="btn-center"><a class="btn-beautify blue larger" href="https://www.wireshark.org" title="Wireshark官网"><i class="fas fa-external-link-alt"></i><span>Wireshark官网</span></a><a class="btn-beautify green larger" href="https://www.tcpdump.org" title="tcpdump官网"><i class="fas fa-external-link-alt"></i><span>tcpdump官网</span></a></div>]]></content>
      
      
      <categories>
          
          <category> 抓包 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>① 利用Blutter反编译Flutter Apk的Dart文件</title>
      <link href="/2025/06/11/%E9%80%86%E5%90%91/Flutter%E9%80%86%E5%90%91%E6%B5%81%E7%A8%8B/"/>
      <url>/2025/06/11/%E9%80%86%E5%90%91/Flutter%E9%80%86%E5%90%91%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="📖-概述"><a href="#📖-概述" class="headerlink" title="📖 概述"></a>📖 概述</h2><div class="note info modern"><p><strong>Flutter逆向分析是移动安全研究的重要组成部分</strong></p><ul><li>本文将详细介绍使用blutter工具对Flutter应用进行逆向分析的完整流程</li><li>包含环境配置、工具使用和常见问题解决方案</li></ul></div><h2 id="🛠️-工具介绍"><a href="#🛠️-工具介绍" class="headerlink" title="🛠️ 工具介绍"></a>🛠️ 工具介绍</h2><div class="note blue icon-padding modern"><i class="note-icon fab fa-github"></i><p><strong>推荐工具：blutter</strong></p><ul><li>项目地址：<a href="https://github.com/crowforkotlin/blutter">blutter - GitHub</a></li><li>专门用于Flutter应用的逆向分析工具</li><li>支持将Flutter so文件反编译为Dart源码</li></ul></div><h2 id="🚀-完整流程"><a href="#🚀-完整流程" class="headerlink" title="🚀 完整流程"></a>🚀 完整流程</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">环境准备</button><button type="button" class="tab">依赖安装</button><button type="button" class="tab">执行逆向</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="📋-系统要求"><a href="#📋-系统要求" class="headerlink" title="📋 系统要求"></a>📋 系统要求</h3><div class="note warning icon-padding modern"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>重要提示：</strong></p><ul><li>blutter工具对GCC版本有严格要求，需要GCC 13版本以上</li><li>推荐使用WSL Ubuntu-24.04环境进行操作</li></ul></div><h3 id="🔧-WSL环境配置"><a href="#🔧-WSL环境配置" class="headerlink" title="🔧 WSL环境配置"></a>🔧 WSL环境配置</h3><div class="note success icon-padding modern"><i class="note-icon fas fa-terminal"></i><p><strong>第一步：安装WSL Ubuntu-24.04</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可用的Linux发行版</span></span><br><span class="line">wsl -list -online</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Ubuntu-24.04</span></span><br><span class="line">wsl --install Ubuntu-24.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动指定发行版</span></span><br><span class="line">wsl --distribution Ubuntu-24.04</span><br></pre></td></tr></table></figure><div class="note success icon-padding modern"><i class="note-icon fas fa-user-cog"></i><p><strong>第二步：配置用户权限</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置root密码</span></span><br><span class="line">sudo passwd root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到root用户</span></span><br><span class="line">su</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h3 id="📦-安装编译工具链"><a href="#📦-安装编译工具链" class="headerlink" title="📦 安装编译工具链"></a>📦 安装编译工具链</h3><div class="note primary icon-padding modern"><i class="note-icon fas fa-download"></i><p><strong>更新系统包管理器</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新包列表</span></span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><div class="note primary icon-padding modern"><i class="note-icon fas fa-code"></i><p><strong>安装GCC 13工具链</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装GCC 13和G++ 13</span></span><br><span class="line">sudo apt install gcc-13 g++-13</span><br></pre></td></tr></table></figure><div class="note info icon-padding modern"><i class="note-icon fas fa-cogs"></i><p><strong>可选：设置GCC默认版本</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置GCC默认版本</span></span><br><span class="line">sudo update-alternatives --config gcc</span><br><span class="line">sudo update-alternatives --config g++</span><br></pre></td></tr></table></figure><h3 id="🔗-安装项目依赖"><a href="#🔗-安装项目依赖" class="headerlink" title="🔗 安装项目依赖"></a>🔗 安装项目依赖</h3><div class="note success icon-padding modern"><i class="note-icon fas fa-puzzle-piece"></i><p><strong>安装所有必需的依赖包</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装blutter所需的全部依赖</span></span><br><span class="line">apt install python3-pyelftools python3-requests git cmake ninja-build \</span><br><span class="line">build-essential pkg-config libicu-dev libcapstone-dev</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h3 id="🎯-运行blutter工具"><a href="#🎯-运行blutter工具" class="headerlink" title="🎯 运行blutter工具"></a>🎯 运行blutter工具</h3><div class="note purple icon-padding modern"><i class="note-icon fas fa-play"></i><p><strong>执行反编译命令</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用blutter对arm64-v8a so文件进行反编译</span></span><br><span class="line">python3 blutter.py arm64-v8a/ out_dir</span><br></pre></td></tr></table></figure><div class="note info icon-padding modern"><i class="note-icon fas fa-info-circle"></i><p><strong>参数说明：</strong></p><ul><li><code>arm64-v8a/</code> - 输入目录，包含Flutter的so文件</li><li><code>out_dir</code> - 输出目录，将生成反编译后的Dart文件</li></ul></div><h3 id="📁-输出结果"><a href="#📁-输出结果" class="headerlink" title="📁 输出结果"></a>📁 输出结果</h3><div class="note success icon-padding modern"><i class="note-icon fas fa-check-circle"></i><p><strong>成功标志：</strong><br>如果配置正确，将会在<code>out_dir</code>目录中生成反编译出来的Dart源码文件</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="⚠️-常见问题与解决方案"><a href="#⚠️-常见问题与解决方案" class="headerlink" title="⚠️ 常见问题与解决方案"></a>⚠️ 常见问题与解决方案</h2><div class="note danger icon-padding modern"><i class="note-icon fas fa-bug"></i><p><strong>已知问题：blutter在某些环境下存在兼容性问题</strong></p></div><h3 id="🔴-问题1：Debian环境编译错误"><a href="#🔴-问题1：Debian环境编译错误" class="headerlink" title="🔴 问题1：Debian环境编译错误"></a>🔴 问题1：Debian环境编译错误</h3><div class="note red icon-padding modern"><i class="note-icon fas fa-times-circle"></i><p><strong>问题描述：</strong><br>在WSL Debian环境下，安装了GCC 13，使用blutter对arm64-v8a so进行反编译时仍然产生大量错误</p></div><div class="note green icon-padding modern"><i class="note-icon fas fa-lightbulb"></i><p><strong>解决方案：</strong><br>建议使用WSL Ubuntu-24.04替代Debian，Ubuntu-24.04对blutter的兼容性更好</p></div><h3 id="🟡-问题2：GCC版本不兼容"><a href="#🟡-问题2：GCC版本不兼容" class="headerlink" title="🟡 问题2：GCC版本不兼容"></a>🟡 问题2：GCC版本不兼容</h3><div class="note warning icon-padding modern"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>问题描述：</strong><br>系统默认GCC版本低于13，导致编译失败</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-tools"></i><p><strong>解决方案：</strong><br>按照上述流程安装GCC 13，并配置为默认版本</p></div><h2 id="🔗-相关资源"><a href="#🔗-相关资源" class="headerlink" title="🔗 相关资源"></a>🔗 相关资源</h2><div class="btn-center"><a class="btn-beautify blue larger" href="https://github.com/crowforkotlin/blutter" title="blutter工具"><i class="fab fa-github"></i><span>blutter工具</span></a><a class="btn-beautify green larger" href="https://flutter.dev" title="Flutter官网"><i class="fas fa-external-link-alt"></i><span>Flutter官网</span></a></div>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Fragment重建踩坑</title>
      <link href="/2025/06/11/Android/ui/fragment/Fragment%E9%87%8D%E5%BB%BA%E8%B8%A9%E5%9D%91/"/>
      <url>/2025/06/11/Android/ui/fragment/Fragment%E9%87%8D%E5%BB%BA%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当使用Navigationd进行Fragment的导航时，返回到上一个fragmentA会导致fragmentA的界面重新创建此时数据要自己去回复，大部分的view&#x2F;viewgroup的state默认已经做好恢复处理，例如coordinator，只需要指定id才能解决恢复问题，还有recyclerview。但是如果遇到了动态addView要如何解决？我这里动态addView的视图是一个ViewPager，要实现重建时动态添加的View能够正确的恢复，必须在重建前onViewCreate去AddView，并且viewpager的adapter需要继承FragmentStateAdapter</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 踩坑 </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android GridLayoutManager踩坑</title>
      <link href="/2025/06/11/Android/ui/recyclerview/GridLayoutManager%E8%B8%A9%E5%9D%91/"/>
      <url>/2025/06/11/Android/ui/recyclerview/GridLayoutManager%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SpanSizeLookUp 可以设置item占满的大小，和spancount意思不同！如SpanCount &#x3D; 4, ItemA span size &#x3D; 4  代表1个Item占满大小1行 即 4&#x2F;4 ， ItemB span size &#x3D; 1 代表一个1个Item占一行的 四分之一, 将会均分4份！之前因为这里排查了不少时间</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 踩坑 </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modbus通信协议实战指南</title>
      <link href="/2023/10/07/%E5%8D%8F%E8%AE%AE/Modbus/"/>
      <url>/2023/10/07/%E5%8D%8F%E8%AE%AE/Modbus/</url>
      
        <content type="html"><![CDATA[<div class="note modern"><p>🎯 <strong>学习目标</strong>：全面掌握Modbus协议的原理、应用和实战技巧，成为工业通信领域的专家</p></div><h2 id="🚀-协议概述"><a href="#🚀-协议概述" class="headerlink" title="🚀 协议概述"></a>🚀 协议概述</h2><p><strong>Modbus</strong> 是工业自动化领域使用最广泛的通信协议之一，具有简单、可靠、开放的特点。</p><div class="note info icon-padding flat"><i class="note-icon fas fa-network-wired"></i><p><strong>协议特点</strong>：开放性强、实现简单、设备兼容性好、在工业控制系统中应用广泛</p></div><h3 id="🏗️-架构模式"><a href="#🏗️-架构模式" class="headerlink" title="🏗️ 架构模式"></a>🏗️ 架构模式</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">👥 主从架构</button><button type="button" class="tab">🌐 网络拓扑</button><button type="button" class="tab">📊 数据模型</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>基本概念：</strong></p><ul><li>🖥️ <strong>主站（Master）</strong>：相当于客户端，主动发起通信请求</li><li>🔧 <strong>从站（Slave）</strong>：相当于服务端，被动响应主站请求</li><li>📡 <strong>通信特点</strong>：半双工通信，主站轮询从站</li></ul><div class="note blue icon-padding flat"><i class="note-icon fas fa-exchange-alt"></i><p><strong>通信流程</strong>：主站发送请求 → 从站处理并响应 → 主站接收数据</p></div></div><div class="tab-item-content"><p><strong>支持的网络类型：</strong></p><ul><li>🔌 <strong>Modbus RTU</strong>：基于RS-485串行通信</li><li>🌍 <strong>Modbus TCP</strong>：基于以太网TCP&#x2F;IP</li><li>⚡ <strong>Modbus ASCII</strong>：ASCII编码的串行通信</li></ul><div class="note green icon-padding flat"><i class="note-icon fas fa-sitemap"></i><p><strong>网络特点</strong>：支持1个主站和最多247个从站设备</p></div></div><div class="tab-item-content"><p><strong>四种数据类型：</strong></p><ul><li>🔘 <strong>线圈（Coils）</strong>：单比特可读写数据</li><li>📥 <strong>离散输入（Discrete Inputs）</strong>：单比特只读数据  </li><li>📋 <strong>保持寄存器（Holding Registers）</strong>：16位可读写数据</li><li>📤 <strong>输入寄存器（Input Registers）</strong>：16位只读数据</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="📚-基础概念理解"><a href="#📚-基础概念理解" class="headerlink" title="📚 基础概念理解"></a>📚 基础概念理解</h2><h3 id="关键术语"><a href="#关键术语" class="headerlink" title="关键术语"></a>关键术语</h3><p><strong>● 1字节（位） &#x3D; 1byte（一个字节） &#x3D; 8bit</strong></p><ul><li>1个字节可以表示0-255的数值</li><li>在Modbus中，地址、功能码等都以字节为单位</li></ul><p><strong>● 串行链路</strong>：数据一位一位按顺序传输的方式</p><ul><li>在广域网中提供远距离传输</li><li>分为”异步”和”同步”传输方式</li><li>以字节为单位进行数据传输</li></ul><blockquote><p>广域网（WAN）：连接不同地区局域网的远程网络，覆盖范围从几十公里到几千公里</p></blockquote><p><strong>● PDU（协议数据单元）</strong>：网络通信中传输的数据单位</p><ul><li>包含控制信息和用户数据</li><li>在不同网络层级有不同名称：包（Packet）、段（Segment）、帧（Frame）</li><li>Modbus中定义了与通信层无关的简单协议数据单元</li></ul><p><strong>● ASCII</strong>：美国信息交换标准代码，与UTF-8都是字符编码方式</p><h3 id="🔧-Modbus操作对象（通用数据类型）"><a href="#🔧-Modbus操作对象（通用数据类型）" class="headerlink" title="🔧 Modbus操作对象（通用数据类型）"></a>🔧 Modbus操作对象（通用数据类型）</h3><table><thead><tr><th>对象类型</th><th>地址范围</th><th>数据位数</th><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><strong>线圈</strong></td><td>00001-09999</td><td>1位</td><td>读写</td><td>PLC输出位，开关量</td></tr><tr><td><strong>离散输入</strong></td><td>10001-19999</td><td>1位</td><td>只读</td><td>PLC输入位，开关量</td></tr><tr><td><strong>输入寄存器</strong></td><td>30001-39999</td><td>16位</td><td>只读</td><td>模拟量输入</td></tr><tr><td><strong>保持寄存器</strong></td><td>40001-49999</td><td>16位</td><td>读写</td><td>模拟量输出</td></tr></tbody></table><p><strong>通用数据结构说明</strong>：</p><ul><li><strong>1位数据</strong>：线圈和离散输入，存储开关状态（0&#x2F;1）</li><li><strong>16位数据</strong>：寄存器类型，存储数值（0-65535）</li><li><strong>地址编码</strong>：前缀数字区分不同类型，实际传输时使用相对地址</li></ul><h2 id="🔢-功能码详解"><a href="#🔢-功能码详解" class="headerlink" title="🔢 功能码详解"></a>🔢 功能码详解</h2><table><thead><tr><th>功能码</th><th>名称</th><th>操作对象</th><th>描述</th></tr></thead><tbody><tr><td><strong>01</strong></td><td>读线圈状态</td><td>00001-09999</td><td>读取离散输出状态</td></tr><tr><td><strong>02</strong></td><td>读离散输入</td><td>10001-19999</td><td>读取离散输入状态</td></tr><tr><td><strong>03</strong></td><td>读保持寄存器</td><td>40001-49999</td><td>读取模拟输出值</td></tr><tr><td><strong>04</strong></td><td>读输入寄存器</td><td>30001-39999</td><td>读取模拟输入值</td></tr><tr><td><strong>05</strong></td><td>写单个线圈</td><td>00001-09999</td><td>写入单个线圈</td></tr><tr><td><strong>06</strong></td><td>写单个寄存器</td><td>40001-49999</td><td>写入单个寄存器</td></tr><tr><td><strong>0F(15)</strong></td><td>写多个线圈</td><td>00001-09999</td><td>写入多个线圈</td></tr><tr><td><strong>10(16)</strong></td><td>写多个寄存器</td><td>40001-49999</td><td>写入多个寄存器</td></tr></tbody></table><h2 id="📦-数据帧格式"><a href="#📦-数据帧格式" class="headerlink" title="📦 数据帧格式"></a>📦 数据帧格式</h2><h3 id="通用PDU结构"><a href="#通用PDU结构" class="headerlink" title="通用PDU结构"></a>通用PDU结构</h3><table><thead><tr><th align="center">功能码</th><th align="center">数据</th></tr></thead><tbody><tr><td align="center">1字节</td><td align="center">不定长</td></tr></tbody></table><h3 id="MBAP报文头（TCP专用）"><a href="#MBAP报文头（TCP专用）" class="headerlink" title="MBAP报文头（TCP专用）"></a>MBAP报文头（TCP专用）</h3><table><thead><tr><th align="center">事务处理标识</th><th align="center">协议标识</th><th align="center">长度</th><th align="center">单元标识符</th></tr></thead><tbody><tr><td align="center">2字节</td><td align="center">2字节</td><td align="center">2字节</td><td align="center">1字节</td></tr></tbody></table><p><strong>字节含义说明</strong>：</p><ul><li><strong>事务处理标识</strong>：报文序列号，每次通信后加1</li><li><strong>协议标识符</strong>：00 00表示Modbus TCP协议  </li><li><strong>长度</strong>：后续数据长度（字节数）</li><li><strong>单元标识符</strong>：设备地址</li></ul><h3 id="1-Modbus-RTU帧模式"><a href="#1-Modbus-RTU帧模式" class="headerlink" title="1. Modbus RTU帧模式"></a>1. Modbus RTU帧模式</h3><table><thead><tr><th align="center">设备地址</th><th align="center">功能代码</th><th align="center">数据格式</th><th align="center">CRC16校验</th></tr></thead><tbody><tr><td align="center">1字节</td><td align="center">1字节</td><td align="center">N字节</td><td align="center">2字节</td></tr></tbody></table><p><strong>读&#x2F;写单个操作</strong>：</p><table><thead><tr><th align="center">设备地址</th><th align="center">功能代码</th><th align="center">起始地址（高位）</th><th align="center">起始地址（低位）</th><th align="center">数量（高位）</th><th align="center">数量（低位）</th><th align="center">CRC16校验</th></tr></thead><tbody><tr><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">2字节</td></tr></tbody></table><p><strong>读&#x2F;写多个操作</strong>：</p><table><thead><tr><th align="center">设备地址</th><th align="center">功能代码</th><th align="center">起始地址（高位）</th><th align="center">起始地址（低位）</th><th align="center">数量（高位）</th><th align="center">数量（低位）</th><th align="center">字节数</th><th align="center">数据</th><th align="center">CRC16校验</th></tr></thead><tbody><tr><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">1字节</td><td align="center">N字节</td><td align="center">2字节</td></tr></tbody></table><h3 id="2-Modbus-ASCII帧模式"><a href="#2-Modbus-ASCII帧模式" class="headerlink" title="2. Modbus ASCII帧模式"></a>2. Modbus ASCII帧模式</h3><table><thead><tr><th align="center">帧头</th><th align="center">设备地址</th><th align="center">功能码</th><th align="center">数据</th><th align="center">校验码LRC</th><th align="center">回车</th><th align="center">换行</th></tr></thead><tbody><tr><td align="center">1字符</td><td align="center">2字符</td><td align="center">2字符</td><td align="center">N字符</td><td align="center">2字符</td><td align="center">1字符</td><td align="center">1字符</td></tr><tr><td align="center"><code>:</code></td><td align="center">01</td><td align="center">03</td><td align="center">00 00 00 01</td><td align="center">FB</td><td align="center"><code>\r</code></td><td align="center"><code>\n</code></td></tr></tbody></table><h3 id="3-Modbus-TCP帧模式"><a href="#3-Modbus-TCP帧模式" class="headerlink" title="3. Modbus TCP帧模式"></a>3. Modbus TCP帧模式</h3><table><thead><tr><th align="center">MBAP报文头</th><th align="center">功能码</th><th align="center">数据</th></tr></thead><tbody><tr><td align="center">7字节</td><td align="center">1字节</td><td align="center">N字节</td></tr></tbody></table><h2 id="🔧-通用数据封装思路"><a href="#🔧-通用数据封装思路" class="headerlink" title="🔧 通用数据封装思路"></a>🔧 通用数据封装思路</h2><p><strong>三种帧格式的共同点</strong>：</p><ol><li><strong>核心数据</strong>：设备地址、功能码、起始地址、数量&#x2F;数值</li><li><strong>数据部分</strong>：根据功能码决定是否包含字节数和具体数值</li><li><strong>校验方式</strong>：RTU用CRC16，ASCII用LRC，TCP无需校验</li></ol><p><strong>封装策略</strong>：</p><ul><li>先构建通用的PDU部分（功能码+数据）</li><li>根据传输模式添加不同的头部和校验</li><li>字节序按照大端模式（高位在前）</li></ul><h2 id="💻-代码实现"><a href="#💻-代码实现" class="headerlink" title="💻 代码实现"></a>💻 代码实现</h2><h3 id="RTU模式构建"><a href="#RTU模式构建" class="headerlink" title="RTU模式构建"></a>RTU模式构建</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RTU</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">( function: <span class="type">ModbusFunction</span>, slave: <span class="type">Int</span>, startAddress: <span class="type">Int</span>, count: <span class="type">Int</span>, value: <span class="type">Int</span>? = <span class="literal">null</span>, values: <span class="type">IntArray</span>? = <span class="literal">null</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> output = buildOutput(slave, function, startAddress, count, value, values)</span><br><span class="line">    toCalculateCRC16(output.toByteArray(), output)</span><br><span class="line">    <span class="keyword">return</span> output.toByteArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCP模式构建"><a href="#TCP模式构建" class="headerlink" title="TCP模式构建"></a>TCP模式构建</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> mTransactionId: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mProtocol: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">(function: <span class="type">ModbusFunction</span>, slave: <span class="type">Int</span>, startAddress: <span class="type">Int</span>, count: <span class="type">Int</span>,value: <span class="type">Int</span>? = <span class="literal">null</span>, values: <span class="type">IntArray</span>? = <span class="literal">null</span>, transactionId: <span class="type">Int</span> = mTransactionId)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> pdu = buildOutput(slave, function, startAddress, count, value, values, isTcp = <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">val</span> size = pdu.size()</span><br><span class="line">    <span class="keyword">val</span> mbap = BytesOutput()</span><br><span class="line">    mbap.writeInt16(transactionId)</span><br><span class="line">    mbap.writeInt16(mProtocol)</span><br><span class="line">    mbap.writeInt16(size + <span class="number">1</span>)</span><br><span class="line">    mbap.writeInt8(slave)</span><br><span class="line">    mbap.write(pdu.toByteArray())</span><br><span class="line">    mTransactionId++</span><br><span class="line">    <span class="keyword">return</span> mbap.toByteArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ASCII模式构建"><a href="#ASCII模式构建" class="headerlink" title="ASCII模式构建"></a>ASCII模式构建</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ASCII</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> HEAD = <span class="number">0x3A</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> END = byteArrayOf(<span class="number">0x0d</span>, <span class="number">0x0A</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">( function: <span class="type">ModbusFunction</span>, slave: <span class="type">Int</span>, startAddress: <span class="type">Int</span>, count: <span class="type">Int</span>, value: <span class="type">Int</span>? = <span class="literal">null</span>, values: <span class="type">IntArray</span>? = <span class="literal">null</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> bytes = BytesOutput()</span><br><span class="line">    <span class="keyword">val</span> output = buildOutput(slave, function, startAddress, count, value, values).toByteArray()</span><br><span class="line">    <span class="keyword">val</span> pLRC = fromAsciiInt8(toCalculateLRC(output))</span><br><span class="line">    <span class="keyword">val</span> outputAscii = toAsciiHexBytes(output)</span><br><span class="line">    bytes.writeInt8(HEAD)</span><br><span class="line">    bytes.writeBytes(outputAscii, outputAscii.size)</span><br><span class="line">    bytes.writeInt8(pLRC.first)</span><br><span class="line">    bytes.writeInt8(pLRC.second)</span><br><span class="line">    bytes.writeBytes(END, END.size)</span><br><span class="line">    <span class="keyword">return</span> bytes.toByteArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心构建函数"><a href="#核心构建函数" class="headerlink" title="核心构建函数"></a>核心构建函数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心实现</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">KModbus</span> <span class="keyword">protected</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ● 构造输出的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ● 2023-10-16 16:42:18 周一 下午</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> crowforkotlin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">buildOutput</span><span class="params">(slave: <span class="type">Int</span>, function: <span class="type">ModbusFunction</span>, startAddress: <span class="type">Int</span>, count: <span class="type">Int</span>, value: <span class="type">Int</span>?, values: <span class="type">IntArray</span>?, isTcp: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>: BytesOutput &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查参数是否符合协议规定</span></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            slave !<span class="keyword">in</span> <span class="number">0.</span>.<span class="number">0xFF</span> -&gt; <span class="keyword">throw</span> ModbusException(ModbusErrorType.ModbusInvalidArgumentError, <span class="string">&quot;Invalid slave <span class="variable">$slave</span>&quot;</span>)</span><br><span class="line">            startAddress !<span class="keyword">in</span> <span class="number">0.</span>.<span class="number">0xFFFF</span> -&gt; <span class="keyword">throw</span> ModbusException(ModbusErrorType.ModbusInvalidArgumentError, <span class="string">&quot;Invalid startAddress <span class="variable">$startAddress</span>&quot;</span>)</span><br><span class="line">            count !<span class="keyword">in</span> <span class="number">1.</span>.<span class="number">0xFF</span> -&gt; <span class="keyword">throw</span> ModbusException(ModbusErrorType.ModbusInvalidArgumentError, <span class="string">&quot;Invalid count <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> output = BytesOutput()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isTcp) &#123;</span><br><span class="line">            output.writeInt8(slave)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">when</span>(function) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读线圈寄存器 、离散输入寄存器、保持寄存器、输入寄存器</span></span><br><span class="line">            ModbusFunction.READ_COILS, ModbusFunction.READ_DISCRETE_INPUTS, ModbusFunction.READ_INPUT_REGISTERS, ModbusFunction.READ_HOLDING_REGISTERS -&gt; &#123;</span><br><span class="line">                output.writeInt8(function.mCode)</span><br><span class="line">                output.writeInt16(startAddress)</span><br><span class="line">                output.writeInt16(count)</span><br><span class="line">            &#125;</span><br><span class="line">            ModbusFunction.WRITE_SINGLE_COIL, ModbusFunction.WRITE_SINGLE_REGISTER -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> valueCopy = value ?: <span class="keyword">throw</span> ModbusException(ModbusErrorType.ModbusInvalidArgumentError, <span class="string">&quot;Function Is <span class="variable">$function</span>\t , Data must be passed in!&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//写单个寄存器指令</span></span><br><span class="line">                <span class="keyword">if</span> (function == ModbusFunction.WRITE_SINGLE_COIL) <span class="keyword">if</span> (value != <span class="number">0</span>) valueCopy = <span class="number">0xff00</span> <span class="comment">//如果为线圈寄存器（写1时为 FF 00,写0时为00 00）</span></span><br><span class="line"></span><br><span class="line">                output.writeInt8(function.mCode)</span><br><span class="line">                output.writeInt16(startAddress)</span><br><span class="line">                output.writeInt16(valueCopy)</span><br><span class="line">            &#125;</span><br><span class="line">            ModbusFunction.WRITE_HOLDING_REGISTERS -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//写多个保持寄存器</span></span><br><span class="line">                output.writeInt8(function.mCode)</span><br><span class="line">                output.writeInt16(startAddress)</span><br><span class="line">                output.writeInt16(count)</span><br><span class="line">                output.writeInt8(<span class="number">2</span> * count)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//写入数据</span></span><br><span class="line">                (values ?: <span class="keyword">throw</span> ModbusException(ModbusErrorType.ModbusInvalidArgumentError, <span class="string">&quot;Function Is <span class="variable">$function</span>, Data must be passed in!&quot;</span>)).forEach &#123; output.writeInt16(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ModbusFunction.WRITE_COILS -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (values == <span class="literal">null</span> || values.isEmpty()) <span class="keyword">throw</span> ModbusException(ModbusErrorType.ModbusInvalidArgumentError, <span class="string">&quot;Function Is <span class="variable">$function</span>, Data must be passed in and cannot be empty!&quot;</span>)</span><br><span class="line">                output.writeInt8(function.mCode)</span><br><span class="line">                output.writeInt16(startAddress)</span><br><span class="line">                output.writeInt16(count)</span><br><span class="line">                output.writeInt8((count + <span class="number">7</span>) shr <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">val</span> chunkedValues = values.toList().chunked(<span class="number">8</span>)</span><br><span class="line">                <span class="keyword">for</span> (chunk <span class="keyword">in</span> chunkedValues) &#123;</span><br><span class="line">                    output.writeInt8(toDecimal(chunk.reversed().toIntArray()))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ● CRC校验</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ● 2023-10-16 16:06:48 周一 下午</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> crowforkotlin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toCalculateCRC16</span><span class="params">(output: <span class="type">BytesOutput</span>)</span></span>: BytesOutput &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算CRC校验码</span></span><br><span class="line">        output.writeInt16Reversal(CRC16.compute(output.toByteArray()))</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ● LRC校验</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ● 2023-10-16 16:06:41 周一 下午</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> crowforkotlin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toCalculateLRC</span><span class="params">(<span class="keyword">data</span>: <span class="type">ByteArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> iTmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="keyword">data</span>) &#123;</span><br><span class="line">            iTmp += x.toInt()</span><br><span class="line">        &#125;</span><br><span class="line">        iTmp %= <span class="number">256</span></span><br><span class="line">        iTmp = (iTmp.inv() + <span class="number">1</span>) and <span class="number">0xFF</span> <span class="comment">// 对补码取模，确保结果在0-255范围内</span></span><br><span class="line">        <span class="keyword">return</span> iTmp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ● Convert each digit component to decimal</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ● 2023-10-16 16:00:53 周一 下午</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> crowforkotlin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">toDecimal</span><span class="params">(<span class="keyword">data</span>: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (bit <span class="keyword">in</span> <span class="keyword">data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bit != <span class="number">0</span> &amp;&amp; bit != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment">// 数据数组中包含非二进制值，返回错误</span></span><br><span class="line">            &#125;</span><br><span class="line">            result = (result shl <span class="number">1</span>) + bit</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="📖-开源项目及参考资料"><a href="#📖-开源项目及参考资料" class="headerlink" title="📖 开源项目及参考资料"></a>📖 开源项目及参考资料</h2><ul><li>🔗 <a href="https://github.com/crowforkotlin/KModbus">KModbus - Kotlin实现</a></li><li>🔗 <a href="https://github.com/stephane/libmodbus">LibModbus - C实现</a></li><li>📚 <a href="https://zhuanlan.zhihu.com/p/484463923">知乎 - Modbus详解</a></li><li>📚 <a href="https://blog.csdn.net/tiandiren111/article/details/118347661">CSDN - Modbus教程</a></li></ul><hr><blockquote><p>💡 <strong>总结</strong>: 本文介绍了Modbus协议的基本概念、数据帧格式和Kotlin实现方法，适合工业自动化入门学习。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> Modbus </tag>
            
            <tag> 工业通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>② 通过JNI打开Android串口</title>
      <link href="/2023/09/27/Android/02JNI%E6%89%93%E5%BC%80%E5%AE%89%E5%8D%93%E4%B8%B2%E5%8F%A3/"/>
      <url>/2023/09/27/Android/02JNI%E6%89%93%E5%BC%80%E5%AE%89%E5%8D%93%E4%B8%B2%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="📖-说明"><a href="#📖-说明" class="headerlink" title="📖 说明"></a>📖 说明</h2><div class="note info modern"><p><strong>本篇文章将详细介绍如何通过JNI在Android中实现串口通信</strong></p><ul><li>在上一篇文章中我们配置了JNI的基础环境和相关上层、C层函数声明</li><li>接下来将编写相关代码来打开串口并进行通信</li></ul></div><h3 id="🔍-Android串口通信原理"><a href="#🔍-Android串口通信原理" class="headerlink" title="🔍 Android串口通信原理"></a>🔍 Android串口通信原理</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">基本原理</button><button type="button" class="tab">代码参考</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="note primary modern"><p><strong>Android串口通信的核心原理：</strong></p><ol><li><strong>Root权限要求</strong>：设备需要root权限才能访问串口文件</li><li><strong>文件句柄操作</strong>：通过文件句柄来管理串口的相关信息（位置、权限、IO信息等）</li><li><strong>串口配置</strong>：获取文件句柄后可以对串口进行配置、交互等操作</li></ol></div><div class="note warning modern"><p><strong>重要提示</strong>：文件句柄是用于管理文件相关信息的抽象概念，包括文件位置、权限、IO信息等</p></div></div><div class="tab-item-content"><div class="note blue icon-padding modern"><i class="note-icon fab fa-github"></i><p><strong>代码核心部分都添加了详细注释，完整源码请查看：</strong><br><a href="https://github.com/crowforkotlin/KModbus">KModbus - GitHub</a></p></div><div class="note green icon-padding modern"><i class="note-icon fas fa-code"></i><p><strong>参考资料：</strong><br><a href="https://github.com/stephane/libmodbus/blob/b25629bfb508bdce7d519884c0fa9810b7d98d44/src/modbus-rtu.c#L661">LibModbus 源码参考</a></p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🔧-串口查看与准备"><a href="#🔧-串口查看与准备" class="headerlink" title="🔧 串口查看与准备"></a>🔧 串口查看与准备</h2><div class="note warning icon-padding modern"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>前置要求：</strong></p><ul><li>确保设备已Root</li><li>准备ADB工具并配置环境变量</li></ul></div><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><div class="note success icon-padding modern"><i class="note-icon fas fa-terminal"></i><p><strong>串口检查命令：</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接设备shell</span></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取管理员权限</span></span><br><span class="line">su</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示串口列表</span></span><br><span class="line"><span class="built_in">ls</span> /dev | grep ttyS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个串口是否占用（以ttyS0为例）</span></span><br><span class="line">lsof /dev/ttyS0</span><br></pre></td></tr></table></figure><h2 id="💻-代码实现"><a href="#💻-代码实现" class="headerlink" title="💻 代码实现"></a>💻 代码实现</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">JNI实现</button><button type="button" class="tab">Kotlin实现</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="🔌-打开串口"><a href="#🔌-打开串口" class="headerlink" title="🔌 打开串口"></a>🔌 打开串口</h3><div class="note blue icon-padding modern"><i class="note-icon fas fa-code"></i><p><strong>核心函数：<code>Java_com_crow_modbus_serialport_SerialPort_open</code></strong></p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     android_serialport_SerialPort</span></span><br><span class="line"><span class="comment"> * Method:    open</span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * Opens a serial port and configures its parameters such as baud rate, data bits, stop bits, and parity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parameters:</span></span><br><span class="line"><span class="comment"> *   path     - The path to the serial port device (e.g., &quot;/dev/ttyS0&quot;).</span></span><br><span class="line"><span class="comment"> *   baudrate - The desired baud rate (e.g., 9600).</span></span><br><span class="line"><span class="comment"> *   flags    - Flags for opening the serial port (e.g., O_RDWR).</span></span><br><span class="line"><span class="comment"> *   parity   - Parity mode (0 for none, 1 for even, 2 for odd).</span></span><br><span class="line"><span class="comment"> *   stop_bit - Stop bit mode (1 or 2).</span></span><br><span class="line"><span class="comment"> *   data_bit - Data bits (5, 6, 7, or 8).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *   A FileDescriptor object representing the opened serial port, or NULL if an error occurs.</span></span><br><span class="line"><span class="comment"> * @author : revise by crowforkotlin </span></span><br><span class="line"><span class="comment"> * @link : https://github.com/stephane/libmodbus/blob/b25629bfb508bdce7d519884c0fa9810b7d98d44/src/modbus-rtu.c#L661</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jobject JNICALL <span class="title function_">Java_com_crow_modbus_serialport_SerialPort_open</span></span><br><span class="line"><span class="params">(JNIEnv *env, jclass thiz, jstring path, jint baudrate, jint flags, jint parity, jint stop_bit, jint data_bit)</span> &#123;</span><br><span class="line">    LOGD(<span class="string">&quot;----------------------------------------------------------&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">speed_t</span> speed;</span><br><span class="line">    jobject mFileDescriptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验波特率是否正确</span></span><br><span class="line">    &#123;</span><br><span class="line">        speed = getBaudrate(baudrate);</span><br><span class="line">        <span class="keyword">if</span> (speed == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">&quot;Invalid baudrate！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启串口 O_RDWR 开启读写权限</span></span><br><span class="line">    &#123;</span><br><span class="line">        jboolean iscopy;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *path_utf = (*env)-&gt;GetStringUTFChars(env, path, &amp;iscopy);</span><br><span class="line">        LOGD(<span class="string">&quot;Opening serial port %s with flags 0x%x&quot;</span>, path_utf, O_RDWR | flags);</span><br><span class="line">        fd = open(path_utf, O_RDWR | flags);</span><br><span class="line">        LOGD(<span class="string">&quot;open() fd = %d&quot;</span>, fd);</span><br><span class="line">        (*env)-&gt;ReleaseStringUTFChars(env, path, path_utf);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">&quot;Cannot open port&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置串口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">cfg</span>;</span></span><br><span class="line">        LOGD(<span class="string">&quot;Configuring serial port&quot;</span>);</span><br><span class="line">        <span class="comment">// 尝试获取文件描述符fd标识并存储到cfg结构体中</span></span><br><span class="line">        <span class="keyword">if</span> (tcgetattr(fd, &amp;cfg)) &#123;</span><br><span class="line">            LOGE(<span class="string">&quot;tcgetattr() failed&quot;</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置原始模式，禁用自动特殊字符处理、奇偶校验等功能</span></span><br><span class="line">        <span class="comment">// 以便更精确地控制串口数据的传输</span></span><br><span class="line">        cfmakeraw(&amp;cfg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置输入输出波特率</span></span><br><span class="line">        cfsetispeed(&amp;cfg, speed);</span><br><span class="line">        cfsetospeed(&amp;cfg, speed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置数据位 (5, 6, 7, 8 bits)</span></span><br><span class="line"><span class="comment">         * CSIZE Bit mask for data bits</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        cfg.c_cflag &amp;= ~CSIZE;</span><br><span class="line">        <span class="keyword">switch</span> (data_bit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                cfg.c_cflag |= CS5;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                cfg.c_cflag |= CS6;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                cfg.c_cflag |= CS7;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cfg.c_cflag |= CS8;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置停止位 (1 or 2) */</span></span><br><span class="line">        <span class="keyword">if</span> (stop_bit == <span class="number">1</span>)</span><br><span class="line">            cfg.c_cflag &amp;= ~CSTOPB;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* 2 */</span></span><br><span class="line">            cfg.c_cflag |= CSTOPB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置校验位模式 Enable parity bit </span></span><br><span class="line">        <span class="keyword">if</span> (parity == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGD(<span class="string">&quot;NONE&quot;</span>);</span><br><span class="line">            cfg.c_cflag &amp;= ~PARENB;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parity == <span class="number">1</span>) &#123;</span><br><span class="line">            LOGD(<span class="string">&quot;Even&quot;</span>);</span><br><span class="line">            cfg.c_cflag |= PARENB;</span><br><span class="line">            cfg.c_cflag &amp;= ~PARODD;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGD(<span class="string">&quot;ODD&quot;</span>);</span><br><span class="line">            cfg.c_cflag |= PARENB;</span><br><span class="line">            cfg.c_cflag |= PARODD;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (tcsetattr(fd, TCSANOW, &amp;cfg)) &#123;</span><br><span class="line">            LOGE(<span class="string">&quot;tcsetattr() failed&quot;</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件描述符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取类、构造函数ID、字段ID 最后实例化FileDescriptor后并设置字段</span></span><br><span class="line">        jclass cFileDescriptor = (*env)-&gt;FindClass(env, <span class="string">&quot;java/io/FileDescriptor&quot;</span>);</span><br><span class="line">        jmethodID iFileDescriptor = (*env)-&gt;GetMethodID(env, cFileDescriptor, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">        jfieldID descriptorID = (*env)-&gt;GetFieldID(env, cFileDescriptor, <span class="string">&quot;descriptor&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">        mFileDescriptor = (*env)-&gt;NewObject(env, cFileDescriptor, iFileDescriptor);</span><br><span class="line">        (*env)-&gt;SetIntField(env, mFileDescriptor, descriptorID, (jint) fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mFileDescriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🔒-关闭串口"><a href="#🔒-关闭串口" class="headerlink" title="🔒 关闭串口"></a>🔒 关闭串口</h3><div class="note blue icon-padding modern"><i class="note-icon fas fa-code"></i><p><strong>核心函数：<code>Java_com_crow_modbus_serialport_SerialPort_close</code></strong></p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     cedric_serial_SerialPort</span></span><br><span class="line"><span class="comment"> * Method:    close</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * Closes the serial port by releasing the file descriptor associated with it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL <span class="title function_">Java_com_crow_modbus_serialport_SerialPort_close</span><span class="params">(JNIEnv *env, jobject thiz)</span> &#123;</span><br><span class="line">    jclass SerialPortClass = (*env)-&gt;GetObjectClass(env, thiz);</span><br><span class="line">    jclass FileDescriptorClass = (*env)-&gt;FindClass(env, <span class="string">&quot;java/io/FileDescriptor&quot;</span>);</span><br><span class="line"></span><br><span class="line">    jfieldID mFdID = (*env)-&gt;GetFieldID(env, SerialPortClass, <span class="string">&quot;mFileDescriptor&quot;</span>, <span class="string">&quot;Ljava/io/FileDescriptor;&quot;</span>);</span><br><span class="line">    jfieldID descriptorID = (*env)-&gt;GetFieldID(env, FileDescriptorClass, <span class="string">&quot;fd&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line"></span><br><span class="line">    jobject mFd = (*env)-&gt;GetObjectField(env, thiz, mFdID);</span><br><span class="line">    jint descriptor = (*env)-&gt;GetIntField(env, mFd, descriptorID);</span><br><span class="line"></span><br><span class="line">    LOGD(<span class="string">&quot;close(fd = %d)&quot;</span>, descriptor);</span><br><span class="line">    close(descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><div class="note purple icon-padding modern"><i class="note-icon fab fa-kotlin"></i><ul><li>上层接口封装</li><li>数据读写操作  </li><li>异常处理机制</li><li>串口参数配置</li></ul></div><h3 id="🔌-接口声明"><a href="#🔌-接口声明" class="headerlink" title="🔌 接口声明"></a>🔌 接口声明</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SerialPort</span> <span class="keyword">protected</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mFileDescriptor: FileDescriptor? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            <span class="comment">// 加载共享库</span></span><br><span class="line">            System.loadLibrary(<span class="string">&quot;SerialPort&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ● 打开串口</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> path 串口文件路径</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> baudrate 波特率</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parity 校验</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> stopbit 停止位 1 或 2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> databit 数据位 5 - 8</span></span><br><span class="line"><span class="comment">    * ● 2023-09-25 18:29:58 周一 下午</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">open</span><span class="params">(path: <span class="type">String</span>, baudrate: <span class="type">Int</span>, parity: <span class="type">SerialPortParityFunction</span>, stopbit: <span class="type">Int</span>, databit: <span class="type">Int</span>)</span></span>: FileDescriptor &#123;</span><br><span class="line">        <span class="keyword">if</span> (stopbit !<span class="keyword">in</span> <span class="number">1.</span><span class="number">.2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;stopbit must in 1..2!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (databit !<span class="keyword">in</span> <span class="number">5.</span><span class="number">.8</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;databit must in 5..8!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">open</span>(path, baudrate, <span class="number">0</span>, parity.code, stopbit, databit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义JNI方法，用于打开串口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">open</span><span class="params">(path: <span class="type">String</span>, baudrate: <span class="type">Int</span>, flags: <span class="type">Int</span>, parity: <span class="type">Int</span>, stopbits: <span class="type">Int</span>, databits: <span class="type">Int</span>)</span></span>: FileDescriptor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义JNI方法，用于关闭串口</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩-串口管理封装"><a href="#🚩-串口管理封装" class="headerlink" title="🚩 串口管理封装"></a>🚩 串口管理封装</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SerialPortManager</span> : <span class="type">SerialPort</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> mutex = Mutex()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> parentJob = SupervisorJob()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> io = CoroutineScope(Dispatchers.IO + parentJob + CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">            loggerError(<span class="string">&quot;SerialPort an Exception occurs! context is <span class="variable">$coroutineContext</span> \t exception : <span class="subst">$&#123;throwable.stackTraceToString()&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mSuccessListener: IOpenSerialPortSuccess? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mFailureListener: IOpenSerialPortFailure? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mFileInputStream: FileInputStream? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mFileOutputStream: FileOutputStream? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mReadedBuffer = Bytes(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ● 修改文件权限为可读、可写、可执行</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * ● 2023-09-23 11:41:26 周六 上午</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">changeFilePermissions</span><span class="params">(file: <span class="type">File</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (file.takeIf &#123; it.exists() &#125; ?: <span class="literal">false</span>).runCatching &#123;</span><br><span class="line"></span><br><span class="line">            logger(<span class="string">&quot;info&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取ROOT权限</span></span><br><span class="line">            <span class="keyword">val</span> su = Runtime.getRuntime().exec(<span class="string">&quot;/system/bin/su&quot;</span>)</span><br><span class="line"></span><br><span class="line">            logger(su)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改文件属性为 [可读 可写 可执行]</span></span><br><span class="line">            <span class="keyword">val</span> cmd = <span class="string">&quot;chmod 777 <span class="subst">$&#123;file.absolutePath&#125;</span>\nexit\n&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将命令写入 su 进程的输出流</span></span><br><span class="line">            su.outputStream.write(cmd.toByteArray())</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 su 进程返回值为 0 并且文件可读、可写、可执行，则返回 true</span></span><br><span class="line">            (su.waitFor() == <span class="number">0</span> &amp;&amp; file.canRead() &amp;&amp; file.canWrite() &amp;&amp; file.canExecute())</span><br><span class="line">        &#125;</span><br><span class="line">        .onFailure &#123; <span class="keyword">catch</span> -&gt;</span><br><span class="line">            <span class="keyword">when</span> (<span class="keyword">catch</span>) &#123;</span><br><span class="line">                <span class="keyword">is</span> IOException -&gt; logger(<span class="string">&quot;No root permission!&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span> -&gt; logger(<span class="keyword">catch</span>.stackTraceToString())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .getOrElse &#123; <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ● 打开串口</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * ● 2023-09-23 16:02:30 周六 下午</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">openSerialPort</span><span class="params">(path: <span class="type">String</span>, baudRate: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> device = File(path)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验串口权限</span></span><br><span class="line">        <span class="keyword">if</span> (!device.canRead() || !device.canWrite()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changeFilePermissions(device)) &#123;</span><br><span class="line">                loggerError(<span class="string">&quot;openSerialPort : 没有读写权限!&quot;</span>)</span><br><span class="line">                mFailureListener?.onFailure(device, SerialPortState.NO_READ_WRITE_PERMISSION)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFileDescriptor = <span class="keyword">open</span>(device.absolutePath, baudRate, SerialPortParityFunction.EVEN, <span class="number">1</span>, <span class="number">8</span>)</span><br><span class="line">        mFileInputStream = FileInputStream(mFileDescriptor)</span><br><span class="line">        mFileOutputStream = FileOutputStream(mFileDescriptor)</span><br><span class="line">        mSuccessListener?.onSuccess(device)</span><br><span class="line">        logger(<span class="string">&quot;openSerialPort : 串口已经打开 <span class="variable">$mFileDescriptor</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ● 关闭串口</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * ● 2023-09-23 16:02:12 周六 下午</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">closeSerialPort</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> runCatching &#123;</span><br><span class="line">            parentJob.children.forEach &#123; job -&gt; job.cancel() &#125;</span><br><span class="line">            mFileDescriptor = <span class="literal">null</span></span><br><span class="line">            mFileInputStream?.close()</span><br><span class="line">            mFileOutputStream?.close()</span><br><span class="line">            mFileInputStream = <span class="literal">null</span></span><br><span class="line">            mFileOutputStream = <span class="literal">null</span></span><br><span class="line">            mSuccessListener = <span class="literal">null</span></span><br><span class="line">            mFailureListener = <span class="literal">null</span></span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onFailure &#123; <span class="keyword">catch</span> -&gt; loggerError(<span class="string">&quot;close serial port exception! <span class="subst">$&#123;catch.stackTraceToString()&#125;</span>&quot;</span>) &#125;</span><br><span class="line">        .getOrElse &#123; <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OptIn(ExperimentalStdlibApi::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">writeBytes</span><span class="params">(bytes: <span class="type">ByteArray</span>)</span></span> &#123;</span><br><span class="line">        io.launch &#123;</span><br><span class="line">            mutex.withLock &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != mFileDescriptor &amp;&amp; <span class="literal">null</span> != mFileInputStream &amp;&amp; <span class="literal">null</span> != mFileOutputStream) &#123;</span><br><span class="line">                    logger(<span class="string">&quot;writeBytes <span class="subst">$&#123;bytes.map &#123; it.toHexString() &#125;</span>&#125;&quot;</span>)</span><br><span class="line">                    mFileOutputStream!!.write(bytes)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBytes</span><span class="params">(iDataReceive: <span class="type">IDataReceive</span>)</span></span> &#123;</span><br><span class="line">        io.launch &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != mFileDescriptor &amp;&amp; <span class="literal">null</span> != mFileInputStream &amp;&amp; <span class="literal">null</span> != mFileOutputStream) &#123;</span><br><span class="line">                    <span class="keyword">val</span> length = mFileInputStream!!.read(mReadedBuffer)</span><br><span class="line">                    logger(<span class="string">&quot;<span class="variable">$length</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">if</span> (length &lt;= <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@launch</span></span><br><span class="line">                    <span class="keyword">val</span> buffer = Bytes(length)</span><br><span class="line">                    System.arraycopy(mReadedBuffer, <span class="number">0</span>, buffer, <span class="number">0</span>, length)</span><br><span class="line">                    iDataReceive.onReceive(buffer)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🎯-关键要点总结"><a href="#🎯-关键要点总结" class="headerlink" title="🎯 关键要点总结"></a>🎯 关键要点总结</h2><div class="note success icon-padding modern"><i class="note-icon fas fa-check-circle"></i><p><strong>本文重点内容：</strong></p><ol><li>✅ 理解Android串口通信的基本原理</li><li>✅ 掌握JNI层串口开启和关闭的实现</li><li>✅ 学会串口参数的配置方法</li><li>✅ 了解文件描述符创建和管理</li></ol></div><h2 id="🔗-相关链接"><a href="#🔗-相关链接" class="headerlink" title="🔗 相关链接"></a>🔗 相关链接</h2><div class="btn-center"><a class="btn-beautify blue larger" href="https://github.com/crowforkotlin/KModbus" title="KModbus项目"><i class="fab fa-github"></i><span>KModbus项目</span></a><a class="btn-beautify green larger" href="https://github.com/stephane/libmodbus" title="LibModbus参考"><i class="fab fa-github"></i><span>LibModbus参考</span></a></div>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> JNI </tag>
            
            <tag> Java </tag>
            
            <tag> Kotlin </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>① Android JNI 入门指南</title>
      <link href="/2023/09/27/Android/01JNI%E5%85%A5%E9%97%A8/"/>
      <url>/2023/09/27/Android/01JNI%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<div class="note modern"><p>🎯 <strong>学习目标</strong>：通过本教程，你将掌握 Android JNI 开发的基础知识，学会如何在 Android 项目中集成和使用 C&#x2F;C++ 代码。</p></div><h2 id="📖-概述"><a href="#📖-概述" class="headerlink" title="📖 概述"></a>📖 概述</h2><p><strong>JNI（Java Native Interface）</strong> 是 Java 平台的一部分，它允许在 Java 虚拟机内运行的 Java 代码调用并被用其他编程语言（如 C、C++）编写的应用程序和库调用。</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">🚀 性能优化</button><button type="button" class="tab">🔧 系统调用</button><button type="button" class="tab">📚 代码复用</button></div><div class="tab-contents"><div class="tab-item-content active"><p>将计算密集型任务移至 C&#x2F;C++ 层执行，充分利用原生代码的性能优势：</p><ul><li>图像处理算法</li><li>音视频编解码</li><li>加密解密运算</li><li>数学计算库</li></ul></div><div class="tab-item-content"><p>直接调用 Linux 系统底层 API，访问 Java 层无法直接使用的功能：</p><ul><li>串口通信</li><li>GPIO 控制</li><li>文件系统操作</li><li>网络底层协议</li></ul></div><div class="tab-item-content"><p>集成现有的成熟 C&#x2F;C++ 库，避免重复开发：</p><ul><li>OpenCV 图像处理</li><li>FFmpeg 音视频处理</li><li>OpenSSL 加密库</li><li>第三方算法库</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="🛠️-基本配置步骤"><a href="#🛠️-基本配置步骤" class="headerlink" title="🛠️ 基本配置步骤"></a>🛠️ 基本配置步骤</h2><div class="note info icon-padding flat"><i class="note-icon fas fa-info-circle"></i><p><strong>开始之前</strong>：确保你已经安装了 Android Studio 和相关开发工具</p></div><h3 id="📋-前置要求"><a href="#📋-前置要求" class="headerlink" title="📋 前置要求"></a>📋 前置要求</h3><div class="note success icon-padding flat"><i class="note-icon fas fa-check-circle"></i><p>✅ <strong>必需工具清单</strong></p><ul><li>Android Studio（最新版本）</li><li>NDK（Native Development Kit）</li><li>CMake 构建工具</li><li>Git（用于版本管理）</li></ul></div><h3 id="�-配置流程"><a href="#�-配置流程" class="headerlink" title="� 配置流程"></a>� 配置流程</h3><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph TD    A[📱 创建 Android 项目] --&gt; B[⚙️ 配置 Gradle]    B --&gt; C[📁 创建 cpp 目录]    C --&gt; D[📝 编写 C&#x2F;C++ 代码]    D --&gt; E[🔗 声明 Native 方法]    E --&gt; F[📚 加载动态库]    F --&gt; G[🎉 编译运行]  </pre></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-lightbulb"></i><p><strong>开发提示</strong>：建议按照上述流程逐步配置，每完成一步都进行测试验证。</p></div><h2 id="⚙️-详细配置"><a href="#⚙️-详细配置" class="headerlink" title="⚙️ 详细配置"></a>⚙️ 详细配置</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">📝 Gradle 配置</button><button type="button" class="tab">🔨 CMake 配置</button><button type="button" class="tab">☕ Java/Kotlin 代码</button><button type="button" class="tab">🔧 C/C++ 实现</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="1-Gradle-配置"><a href="#1-Gradle-配置" class="headerlink" title="1. Gradle 配置"></a>1. Gradle 配置</h3><p>在 <code>app/build.gradle.kts</code> 文件中添加 NDK 和 CMake 配置：</p><div class="note orange icon-padding flat"><i class="note-icon fas fa-file-code"></i><p><strong>配置文件</strong>：<code>app/build.gradle.kts</code></p></div><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// ...其他配置</span></span><br><span class="line">    </span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="comment">// ...其他配置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 配置 NDK 支持的 ABI 架构</span></span><br><span class="line">        ndk &#123;</span><br><span class="line">            abiFilters += listOf(<span class="string">&quot;armeabi-v7a&quot;</span>, <span class="string">&quot;arm64-v8a&quot;</span>, <span class="string">&quot;x86&quot;</span>, <span class="string">&quot;x86_64&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 CMake 构建系统</span></span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path = file(<span class="string">&quot;CMakeLists.txt&quot;</span>)</span><br><span class="line">            version = <span class="string">&quot;3.18.1&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning icon-padding flat"><i class="note-icon fas fa-exclamation-triangle"></i><p><strong>注意</strong>：ABI 架构建议根据目标设备选择，过多的架构会增加 APK 体积。</p></div></div><div class="tab-item-content"><h3 id="2-CMake-配置"><a href="#2-CMake-配置" class="headerlink" title="2. CMake 配置"></a>2. CMake 配置</h3><p>在项目根目录创建 <code>CMakeLists.txt</code> 文件：</p><div class="note purple icon-padding flat"><i class="note-icon fas fa-hammer"></i><p><strong>配置文件</strong>：<code>CMakeLists.txt</code></p></div><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.18</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目名称</span></span><br><span class="line"><span class="keyword">project</span>(<span class="string">&quot;SerialPortDemo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加库文件 - 创建名为 SerialPort 的共享动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">    SerialPort                    <span class="comment"># 库名称</span></span><br><span class="line">    SHARED                        <span class="comment"># 库类型：共享库</span></span><br><span class="line">    src/main/cpp/SerialPort.h     <span class="comment"># 头文件</span></span><br><span class="line">    src/main/cpp/SerialPort.c     <span class="comment"># 源文件</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 Android 系统库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    SerialPort                    <span class="comment"># 目标库</span></span><br><span class="line">    android                       <span class="comment"># Android 系统库</span></span><br><span class="line">    log                          <span class="comment"># 日志库</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><div class="note green icon-padding modern"><i class="note-icon fas fa-check"></i><p><strong>构建说明</strong>：CMake 会自动处理跨平台编译，生成对应架构的 <code>.so</code> 动态库文件。</p></div></div><div class="tab-item-content"><h3 id="3-Java-x2F-Kotlin-中的-Native-方法声明"><a href="#3-Java-x2F-Kotlin-中的-Native-方法声明" class="headerlink" title="3. Java&#x2F;Kotlin 中的 Native 方法声明"></a>3. Java&#x2F;Kotlin 中的 Native 方法声明</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">🟢 Kotlin 版本</button><button type="button" class="tab">☕ Java 版本</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="note green icon-padding flat"><i class="note-icon fab fa-kotlin"></i><p><strong>推荐使用</strong>：Kotlin 是 Android 官方首选语言</p></div><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.serialport</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileDescriptor</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SerialPort</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">// 静态初始化块 - 加载 Native 库</span></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;SerialPort&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开串口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 串口设备路径，如 &quot;/dev/ttyS0&quot;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> baudrate 波特率，如 9600, 115200</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flags 标志位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parity 校验位：0-无校验，1-奇校验，2-偶校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stopbits 停止位：1 或 2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> databits 数据位：5, 6, 7, 8</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 文件描述符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        path: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        baudrate: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        flags: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        parity: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        stopbits: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        databits: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: FileDescriptor?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭串口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><div class="note orange icon-padding flat"><i class="note-icon fab fa-java"></i><p><strong>经典选择</strong>：适合熟悉传统 Java 开发的开发者</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.serialport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileDescriptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerialPort</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态初始化块 - 加载 Native 库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;SerialPort&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开串口（Native 方法）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> FileDescriptor <span class="title function_">open</span><span class="params">(String path, <span class="type">int</span> baudrate, <span class="type">int</span> flags, </span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> parity, <span class="type">int</span> stopbits, <span class="type">int</span> databits)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭串口（Native 方法）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tab-item-content"><h3 id="4-C-x2F-C-实现"><a href="#4-C-x2F-C-实现" class="headerlink" title="4. C&#x2F;C++ 实现"></a>4. C&#x2F;C++ 实现</h3><p>在 <code>app/src/main/cpp/SerialPort.c</code> 中实现 Native 方法：</p><div class="note red icon-padding flat"><i class="note-icon fas fa-code"></i><p><strong>核心代码</strong>：C&#x2F;C++ 原生实现</p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志标签</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_TAG <span class="string">&quot;SerialPort-JNI&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JNI 函数命名规则：</span></span><br><span class="line"><span class="comment"> * JNIEXPORT 返回类型 JNICALL Java_包名_类名_方法名</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param env JNI 环境指针</span></span><br><span class="line"><span class="comment"> * @param thiz 调用该方法的类实例（如果是静态方法则为类对象）</span></span><br><span class="line"><span class="comment"> * @param path 串口设备路径</span></span><br><span class="line"><span class="comment"> * @param baudrate 波特率</span></span><br><span class="line"><span class="comment"> * @param flags 打开标志</span></span><br><span class="line"><span class="comment"> * @param parity 校验位</span></span><br><span class="line"><span class="comment"> * @param stopbits 停止位</span></span><br><span class="line"><span class="comment"> * @param databits 数据位</span></span><br><span class="line"><span class="comment"> * @return 返回 FileDescriptor 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jobject JNICALL </span><br><span class="line"><span class="title function_">Java_com_example_serialport_SerialPort_open</span><span class="params">(JNIEnv *env, jobject thiz, </span></span><br><span class="line"><span class="params">                                           jstring path, jint baudrate, jint flags, </span></span><br><span class="line"><span class="params">                                           jint parity, jint stopbits, jint databits)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 Java String 转换为 C 字符串</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *path_utf = (*env)-&gt;GetStringUTFChars(env, path, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    LOGD(<span class="string">&quot;Opening serial port: %s&quot;</span>, path_utf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开串口设备</span></span><br><span class="line">    <span class="type">int</span> fd = open(path_utf, O_RDWR | O_NOCTTY | O_NONBLOCK);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放字符串内存</span></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, path, path_utf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">&quot;Failed to open serial port: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置串口参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">tios</span>;</span></span><br><span class="line">    tcgetattr(fd, &amp;tios);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置波特率、数据位、停止位、校验位等...</span></span><br><span class="line">    <span class="comment">// (具体实现省略)</span></span><br><span class="line">    </span><br><span class="line">    tcsetattr(fd, TCSANOW, &amp;tios);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 FileDescriptor 对象</span></span><br><span class="line">    jclass cFileDescriptor = (*env)-&gt;FindClass(env, <span class="string">&quot;java/io/FileDescriptor&quot;</span>);</span><br><span class="line">    jmethodID iFileDescriptor = (*env)-&gt;GetMethodID(env, cFileDescriptor, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    jobject jFileDescriptor = (*env)-&gt;NewObject(env, cFileDescriptor, iFileDescriptor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 fd 字段</span></span><br><span class="line">    jfieldID descriptorID = (*env)-&gt;GetFieldID(env, cFileDescriptor, <span class="string">&quot;descriptor&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">    (*env)-&gt;SetIntField(env, jFileDescriptor, descriptorID, (jint)fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> jFileDescriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭串口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL </span><br><span class="line"><span class="title function_">Java_com_example_serialport_SerialPort_close</span><span class="params">(JNIEnv *env, jobject thiz)</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭串口的实现</span></span><br><span class="line">    LOGD(<span class="string">&quot;Closing serial port&quot;</span>);</span><br><span class="line">    <span class="comment">// 具体实现...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note pink icon-padding modern"><i class="note-icon fas fa-magic"></i><p><strong>编程技巧</strong>：使用 Android Log 系统可以方便地调试 C&#x2F;C++ 代码。</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## JNI 函数命名规则</span><br><span class="line"></span><br><span class="line">JNI 函数必须遵循特定的命名规则：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JNIEXPORT 返回类型 JNICALL Java_完整包名_类名_方法名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 示例解析</span><br><span class="line"></span><br><span class="line">对于包名为 `com.example.serialport`，类名为 `SerialPort`，方法名为 `open` 的函数：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">JNIEXPORT jobject JNICALL </span><br><span class="line">Java_com_example_serialport_SerialPort_open(JNIEnv *env, jobject thiz, ...)</span><br></pre></td></tr></table></figure><ul><li><code>com.example.serialport</code> → <code>com_example_serialport</code></li><li>包名中的点(<code>.</code>)替换为下划线(<code>_</code>)</li><li>类名和方法名直接拼接</li></ul><h2 id="常见问题与注意事项"><a href="#常见问题与注意事项" class="headerlink" title="常见问题与注意事项"></a>常见问题与注意事项</h2><h3 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a>⚠️ 注意事项</h3><ol><li><strong>内存管理</strong>：使用 <code>GetStringUTFChars</code> 后必须调用 <code>ReleaseStringUTFChars</code></li><li><strong>异常处理</strong>：JNI 调用可能产生异常，需要适当处理</li><li><strong>线程安全</strong>：JNI 调用需要考虑线程安全问题</li><li><strong>性能影响</strong>：频繁的 Java-Native 调用会影响性能</li></ol><h3 id="🔧-常见错误"><a href="#🔧-常见错误" class="headerlink" title="🔧 常见错误"></a>🔧 常见错误</h3><ul><li><strong>UnsatisfiedLinkError</strong>：通常是库加载失败或函数签名不匹配</li><li><strong>FindClass 失败</strong>：类名路径错误或类不存在</li><li><strong>内存泄漏</strong>：忘记释放 JNI 分配的内存</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Android JNI 开发虽然入门门槛较高，但掌握基本流程后就能够：</p><ol><li><strong>性能优化</strong>：将计算密集型任务移至 C&#x2F;C++ 层</li><li><strong>系统调用</strong>：直接调用 Linux 系统 API</li><li><strong>代码复用</strong>：集成现有的 C&#x2F;C++ 库</li></ol><p>通过本教程的配置和示例，你应该能够开始自己的 JNI 开发之旅。建议从简单的函数开始，逐步深入学习更复杂的 JNI 特性。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://developer.android.com/ndk">Android NDK 官方文档</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/">JNI 规范</a></li><li><a href="https://cmake.org/documentation/">CMake 官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> JNI </tag>
            
            <tag> Java </tag>
            
            <tag> Kotlin </tag>
            
            <tag> C </tag>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
